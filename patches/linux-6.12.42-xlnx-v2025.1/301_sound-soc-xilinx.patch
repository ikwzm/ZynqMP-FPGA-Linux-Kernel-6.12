diff --git a/Documentation/devicetree/bindings/sound/xlnx,audio-formatter.txt b/Documentation/devicetree/bindings/sound/xlnx,audio-formatter.txt
deleted file mode 100644
index cbc93c8f4..000000000
--- a/Documentation/devicetree/bindings/sound/xlnx,audio-formatter.txt
+++ /dev/null
@@ -1,29 +0,0 @@
-Device-Tree bindings for Xilinx PL audio formatter
-
-The IP core supports DMA, data formatting(AES<->PCM conversion)
-of audio samples.
-
-Required properties:
- - compatible: "xlnx,audio-formatter-1.0"
- - interrupt-names: Names specified to list of interrupts in same
-		    order mentioned under "interrupts".
-		    List of supported interrupt names are:
-		    "irq_mm2s" : interrupt from MM2S block
-		    "irq_s2mm" : interrupt from S2MM block
- - interrupts-parent: Phandle for interrupt controller.
- - interrupts: List of Interrupt numbers.
- - reg: Base address and size of the IP core instance.
- - clock-names: List of input clocks.
-   Required elements: "s_axi_lite_aclk", "aud_mclk"
- - clocks: Input clock specifier. Refer to common clock bindings.
-
-Example:
-	audio_ss_0_audio_formatter_0: audio_formatter@80010000 {
-		compatible = "xlnx,audio-formatter-1.0";
-		interrupt-names = "irq_mm2s", "irq_s2mm";
-		interrupt-parent = <&gic>;
-		interrupts = <0 104 4>, <0 105 4>;
-		reg = <0x0 0x80010000 0x0 0x1000>;
-		clock-names = "s_axi_lite_aclk", "aud_mclk";
-		clocks = <&clk 71>, <&clk_wiz_1 0>;
-	};
diff --git a/Documentation/devicetree/bindings/sound/xlnx,audio-formatter.yaml b/Documentation/devicetree/bindings/sound/xlnx,audio-formatter.yaml
new file mode 100644
index 000000000..b2cf69c0c
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/xlnx,audio-formatter.yaml
@@ -0,0 +1,92 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+# %YAML 1.2
+---
+$id: http://devicetree.org/schemas/sound/xlnx,audio-formatter.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx Audio DMA for Playback/Capture audio system
+
+maintainers:
+  - Katta Dhanunjanrao <katta.dhanunjanrao@amd.com>
+
+description:
+  The IP core supports DMA, data formatting(packing, conversion)
+  of audio samples.The Audio formatter provides high-bandwidth direct
+  memory access between memory and AXI4-Stream target peripherals.
+
+properties:
+  compatible:
+    const: xlnx,audio-formatter-1.0
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    minItems: 1
+    maxItems: 2
+
+  interrupt-names:
+    description: List of supported interrupts are
+                 irq_mm2s interrupt from MM2S block and
+                 irq_s2mm interrupt from S2MM block.
+    items:
+      - const: irq_mm2s
+      - const: irq_s2mm
+
+  clocks:
+    maxItems: 4
+    description: Input clock specifier. Refer to common clock bindings.
+
+  clock-names:
+    items:
+      - const: s_axi_lite_aclk
+      - const: m_axis_mm2s_aclk
+      - const: aud_mclk
+      - const: s_axis_s2mm_aclk
+
+  xlnx,tx:
+    description: connected audio sink node.
+                 Should be one of below supported nodes
+                 1. HDMI video Tx output
+                 2. I2S transmitter
+                 3. UHDSDI audio embed
+                 4. DP video Tx output
+                 5. SPDIF transmitter
+                 Only these nodes were supported in sound card driver.
+    $ref: /schemas/types.yaml#/definitions/phandle
+
+  xlnx,rx:
+    description: Audio formatter connected audio source node.
+                 Should be one of below supported node.
+                 1. HDMI video Rx input
+                 2. I2S receiver
+                 3. UHDSDI audio extract
+                 4. DP video Rx output
+                 5. SPDIF receiver
+                 Only these nodes were supported in sound card driver.
+    $ref: /schemas/types.yaml#/definitions/phandle
+
+required:
+  - reg
+  - interrupts
+  - interrupt-names
+  - clock-names
+  - clocks
+  - xlnx,tx
+  - xlnx,rx
+
+additionalProperties: false
+
+examples:
+  - |
+    audio-formatter@80010000 {
+      compatible = "xlnx,audio-formatter-1.0";
+      reg = <0x80010000 0x1000>;
+      interrupts = <0 104 4>, <0 105 4>;
+      interrupt-names = "irq_mm2s", "irq_s2mm";
+      clock-names = "s_axi_lite_aclk", "m_axis_mm2s_aclk", "aud_mclk", "s_axis_s2mm_aclk";
+      clocks = <&clk 71>, <&audio_ss_0_clk_wiz_0 0>, <&audio_ss_0_clk_wiz_0 0>, <&clk 71>;
+      xlnx,tx = <&i2s_transmitter>;
+      xlnx,rx = <&i2s_receiver>;
+    };
+...
diff --git a/Documentation/devicetree/bindings/sound/xlnx,i2s.txt b/Documentation/devicetree/bindings/sound/xlnx,i2s.txt
deleted file mode 100644
index 5e7c7d5bb..000000000
--- a/Documentation/devicetree/bindings/sound/xlnx,i2s.txt
+++ /dev/null
@@ -1,28 +0,0 @@
-Device-Tree bindings for Xilinx I2S PL block
-
-The IP supports I2S based playback/capture audio
-
-Required property:
- - compatible: "xlnx,i2s-transmitter-1.0" for playback and
-	       "xlnx,i2s-receiver-1.0" for capture
-
-Required property common to both I2S playback and capture:
- - reg: Base address and size of the IP core instance.
- - xlnx,dwidth: sample data width. Can be any of 16, 24.
- - xlnx,num-channels: Number of I2S streams. Can be any of 1, 2, 3, 4.
-		      supported channels = 2 * xlnx,num-channels
-
-Example:
-
-	i2s_receiver@a0080000 {
-		compatible = "xlnx,i2s-receiver-1.0";
-		reg = <0x0 0xa0080000 0x0 0x10000>;
-		xlnx,dwidth = <0x18>;
-		xlnx,num-channels = <1>;
-	};
-	i2s_transmitter@a0090000 {
-		compatible = "xlnx,i2s-transmitter-1.0";
-		reg = <0x0 0xa0090000 0x0 0x10000>;
-		xlnx,dwidth = <0x18>;
-		xlnx,num-channels = <1>;
-	};
diff --git a/Documentation/devicetree/bindings/sound/xlnx,i2s.yaml b/Documentation/devicetree/bindings/sound/xlnx,i2s.yaml
new file mode 100644
index 000000000..170ebf731
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/xlnx,i2s.yaml
@@ -0,0 +1,115 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+# %YAML 1.2
+---
+$id: http://devicetree.org/schemas/sound/xlnx,i2s.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx I2S Playback/Capture audio system
+
+maintainers:
+  - Katta Dhanunjanrao <katta.dhanunjanrao@amd.com>
+
+description:
+  IP I2S Transmitter and receiver cores are soft IP cores in AMD Vivado
+  design suite which make it easy to implement Inter-IC-Sound (I2S)
+  interface used to connect audio devices for transmitting and
+  receiving PCM audio.
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - xlnx,i2s-transmitter-1.0
+          - xlnx,i2s-receiver-1.0
+  reg:
+    maxItems: 1
+
+  clocks:
+    description: List of clock specifiers.
+    items:
+      - description: Input audio clock.
+      - description: Input clock for AXI4-Lite Interface.
+      - description: AXIS Audio streaming clock.
+
+  clock-names:
+    maxItems: 3
+
+  interrupts:
+    maxItems: 1
+
+  xlnx,dwidth:
+    description: Indicates the I2S data width of the core.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    enum: [16, 24]
+
+  xlnx,num-channels:
+    description: Indicates the number of audio channels supported.
+                 supported channels = 2 * xlnx,num-channels.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    enum: [1, 2, 3, 4]
+
+  xlnx,snd-pcm:
+    description: Reference to audio formatter block.
+    $ref: /schemas/types.yaml#/definitions/phandle
+
+  xlnx,32bit-lr:
+    type: boolean
+    description: Core configuration either master or slave.
+
+required:
+  - reg
+  - clocks
+  - clock-names
+  - xlnx,dwidth
+  - xlnx,num-channels
+  - xlnx,snd-pcm
+
+additionalProperties: false
+
+allOf:
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: xlnx,i2s-transmitter-1.0
+    then:
+      properties:
+        clock-names:
+          items:
+            - const: aud_mclk
+            - const: s_axi_ctrl_aclk
+            - const: s_axis_aud_aclk
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: xlnx,i2s-receiver-1.0
+    then:
+      properties:
+        clock-names:
+          items:
+            - const: aud_mclk
+            - const: s_axi_ctrl_aclk
+            - const: m_axis_aud_aclk
+
+examples:
+  - |
+   i2s-transmitter@a00d0000 {
+     compatible = "xlnx,i2s-transmitter-1.0";
+     reg = <0xa00d0000 0x10000>;
+     clocks = <&audio_ss_0_clk_wiz_0 0>, <&zynqmp_clk 71>, <&audio_ss_0_clk_wiz_0 0>;
+     clock-names = "aud_mclk" , "s_axi_ctrl_aclk" , "s_axis_aud_aclk";
+     xlnx,dwidth = <0x18>;
+     xlnx,num-channels = <0x1>;
+     xlnx,snd-pcm = <&audio_ss_0_audio_formatter_2>;
+   };
+   i2s-receiver@a00c0000 {
+     compatible = "xlnx,i2s-receiver-1.0";
+     reg = <0xa00d0000 0x10000>;
+     clocks = <&audio_ss_0_clk_wiz_0 0>, <&zynqmp_clk 71>, <&audio_ss_0_clk_wiz_0 0>;
+     clock-names = "aud_mclk" , "s_axi_ctrl_aclk", "m_axis_aud_aclk";
+     xlnx,dwidth = <0x18>;
+     xlnx,num-channels = <0x1>;
+     xlnx,snd-pcm = <&audio_ss_0_audio_formatter_2>;
+   };
+...
diff --git a/Documentation/devicetree/bindings/sound/xlnx,spdif.txt b/Documentation/devicetree/bindings/sound/xlnx,spdif.txt
deleted file mode 100644
index 15c2d64d2..000000000
--- a/Documentation/devicetree/bindings/sound/xlnx,spdif.txt
+++ /dev/null
@@ -1,28 +0,0 @@
-Device-Tree bindings for Xilinx SPDIF IP
-
-The IP supports playback and capture of SPDIF audio
-
-Required properties:
- - compatible: "xlnx,spdif-2.0"
- - clock-names: List of input clocks.
-   Required elements: "s_axi_aclk", "aud_clk_i"
- - clocks: Input clock specifier. Refer to common clock bindings.
- - reg: Base address and address length of the IP core instance.
- - interrupts-parent: Phandle for interrupt controller.
- - interrupts: List of Interrupt numbers.
- - xlnx,spdif-mode: 0 :- receiver mode
-		    1 :- transmitter mode
- - xlnx,aud_clk_i: input audio clock value.
-
-Example:
-	spdif_0: spdif@80010000 {
-		clock-names = "aud_clk_i", "s_axi_aclk";
-		clocks = <&misc_clk_0>, <&clk 71>;
-		compatible = "xlnx,spdif-2.0";
-		interrupt-names = "spdif_interrupt";
-		interrupt-parent = <&gic>;
-		interrupts = <0 91 4>;
-		reg = <0x0 0x80010000 0x0 0x10000>;
-		xlnx,spdif-mode = <1>;
-		xlnx,aud_clk_i = <49152913>;
-	};
diff --git a/Documentation/devicetree/bindings/sound/xlnx,spdif.yaml b/Documentation/devicetree/bindings/sound/xlnx,spdif.yaml
new file mode 100644
index 000000000..501269779
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/xlnx,spdif.yaml
@@ -0,0 +1,98 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+# %YAML 1.2
+---
+$id: http://devicetree.org/schemas/sound/xlnx,spdif.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx S/PDIF/AES3 Playback/Capture audio system
+
+maintainers:
+  - Katta Dhanunjanrao <katta.dhanunjanrao@amd.com>
+
+description:
+  IP SPDIF/AES3 cores are soft IP cores in AMD Vivado.
+  The Sony/Philips Digital Interconnect Format (SPDIF) and AES3
+  are digital audio interfaces that implements the IEC 60958 interface
+  for transmitting and receiving audio data.
+
+properties:
+  compatible:
+    const: xlnx,spdif-2.0
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    description: List of clock specifiers.
+    items:
+      - description: Audio clock input used at the SPDIF/AES3 interface.
+      - description: Axi4-Lite clock.
+      - description: Axi4-Stream global clock signal.
+
+  clock-names:
+    maxItems: 3
+
+  interrupts:
+    maxItems: 1
+
+  xlnx,spdif-mode:
+    description: Mode of spdif IP operation either playback or capture.
+                 0 - is for receiver mode and 1 - is for the transmitter mode.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    enum: [0, 1]
+
+  xlnx,snd-pcm:
+    description: Reference to audio formatter block.
+    $ref: /schemas/types.yaml#/definitions/phandle
+
+required:
+  - reg
+  - clocks
+  - clock-names
+  - interrupts
+  - xlnx,spdif-mode
+  - xlnx,snd-pcm
+
+additionalProperties: false
+
+allOf:
+  - if:
+      properties:
+        xlnx,spdif-mode:
+          const: 1 # Transmitter Mode
+    then:
+      properties:
+        clock-names:
+          items:
+            - const: aud_clk_i
+            - const: s_axi_aclk
+            - const: s_axis_aclk
+    else:
+      properties:
+        clock-names:
+          items:
+            - const: aud_clk_i
+            - const: s_axi_aclk
+            - const: m_axis_aclk
+
+examples:
+  - |
+    spdif@800a0000 {
+      compatible = "xlnx,spdif-2.0";
+      reg = <0x800a0000 0x10000>;
+      clocks = <&misc_clk_0>, <&zynqmp_clk 71>, <&misc_clk_0>;
+      clock-names = "aud_clk_i", "s_axi_aclk", "s_axis_aclk";
+      interrupts = <0 89 4>;
+      xlnx,spdif-mode = <1>;
+      xlnx,snd-pcm = <&audio_formatter>;
+    };
+    spdif@80090000 {
+      compatible = "xlnx,spdif-2.0";
+      reg = <0x80090000 0x10000>;
+      clocks = <&misc_clk_0>, <&zynqmp_clk 71>, <&zynqmp_clk 71>;
+      clock-names = "aud_clk_i" , "s_axi_aclk" , "m_axis_aclk";
+      interrupts = <0 90 4>;
+      xlnx,spdif-mode = <0>;
+      xlnx,snd-pcm = <&audio_formatter>;
+    };
+...
diff --git a/Documentation/devicetree/bindings/sound/xlnx,v-uhdsdi-audio.yaml b/Documentation/devicetree/bindings/sound/xlnx,v-uhdsdi-audio.yaml
new file mode 100644
index 000000000..85cf1b15c
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/xlnx,v-uhdsdi-audio.yaml
@@ -0,0 +1,140 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+# %YAML 1.2
+---
+$id: http://devicetree.org/schemas/sound/xlnx,v-uhdsdi-audio.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx UHD SDI Playback/Capture audio system
+
+maintainers:
+  - Katta Dhanunjanrao <katta.dhanunjanrao@amd.com>
+
+description:
+  The IP core supports UHD SDI Embed/Extract of audio in SDI Tx and Rx protocol respectively.
+  Please note that v1.0 (xlnx,v-uhdsdi-audio-1.0) is deprecated and driver no longer supports it.
+  Mandatory to upgrade to v2.0.
+  Refer to the documentation -
+  https://www.xilinx.com/support/documentation/ip_documentation/v_uhdsdi_audio/v1_0/pg309-v-uhdsdi-audio.pdf
+
+properties:
+  compatible:
+    const: xlnx,v-uhdsdi-audio-2.0
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    description: List of phandles to AXI lite, sdi embed  and axi stream clock.
+    items:
+      - description: AXI lite clock.
+      - description: AXI stream clock.
+          - s_axis_clk is clock for audio embed.
+          - m_axis_clk is clock for audio extract.
+      - description: SDI embed/extract clock.
+          - sdi_embed_clk is used for embedding the audio into SDI stream(Tx).
+          - sdi_extract_clk is used for extracting the audio from SDI stream(Rx).
+
+  clock-names:
+    items:
+      - const: s_axi_aclk
+      - enum: [s_axis_clk, m_axis_clk]
+      - enum: [sdi_embed_clk, sdi_extract_clk]
+
+  xlnx,snd-pcm:
+    description: Reference to audio formatter block.
+    $ref: /schemas/types.yaml#/definitions/phandle
+
+  ports:
+    type: object
+
+    properties:
+      "#address-cells":
+        const: 1
+
+      "#size-cells":
+        const: 0
+
+      port@0:
+        type: object
+        description: Output / source port node, endpoint describing modules
+                     connected the SDI Audio Embed.
+        properties:
+          reg:
+            const: 0
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        additionalProperties: false
+
+    additionalProperties: false
+
+required:
+  - reg
+  - clock-names
+  - clocks
+  - interrupts
+  - xlnx,snd-pcm
+
+allOf:
+  - if:
+      properties:
+        clock-names:
+          contains:
+            const: s_axis_clk
+    then:
+      properties:
+        clock-names:
+          contains:
+            const: sdi_embed_clk
+
+      required:
+        - ports
+    else:
+      properties:
+        clock-names:
+          contains:
+            const: sdi_extract_clk
+
+additionalProperties: false
+
+examples:
+  - |
+    v-uhdsdi-audio@80090000 {
+        compatible = "xlnx,v-uhdsdi-audio-2.0";
+        reg = <0x80090000 0x10000>;
+        clock-names = "s_axi_aclk", "s_axis_clk", "sdi_embed_clk";
+        clocks = <&misc_clk_0>, <&misc_clk_0>, <&misc_clk_1>;
+        interrupts = <0 107 4>;
+        xlnx,snd-pcm = <&audio_formatter>;
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+            port@0 {
+                reg = <0>;
+                endpoint {
+                    remote-endpoint = <&sdi_audio_sink_port>;
+                };
+            };
+        };
+    };
+    v-uhdsdi-audio@80080000 {
+        compatible = "xlnx,v-uhdsdi-audio-2.0";
+        reg = <0x80080000 0x10000>;
+        clock-names = "s_axi_aclk", "m_axis_clk", "sdi_extract_clk";
+        clocks = <&misc_clk_0>, <&misc_clk_0>, <&misc_clk_1>;
+        interrupts = <0 106 4>;
+        xlnx,snd-pcm = <&audio_formatter>;
+    };
+...
diff --git a/sound/soc/xilinx/Kconfig b/sound/soc/xilinx/Kconfig
index 5bd2730aa..11aea2395 100644
--- a/sound/soc/xilinx/Kconfig
+++ b/sound/soc/xilinx/Kconfig
@@ -1,4 +1,12 @@
 # SPDX-License-Identifier: GPL-2.0-only
+config SND_SOC_XILINX_SDI
+	tristate "Audio support for the the Xilinx SDI"
+	depends on DRM_XLNX_SDI
+	depends on VIDEO_XILINX_SDIRXSS
+	help
+	  Select this option to enable Xilinx SDI Audio.This enables
+	  SDI audio playback and capture using xilinx soft IP
+
 config SND_SOC_XILINX_I2S
 	tristate "Audio support for the Xilinx I2S"
 	help
@@ -19,5 +27,14 @@ config SND_SOC_XILINX_SPDIF
 	tristate "Audio support for the Xilinx SPDIF"
 	help
 	  Select this option to enable Xilinx SPDIF Audio.
-	  This provides playback and capture of SPDIF audio in
-	  AES format.
+	  Enabling this provides one of the component required in ASoC
+	  audio pipeline.
+	  This supports playback and capture usecases.
+
+config SND_SOC_XILINX_PL_SND_CARD
+	tristate "Audio support for the the Xilinx PL sound card"
+	depends on SND_SOC_XILINX_AUDIO_FORMATTER || SND_SOC_XILINX_I2S || SND_SOC_XILINX_SDI
+	help
+	  Select this option to enable Xilinx PL sound card
+	  support. This enables sound card using xilinx soft IPs
+	  in audio pipeline.
diff --git a/sound/soc/xilinx/Makefile b/sound/soc/xilinx/Makefile
index 61cb47cf7..55ef530e4 100644
--- a/sound/soc/xilinx/Makefile
+++ b/sound/soc/xilinx/Makefile
@@ -1,7 +1,9 @@
 # SPDX-License-Identifier: GPL-2.0-only
+obj-$(CONFIG_SND_SOC_XILINX_SDI) += xlnx_sdi_audio.o
 snd-soc-xlnx-i2s-y      := xlnx_i2s.o
 obj-$(CONFIG_SND_SOC_XILINX_I2S) += snd-soc-xlnx-i2s.o
 snd-soc-xlnx-formatter-pcm-y := xlnx_formatter_pcm.o
 obj-$(CONFIG_SND_SOC_XILINX_AUDIO_FORMATTER) += snd-soc-xlnx-formatter-pcm.o
 snd-soc-xlnx-spdif-y := xlnx_spdif.o
 obj-$(CONFIG_SND_SOC_XILINX_SPDIF) += snd-soc-xlnx-spdif.o
+obj-$(CONFIG_SND_SOC_XILINX_PL_SND_CARD) += xlnx_pl_snd_card.o
diff --git a/sound/soc/xilinx/xlnx_formatter_pcm.c b/sound/soc/xilinx/xlnx_formatter_pcm.c
index 17ef05309..88e034deb 100644
--- a/sound/soc/xilinx/xlnx_formatter_pcm.c
+++ b/sound/soc/xilinx/xlnx_formatter_pcm.c
@@ -1,22 +1,26 @@
 // SPDX-License-Identifier: GPL-2.0
-//
-// Xilinx ASoC audio formatter support
-//
-// Copyright (C) 2018 Xilinx, Inc.
-//
-// Author: Maruthi Srinivas Bayyavarapu <maruthis@xilinx.com>
+/*
+ * Xilinx ASoC audio formatter support
+ *
+ * Copyright (C) 2018 Xilinx, Inc.
+ *
+ */
 
 #include <linux/clk.h>
+#include <linux/dma-mapping.h>
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
+#include <linux/platform_device.h>
 #include <linux/sizes.h>
 
 #include <sound/asoundef.h>
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
 
+#include "xlnx_snd_common.h"
+
 #define DRV_NAME "xlnx_formatter_pcm"
 
 #define XLNX_S2MM_OFFSET	0
@@ -57,7 +61,9 @@
 #define CFG_S2MM_XFER_SHIFT	29
 #define CFG_S2MM_PKG_MASK	BIT(28)
 
+#define AUD_CTRL_DATA_WIDTH_MASK	GENMASK(18, 16)
 #define AUD_CTRL_DATA_WIDTH_SHIFT	16
+#define AUD_CTRL_ACTIVE_CH_MASK		GENMASK(22, 19)
 #define AUD_CTRL_ACTIVE_CH_SHIFT	19
 #define PERIOD_CFG_PERIODS_SHIFT	16
 
@@ -83,7 +89,12 @@ struct xlnx_pcm_drv_data {
 	int mm2s_irq;
 	struct snd_pcm_substream *play_stream;
 	struct snd_pcm_substream *capture_stream;
+	struct platform_device *pdev;
+	struct device_node *nodes[XLNX_MAX_PATHS];
 	struct clk *axi_clk;
+	struct clk *mm2s_axis_clk;
+	struct clk *s2mm_axis_clk;
+	struct clk *aud_mclk;
 	unsigned int sysclk;
 };
 
@@ -110,7 +121,7 @@ static const struct snd_pcm_hardware xlnx_pcm_hardware = {
 	.formats = SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE |
 		   SNDRV_PCM_FMTBIT_S24_LE,
 	.channels_min = 2,
-	.channels_max = 2,
+	.channels_max = 8,
 	.rates = SNDRV_PCM_RATE_8000_192000,
 	.rate_min = 8000,
 	.rate_max = 192000,
@@ -248,16 +259,16 @@ static int xlnx_formatter_pcm_reset(void __iomem *mmio_base)
 {
 	u32 val, retries = 0;
 
-	val = readl(mmio_base + XLNX_AUD_CTRL);
+	val = ioread32(mmio_base + XLNX_AUD_CTRL);
 	val |= AUD_CTRL_RESET_MASK;
-	writel(val, mmio_base + XLNX_AUD_CTRL);
+	iowrite32(val, mmio_base + XLNX_AUD_CTRL);
 
-	val = readl(mmio_base + XLNX_AUD_CTRL);
+	val = ioread32(mmio_base + XLNX_AUD_CTRL);
 	/* Poll for maximum timeout of approximately 100ms (1 * 100)*/
 	while ((val & AUD_CTRL_RESET_MASK) && (retries < 100)) {
 		mdelay(1);
 		retries++;
-		val = readl(mmio_base + XLNX_AUD_CTRL);
+		val = ioread32(mmio_base + XLNX_AUD_CTRL);
 	}
 	if (val & AUD_CTRL_RESET_MASK)
 		return -ENODEV;
@@ -269,12 +280,12 @@ static void xlnx_formatter_disable_irqs(void __iomem *mmio_base, int stream)
 {
 	u32 val;
 
-	val = readl(mmio_base + XLNX_AUD_CTRL);
+	val = ioread32(mmio_base + XLNX_AUD_CTRL);
 	val &= ~AUD_CTRL_IOC_IRQ_MASK;
 	if (stream == SNDRV_PCM_STREAM_CAPTURE)
 		val &= ~AUD_CTRL_TOUT_IRQ_MASK;
 
-	writel(val, mmio_base + XLNX_AUD_CTRL);
+	iowrite32(val, mmio_base + XLNX_AUD_CTRL);
 }
 
 static irqreturn_t xlnx_mm2s_irq_handler(int irq, void *arg)
@@ -285,9 +296,9 @@ static irqreturn_t xlnx_mm2s_irq_handler(int irq, void *arg)
 	struct xlnx_pcm_drv_data *adata = dev_get_drvdata(dev);
 
 	reg = adata->mmio + XLNX_MM2S_OFFSET + XLNX_AUD_STS;
-	val = readl(reg);
+	val = ioread32(reg);
 	if (val & AUD_STS_IOC_IRQ_MASK) {
-		writel(val & AUD_STS_IOC_IRQ_MASK, reg);
+		iowrite32(val & AUD_STS_IOC_IRQ_MASK, reg);
 		if (adata->play_stream)
 			snd_pcm_period_elapsed(adata->play_stream);
 		return IRQ_HANDLED;
@@ -304,9 +315,9 @@ static irqreturn_t xlnx_s2mm_irq_handler(int irq, void *arg)
 	struct xlnx_pcm_drv_data *adata = dev_get_drvdata(dev);
 
 	reg = adata->mmio + XLNX_S2MM_OFFSET + XLNX_AUD_STS;
-	val = readl(reg);
+	val = ioread32(reg);
 	if (val & AUD_STS_IOC_IRQ_MASK) {
-		writel(val & AUD_STS_IOC_IRQ_MASK, reg);
+		iowrite32(val & AUD_STS_IOC_IRQ_MASK, reg);
 		if (adata->capture_stream)
 			snd_pcm_period_elapsed(adata->capture_stream);
 		return IRQ_HANDLED;
@@ -332,7 +343,12 @@ static int xlnx_formatter_pcm_open(struct snd_soc_component *component,
 	u32 ch_count_mask, ch_count_shift, data_xfer_mode, data_xfer_shift;
 	struct xlnx_pcm_stream_param *stream_data;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct xlnx_pcm_drv_data *adata = dev_get_drvdata(component->dev);
+	struct xlnx_pcm_drv_data *adata;
+
+	if (!component)
+		return -ENODEV;
+
+	adata = dev_get_drvdata(component->dev);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
 	    !adata->mm2s_presence)
@@ -364,10 +380,12 @@ static int xlnx_formatter_pcm_open(struct snd_soc_component *component,
 		adata->capture_stream = substream;
 	}
 
-	val = readl(adata->mmio + XLNX_AUD_CORE_CONFIG);
+	val = ioread32(adata->mmio + XLNX_AUD_CORE_CONFIG);
 
 	if (!(val & data_format_mode))
 		stream_data->interleaved = true;
+	else
+		stream_data->interleaved = false;
 
 	stream_data->xfer_mode = (val & data_xfer_mode) >> data_xfer_shift;
 	stream_data->ch_limit = (val & ch_count_mask) >> ch_count_shift;
@@ -409,9 +427,9 @@ static int xlnx_formatter_pcm_open(struct snd_soc_component *component,
 	}
 
 	/* enable DMA IOC irq */
-	val = readl(stream_data->mmio + XLNX_AUD_CTRL);
+	val = ioread32(stream_data->mmio + XLNX_AUD_CTRL);
 	val |= AUD_CTRL_IOC_IRQ_MASK;
-	writel(val, stream_data->mmio + XLNX_AUD_CTRL);
+	iowrite32(val, stream_data->mmio + XLNX_AUD_CTRL);
 
 	return 0;
 }
@@ -423,6 +441,9 @@ static int xlnx_formatter_pcm_close(struct snd_soc_component *component,
 	struct xlnx_pcm_stream_param *stream_data =
 			substream->runtime->private_data;
 
+	if (!component)
+		return -ENODEV;
+
 	ret = xlnx_formatter_pcm_reset(stream_data->mmio);
 	if (ret) {
 		dev_err(component->dev, "audio formatter reset failed\n");
@@ -443,7 +464,7 @@ xlnx_formatter_pcm_pointer(struct snd_soc_component *component,
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct xlnx_pcm_stream_param *stream_data = runtime->private_data;
 
-	pos = readl(stream_data->mmio + XLNX_AUD_XFER_COUNT);
+	pos = ioread32(stream_data->mmio + XLNX_AUD_XFER_COUNT);
 
 	if (pos >= stream_data->buffer_size)
 		pos = 0;
@@ -455,12 +476,20 @@ static int xlnx_formatter_pcm_hw_params(struct snd_soc_component *component,
 					struct snd_pcm_substream *substream,
 					struct snd_pcm_hw_params *params)
 {
-	u32 low, high, active_ch, val, bytes_per_ch, bits_per_sample;
+	u32 low, high, active_ch, val, bits_per_sample, bytes_per_ch;
 	u32 aes_reg1_val, aes_reg2_val;
+	int status;
 	u64 size;
+	struct pl_card_data *prv;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct xlnx_pcm_stream_param *stream_data = runtime->private_data;
-	struct xlnx_pcm_drv_data *adata = dev_get_drvdata(component->dev);
+	struct xlnx_pcm_drv_data *adata;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if (!component)
+		return -ENODEV;
+
+	adata = dev_get_drvdata(component->dev);
 
 	active_ch = params_channels(params);
 	if (active_ch > stream_data->ch_limit)
@@ -480,13 +509,20 @@ static int xlnx_formatter_pcm_hw_params(struct snd_soc_component *component,
 	}
 
 	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
-	    stream_data->xfer_mode == AES_TO_PCM) {
-		val = readl(stream_data->mmio + XLNX_AUD_STS);
+	    stream_data->xfer_mode == AES_TO_PCM &&
+	    ((strstr(adata->nodes[XLNX_CAPTURE]->name, "hdmi")) ||
+	    (strstr(adata->nodes[XLNX_CAPTURE]->name, "sdi")) ||
+	    (strstr(adata->nodes[XLNX_CAPTURE]->name, "dp")))) {
+		/*
+		 * If formatter is in AES_PCM mode for HDMI/SDI capture path,
+		 * parse AES header
+		 */
+		val = ioread32(stream_data->mmio + XLNX_AUD_STS);
 		if (val & AUD_STS_CH_STS_MASK) {
-			aes_reg1_val = readl(stream_data->mmio +
-					     XLNX_AUD_CH_STS_START);
-			aes_reg2_val = readl(stream_data->mmio +
-					     XLNX_AUD_CH_STS_START + 0x4);
+			aes_reg1_val = ioread32(stream_data->mmio +
+					 XLNX_AUD_CH_STS_START);
+			aes_reg2_val = ioread32(stream_data->mmio +
+					 XLNX_AUD_CH_STS_START + 0x4);
 
 			xlnx_parse_aes_params(aes_reg1_val, aes_reg2_val,
 					      component->dev);
@@ -494,15 +530,19 @@ static int xlnx_formatter_pcm_hw_params(struct snd_soc_component *component,
 	}
 
 	size = params_buffer_bytes(params);
+	status = snd_pcm_lib_malloc_pages(substream, size);
+	if (status < 0)
+		return status;
 
 	stream_data->buffer_size = size;
 
 	low = lower_32_bits(runtime->dma_addr);
 	high = upper_32_bits(runtime->dma_addr);
-	writel(low, stream_data->mmio + XLNX_AUD_BUFF_ADDR_LSB);
-	writel(high, stream_data->mmio + XLNX_AUD_BUFF_ADDR_MSB);
+	iowrite32(low, stream_data->mmio + XLNX_AUD_BUFF_ADDR_LSB);
+	iowrite32(high, stream_data->mmio + XLNX_AUD_BUFF_ADDR_MSB);
 
-	val = readl(stream_data->mmio + XLNX_AUD_CTRL);
+	val = ioread32(stream_data->mmio + XLNX_AUD_CTRL);
+	val &= ~AUD_CTRL_DATA_WIDTH_MASK;
 	bits_per_sample = params_width(params);
 	switch (bits_per_sample) {
 	case 8:
@@ -520,25 +560,35 @@ static int xlnx_formatter_pcm_hw_params(struct snd_soc_component *component,
 	case 32:
 		val |= (BIT_DEPTH_32 << AUD_CTRL_DATA_WIDTH_SHIFT);
 		break;
-	default:
-		return -EINVAL;
 	}
 
+	val &= ~AUD_CTRL_ACTIVE_CH_MASK;
 	val |= active_ch << AUD_CTRL_ACTIVE_CH_SHIFT;
-	writel(val, stream_data->mmio + XLNX_AUD_CTRL);
+	iowrite32(val, stream_data->mmio + XLNX_AUD_CTRL);
 
 	val = (params_periods(params) << PERIOD_CFG_PERIODS_SHIFT)
 		| params_period_bytes(params);
-	writel(val, stream_data->mmio + XLNX_AUD_PERIOD_CONFIG);
+	iowrite32(val, stream_data->mmio + XLNX_AUD_PERIOD_CONFIG);
 	bytes_per_ch = DIV_ROUND_UP(params_period_bytes(params), active_ch);
-	writel(bytes_per_ch, stream_data->mmio + XLNX_BYTES_PER_CH);
+	iowrite32(bytes_per_ch, stream_data->mmio + XLNX_BYTES_PER_CH);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		prv = snd_soc_card_get_drvdata(rtd->card);
+		iowrite32(prv->mclk_ratio,
+			  stream_data->mmio + XLNX_AUD_FS_MULTIPLIER);
+	}
 
 	return 0;
 }
 
+static int xlnx_formatter_pcm_hw_free(struct snd_soc_component *component,
+				      struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
 static int xlnx_formatter_pcm_trigger(struct snd_soc_component *component,
-				      struct snd_pcm_substream *substream,
-				      int cmd)
+				      struct snd_pcm_substream *substream, int cmd)
 {
 	u32 val;
 	struct xlnx_pcm_stream_param *stream_data =
@@ -548,16 +598,16 @@ static int xlnx_formatter_pcm_trigger(struct snd_soc_component *component,
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 	case SNDRV_PCM_TRIGGER_RESUME:
-		val = readl(stream_data->mmio + XLNX_AUD_CTRL);
+		val = ioread32(stream_data->mmio + XLNX_AUD_CTRL);
 		val |= AUD_CTRL_DMA_EN_MASK;
-		writel(val, stream_data->mmio + XLNX_AUD_CTRL);
+		iowrite32(val, stream_data->mmio + XLNX_AUD_CTRL);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
-		val = readl(stream_data->mmio + XLNX_AUD_CTRL);
+		val = ioread32(stream_data->mmio + XLNX_AUD_CTRL);
 		val &= ~AUD_CTRL_DMA_EN_MASK;
-		writel(val, stream_data->mmio + XLNX_AUD_CTRL);
+		iowrite32(val, stream_data->mmio + XLNX_AUD_CTRL);
 		break;
 	}
 
@@ -567,28 +617,139 @@ static int xlnx_formatter_pcm_trigger(struct snd_soc_component *component,
 static int xlnx_formatter_pcm_new(struct snd_soc_component *component,
 				  struct snd_soc_pcm_runtime *rtd)
 {
-	snd_pcm_set_managed_buffer_all(rtd->pcm,
-			SNDRV_DMA_TYPE_DEV, component->dev,
-			xlnx_pcm_hardware.buffer_bytes_max,
-			xlnx_pcm_hardware.buffer_bytes_max);
+	if (!component)
+		return -ENODEV;
+
+	snd_pcm_lib_preallocate_pages_for_all(rtd->pcm,
+					      SNDRV_DMA_TYPE_DEV,
+					      component->dev,
+					      xlnx_pcm_hardware.buffer_bytes_max,
+					      xlnx_pcm_hardware.buffer_bytes_max);
 	return 0;
 }
 
 static const struct snd_soc_component_driver xlnx_asoc_component = {
-	.name			= DRV_NAME,
-	.set_sysclk		= xlnx_formatter_set_sysclk,
-	.open			= xlnx_formatter_pcm_open,
-	.close			= xlnx_formatter_pcm_close,
-	.hw_params		= xlnx_formatter_pcm_hw_params,
-	.trigger		= xlnx_formatter_pcm_trigger,
-	.pointer		= xlnx_formatter_pcm_pointer,
-	.pcm_construct		= xlnx_formatter_pcm_new,
+	.name		= DRV_NAME,
+	.set_sysclk	= xlnx_formatter_set_sysclk,
+	.open		= xlnx_formatter_pcm_open,
+	.close		= xlnx_formatter_pcm_close,
+	.hw_params	= xlnx_formatter_pcm_hw_params,
+	.hw_free	= xlnx_formatter_pcm_hw_free,
+	.trigger	= xlnx_formatter_pcm_trigger,
+	.pointer	= xlnx_formatter_pcm_pointer,
+	.pcm_construct	= xlnx_formatter_pcm_new,
 };
 
+static int configure_mm2s(struct xlnx_pcm_drv_data *aud_drv_data,
+			  struct platform_device *pdev)
+{
+	int ret;
+	struct device *dev = &pdev->dev;
+
+	aud_drv_data->mm2s_axis_clk = devm_clk_get_enabled(dev, "m_axis_mm2s_aclk");
+	if (IS_ERR(aud_drv_data->mm2s_axis_clk)) {
+		ret = PTR_ERR(aud_drv_data->mm2s_axis_clk);
+		dev_err(dev, "failed to get m_axis_mm2s_aclk(%d)\n", ret);
+		return ret;
+	}
+
+	aud_drv_data->aud_mclk = devm_clk_get_enabled(dev, "aud_mclk");
+	if (IS_ERR(aud_drv_data->aud_mclk)) {
+		ret = PTR_ERR(aud_drv_data->aud_mclk);
+		dev_err(dev, "failed to get aud_mclk(%d)\n", ret);
+		return ret;
+	}
+
+	aud_drv_data->mm2s_irq = platform_get_irq_byname(pdev,
+							 "irq_mm2s");
+	if (aud_drv_data->mm2s_irq < 0)
+		return aud_drv_data->mm2s_irq;
+
+	ret = devm_request_irq(dev, aud_drv_data->mm2s_irq,
+			       xlnx_mm2s_irq_handler, 0,
+			       "xlnx_formatter_pcm_mm2s_irq", dev);
+	if (ret) {
+		dev_err(dev, "xlnx audio mm2s irq request failed\n");
+		return ret;
+	}
+	ret = xlnx_formatter_pcm_reset(aud_drv_data->mmio +
+				       XLNX_MM2S_OFFSET);
+	if (ret) {
+		dev_err(dev, "audio formatter reset failed\n");
+		return ret;
+	}
+	xlnx_formatter_disable_irqs(aud_drv_data->mmio +
+				    XLNX_MM2S_OFFSET,
+				    SNDRV_PCM_STREAM_PLAYBACK);
+
+	aud_drv_data->nodes[XLNX_PLAYBACK] =
+		of_parse_phandle(dev->of_node, "xlnx,tx", 0);
+	if (!aud_drv_data->nodes[XLNX_PLAYBACK])
+		dev_err(dev, "tx node not found\n");
+	else
+		dev_info(dev,
+			 "sound card device will use DAI link: %s\n",
+			 (aud_drv_data->nodes[XLNX_PLAYBACK])->name);
+	of_node_put(aud_drv_data->nodes[XLNX_PLAYBACK]);
+
+	aud_drv_data->mm2s_presence = true;
+	return 0;
+}
+
+static int configure_s2mm(struct xlnx_pcm_drv_data *aud_drv_data,
+			  struct platform_device *pdev)
+{
+	int ret;
+	struct device *dev = &pdev->dev;
+
+	aud_drv_data->s2mm_axis_clk = devm_clk_get_enabled(dev, "s_axis_s2mm_aclk");
+	if (IS_ERR(aud_drv_data->s2mm_axis_clk)) {
+		ret = PTR_ERR(aud_drv_data->s2mm_axis_clk);
+		dev_err(dev, "failed to get s_axis_s2mm_aclk(%d)\n", ret);
+		return ret;
+	}
+
+	aud_drv_data->s2mm_irq = platform_get_irq_byname(pdev,
+							 "irq_s2mm");
+	if (aud_drv_data->s2mm_irq < 0)
+		return aud_drv_data->s2mm_irq;
+
+	ret = devm_request_irq(dev, aud_drv_data->s2mm_irq,
+			       xlnx_s2mm_irq_handler, 0,
+			       "xlnx_formatter_pcm_s2mm_irq",
+			       dev);
+	if (ret) {
+		dev_err(dev, "xlnx audio s2mm irq request failed\n");
+		return ret;
+	}
+	ret = xlnx_formatter_pcm_reset(aud_drv_data->mmio +
+				       XLNX_S2MM_OFFSET);
+	if (ret) {
+		dev_err(dev, "audio formatter reset failed\n");
+		return ret;
+	}
+	xlnx_formatter_disable_irqs(aud_drv_data->mmio +
+				    XLNX_S2MM_OFFSET,
+				    SNDRV_PCM_STREAM_CAPTURE);
+
+	aud_drv_data->nodes[XLNX_CAPTURE] =
+		of_parse_phandle(dev->of_node, "xlnx,rx", 0);
+	if (!aud_drv_data->nodes[XLNX_CAPTURE])
+		dev_err(dev, "rx node not found\n");
+	else
+		dev_info(dev, "sound card device will use DAI link: %s\n",
+			 (aud_drv_data->nodes[XLNX_CAPTURE])->name);
+	of_node_put(aud_drv_data->nodes[XLNX_CAPTURE]);
+
+	aud_drv_data->s2mm_presence = true;
+	return 0;
+}
+
 static int xlnx_formatter_pcm_probe(struct platform_device *pdev)
 {
 	int ret;
 	u32 val;
+	size_t pdata_size;
 	struct xlnx_pcm_drv_data *aud_drv_data;
 	struct device *dev = &pdev->dev;
 
@@ -596,79 +757,36 @@ static int xlnx_formatter_pcm_probe(struct platform_device *pdev)
 	if (!aud_drv_data)
 		return -ENOMEM;
 
-	aud_drv_data->axi_clk = devm_clk_get(dev, "s_axi_lite_aclk");
+	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));
+	if (ret) {
+		dev_err(dev, "higher dma address mapping failed %d\n", ret);
+		return ret;
+	}
+
+	aud_drv_data->axi_clk = devm_clk_get_enabled(dev, "s_axi_lite_aclk");
 	if (IS_ERR(aud_drv_data->axi_clk)) {
 		ret = PTR_ERR(aud_drv_data->axi_clk);
 		dev_err(dev, "failed to get s_axi_lite_aclk(%d)\n", ret);
 		return ret;
 	}
-	ret = clk_prepare_enable(aud_drv_data->axi_clk);
-	if (ret) {
-		dev_err(dev,
-			"failed to enable s_axi_lite_aclk(%d)\n", ret);
-		return ret;
-	}
 
 	aud_drv_data->mmio = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(aud_drv_data->mmio)) {
 		dev_err(dev, "audio formatter ioremap failed\n");
-		ret = PTR_ERR(aud_drv_data->mmio);
-		goto clk_err;
+		return PTR_ERR(aud_drv_data->mmio);
 	}
 
-	val = readl(aud_drv_data->mmio + XLNX_AUD_CORE_CONFIG);
+	val = ioread32(aud_drv_data->mmio + XLNX_AUD_CORE_CONFIG);
 	if (val & AUD_CFG_MM2S_MASK) {
-		aud_drv_data->mm2s_presence = true;
-		ret = xlnx_formatter_pcm_reset(aud_drv_data->mmio +
-					       XLNX_MM2S_OFFSET);
-		if (ret) {
-			dev_err(dev, "audio formatter reset failed\n");
-			goto clk_err;
-		}
-		xlnx_formatter_disable_irqs(aud_drv_data->mmio +
-					    XLNX_MM2S_OFFSET,
-					    SNDRV_PCM_STREAM_PLAYBACK);
-
-		aud_drv_data->mm2s_irq = platform_get_irq_byname(pdev,
-								 "irq_mm2s");
-		if (aud_drv_data->mm2s_irq < 0) {
-			ret = aud_drv_data->mm2s_irq;
-			goto clk_err;
-		}
-		ret = devm_request_irq(dev, aud_drv_data->mm2s_irq,
-				       xlnx_mm2s_irq_handler, 0,
-				       "xlnx_formatter_pcm_mm2s_irq", dev);
-		if (ret) {
-			dev_err(dev, "xlnx audio mm2s irq request failed\n");
-			goto clk_err;
-		}
+		ret = configure_mm2s(aud_drv_data, pdev);
+		if (ret)
+			return ret;
 	}
+
 	if (val & AUD_CFG_S2MM_MASK) {
-		aud_drv_data->s2mm_presence = true;
-		ret = xlnx_formatter_pcm_reset(aud_drv_data->mmio +
-					       XLNX_S2MM_OFFSET);
-		if (ret) {
-			dev_err(dev, "audio formatter reset failed\n");
-			goto clk_err;
-		}
-		xlnx_formatter_disable_irqs(aud_drv_data->mmio +
-					    XLNX_S2MM_OFFSET,
-					    SNDRV_PCM_STREAM_CAPTURE);
-
-		aud_drv_data->s2mm_irq = platform_get_irq_byname(pdev,
-								 "irq_s2mm");
-		if (aud_drv_data->s2mm_irq < 0) {
-			ret = aud_drv_data->s2mm_irq;
-			goto clk_err;
-		}
-		ret = devm_request_irq(dev, aud_drv_data->s2mm_irq,
-				       xlnx_s2mm_irq_handler, 0,
-				       "xlnx_formatter_pcm_s2mm_irq",
-				       dev);
-		if (ret) {
-			dev_err(dev, "xlnx audio s2mm irq request failed\n");
-			goto clk_err;
-		}
+		ret = configure_s2mm(aud_drv_data, pdev);
+		if (ret)
+			return ret;
 	}
 
 	dev_set_drvdata(dev, aud_drv_data);
@@ -677,14 +795,23 @@ static int xlnx_formatter_pcm_probe(struct platform_device *pdev)
 					      NULL, 0);
 	if (ret) {
 		dev_err(dev, "pcm platform device register failed\n");
-		goto clk_err;
+		return ret;
 	}
 
+	pdata_size = sizeof(aud_drv_data->nodes);
+	if (aud_drv_data->nodes[XLNX_PLAYBACK] ||
+	    aud_drv_data->nodes[XLNX_CAPTURE])
+		aud_drv_data->pdev =
+			platform_device_register_resndata(dev, "xlnx_snd_card",
+							  PLATFORM_DEVID_AUTO,
+							  NULL, 0,
+							  &aud_drv_data->nodes,
+							  pdata_size);
+	if (!aud_drv_data->pdev)
+		dev_err(dev, "sound card device creation failed\n");
+
+	dev_info(dev, "pcm platform device registered\n");
 	return 0;
-
-clk_err:
-	clk_disable_unprepare(aud_drv_data->axi_clk);
-	return ret;
 }
 
 static void xlnx_formatter_pcm_remove(struct platform_device *pdev)
@@ -692,6 +819,8 @@ static void xlnx_formatter_pcm_remove(struct platform_device *pdev)
 	int ret = 0;
 	struct xlnx_pcm_drv_data *adata = dev_get_drvdata(&pdev->dev);
 
+	platform_device_unregister(adata->pdev);
+
 	if (adata->s2mm_presence)
 		ret = xlnx_formatter_pcm_reset(adata->mmio + XLNX_S2MM_OFFSET);
 
@@ -701,8 +830,6 @@ static void xlnx_formatter_pcm_remove(struct platform_device *pdev)
 
 	if (ret)
 		dev_err(&pdev->dev, "audio formatter reset failed\n");
-
-	clk_disable_unprepare(adata->axi_clk);
 }
 
 static const struct of_device_id xlnx_formatter_pcm_of_match[] = {
diff --git a/sound/soc/xilinx/xlnx_i2s.c b/sound/soc/xilinx/xlnx_i2s.c
index ca915a001..a3a4b5be9 100644
--- a/sound/soc/xilinx/xlnx_i2s.c
+++ b/sound/soc/xilinx/xlnx_i2s.c
@@ -7,6 +7,7 @@
 // Author: Praveen Vuppala <praveenv@xilinx.com>
 // Author: Maruthi Srinivas Bayyavarapu <maruthis@xilinx.com>
 
+#include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/of.h>
@@ -33,6 +34,9 @@ struct xlnx_i2s_drv_data {
 	bool is_32bit_lrclk;
 	struct snd_ratnum ratnum;
 	struct snd_pcm_hw_constraint_ratnums rate_constraints;
+	struct clk *axi_clk;
+	struct clk *axis_clk;
+	struct clk *aud_mclk;
 };
 
 static int xlnx_i2s_set_sclkout_div(struct snd_soc_dai *cpu_dai,
@@ -184,6 +188,13 @@ static int xlnx_i2s_probe(struct platform_device *pdev)
 	if (IS_ERR(drv_data->base))
 		return PTR_ERR(drv_data->base);
 
+	drv_data->axi_clk = devm_clk_get_enabled(&pdev->dev, "s_axi_ctrl_aclk");
+	if (IS_ERR(drv_data->axi_clk)) {
+		ret = PTR_ERR(drv_data->axi_clk);
+		dev_err(&pdev->dev, "failed to get s_axi_ctrl_aclk(%d)\n", ret);
+		return ret;
+	}
+
 	ret = of_property_read_u32(node, "xlnx,num-channels", &drv_data->channels);
 	if (ret < 0) {
 		dev_err(dev, "cannot get supported channels\n");
@@ -215,6 +226,15 @@ static int xlnx_i2s_probe(struct platform_device *pdev)
 		drv_data->dai_drv.playback.channels_max = drv_data->channels;
 		drv_data->dai_drv.playback.rates	= SNDRV_PCM_RATE_8000_192000;
 		drv_data->dai_drv.ops = &xlnx_i2s_dai_ops;
+
+		drv_data->axis_clk = devm_clk_get_enabled(&pdev->dev,
+							  "s_axis_aud_aclk");
+		if (IS_ERR(drv_data->axis_clk)) {
+			ret = PTR_ERR(drv_data->axis_clk);
+			dev_err(&pdev->dev,
+				"failed to get s_axis_aud_aclk(%d)\n", ret);
+			return ret;
+		}
 	} else if (of_device_is_compatible(node, "xlnx,i2s-receiver-1.0")) {
 		drv_data->dai_drv.name = "xlnx_i2s_capture";
 		drv_data->dai_drv.capture.stream_name = "Capture";
@@ -223,12 +243,28 @@ static int xlnx_i2s_probe(struct platform_device *pdev)
 		drv_data->dai_drv.capture.channels_max = drv_data->channels;
 		drv_data->dai_drv.capture.rates = SNDRV_PCM_RATE_8000_192000;
 		drv_data->dai_drv.ops = &xlnx_i2s_dai_ops;
+
+		drv_data->axis_clk = devm_clk_get_enabled(&pdev->dev,
+							  "m_axis_aud_aclk");
+		if (IS_ERR(drv_data->axis_clk)) {
+			ret = PTR_ERR(drv_data->axis_clk);
+			dev_err(&pdev->dev,
+				"failed to get m_axis_aud_aclk(%d)\n", ret);
+			return ret;
+		}
 	} else {
 		return -ENODEV;
 	}
 	drv_data->is_32bit_lrclk = readl(drv_data->base + I2S_CORE_CTRL_OFFSET) &
 				   I2S_CORE_CTRL_32BIT_LRCLK;
 
+	drv_data->aud_mclk = devm_clk_get_enabled(&pdev->dev, "aud_mclk");
+	if (IS_ERR(drv_data->aud_mclk)) {
+		ret = PTR_ERR(drv_data->aud_mclk);
+		dev_err(&pdev->dev, "failed to get aud_mclk(%d)\n", ret);
+		return ret;
+	}
+
 	dev_set_drvdata(&pdev->dev, drv_data);
 
 	ret = devm_snd_soc_register_component(&pdev->dev, &xlnx_i2s_component,
@@ -240,7 +276,7 @@ static int xlnx_i2s_probe(struct platform_device *pdev)
 
 	dev_info(&pdev->dev, "%s DAI registered\n", drv_data->dai_drv.name);
 
-	return ret;
+	return 0;
 }
 
 static struct platform_driver xlnx_i2s_aud_driver = {
diff --git a/sound/soc/xilinx/xlnx_pl_snd_card.c b/sound/soc/xilinx/xlnx_pl_snd_card.c
new file mode 100644
index 000000000..5b7f5eebe
--- /dev/null
+++ b/sound/soc/xilinx/xlnx_pl_snd_card.c
@@ -0,0 +1,545 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx ASoC sound card support
+ *
+ * Copyright (C) 2018 Xilinx, Inc.
+ */
+
+#include <linux/clk.h>
+#include <linux/idr.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include "xlnx_snd_common.h"
+
+#define I2S_CLOCK_RATIO 384
+#define XLNX_MAX_PL_SND_DEV 6
+
+static DEFINE_IDA(xlnx_snd_card_dev);
+
+enum {
+	I2S_AUDIO = 0,
+	HDMI_AUDIO,
+	SDI_AUDIO,
+	SPDIF_AUDIO,
+	DP_AUDIO,
+	XLNX_MAX_IFACE,
+};
+
+static const char *xlnx_snd_card_name[XLNX_MAX_IFACE] = {
+	[I2S_AUDIO]	= "xlnx-i2s-snd-card",
+	[HDMI_AUDIO]	= "xlnx-hdmi-snd-card",
+	[SDI_AUDIO]	= "xlnx-sdi-snd-card",
+	[SPDIF_AUDIO]	= "xlnx-spdif-snd-card",
+	[DP_AUDIO]	= "xlnx-dp-snd-card",
+};
+
+static const char *dev_compat[][XLNX_MAX_IFACE] = {
+	[XLNX_PLAYBACK] = {
+		"xlnx,i2s-transmitter-1.0",
+		"xlnx,v-hdmi-tx-ss-3.1",
+		"xlnx,v-uhdsdi-audio-2.0",
+		"xlnx,spdif-2.0",
+		"xlnx,v-dp-txss-3.0"
+	},
+
+	[XLNX_CAPTURE] = {
+		"xlnx,i2s-receiver-1.0",
+		"xlnx,v-hdmi-rx-ss-3.1",
+		"xlnx,v-uhdsdi-audio-2.0",
+		"xlnx,spdif-2.0",
+		"xlnx,v-dp-rxss-3.0",
+	},
+};
+
+static int xlnx_spdif_card_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct pl_card_data *prv = snd_soc_card_get_drvdata(rtd->card);
+	u32 sample_rate = params_rate(params);
+
+	/* mclk must be >=1024 * sampleing rate */
+	prv->mclk_val = 1024 * sample_rate;
+	prv->mclk_ratio = 1024;
+	return clk_set_rate(prv->mclk, prv->mclk_val);
+}
+
+static int xlnx_sdi_card_hw_params(struct snd_pcm_substream *substream,
+				   struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct pl_card_data *prv = snd_soc_card_get_drvdata(rtd->card);
+	u32 sample_rate = params_rate(params);
+
+	prv->mclk_val = prv->mclk_ratio * sample_rate;
+	return clk_set_rate(prv->mclk, prv->mclk_val);
+}
+
+static int xlnx_dp_card_hw_params(struct snd_pcm_substream *substream,
+				  struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct pl_card_data *prv = snd_soc_card_get_drvdata(rtd->card);
+	u32 sample_rate = params_rate(params);
+
+	switch (sample_rate) {
+	case 32000:
+	case 44100:
+	case 48000:
+	case 88200:
+	case 96000:
+	case 176400:
+	case 192000:
+		prv->mclk_ratio = 512;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	prv->mclk_val = prv->mclk_ratio * sample_rate;
+	return clk_set_rate(prv->mclk, prv->mclk_val);
+}
+
+static int xlnx_hdmi_card_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct pl_card_data *prv = snd_soc_card_get_drvdata(rtd->card);
+	u32 sample_rate = params_rate(params);
+
+	switch (sample_rate) {
+	case 32000:
+	case 44100:
+	case 48000:
+	case 88200:
+	case 96000:
+	case 176400:
+	case 192000:
+		prv->mclk_ratio = 512;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	prv->mclk_val = prv->mclk_ratio * sample_rate;
+	return clk_set_rate(prv->mclk, prv->mclk_val);
+}
+
+static int xlnx_i2s_card_hw_params(struct snd_pcm_substream *substream,
+				   struct snd_pcm_hw_params *params)
+{
+	int ret, clk_div;
+	u32 ch, data_width, sample_rate;
+	struct pl_card_data *prv;
+
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = snd_soc_rtd_to_cpu(rtd, 0);
+
+	ch = params_channels(params);
+	data_width = params_width(params);
+	sample_rate = params_rate(params);
+
+	/* only 2 channels supported */
+	if (ch != 2)
+		return -EINVAL;
+
+	prv = snd_soc_card_get_drvdata(rtd->card);
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		switch (sample_rate) {
+		case 5512:
+		case 8000:
+		case 11025:
+		case 16000:
+		case 22050:
+		case 32000:
+		case 44100:
+		case 48000:
+		case 64000:
+		case 88200:
+		case 96000:
+			prv->mclk_ratio = 384;
+			break;
+		default:
+			return -EINVAL;
+		}
+	} else {
+		switch (sample_rate) {
+		case 32000:
+		case 44100:
+		case 48000:
+		case 88200:
+		case 96000:
+			prv->mclk_ratio = 384;
+			break;
+		case 64000:
+		case 176400:
+		case 192000:
+			prv->mclk_ratio = 192;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	prv->mclk_val = prv->mclk_ratio * sample_rate;
+	clk_div = DIV_ROUND_UP(prv->mclk_ratio, 2 * ch * data_width);
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, clk_div);
+	if (ret)
+		return ret;
+
+	return clk_set_rate(prv->mclk, prv->mclk_val);
+}
+
+static const struct snd_soc_ops xlnx_sdi_card_ops = {
+	.hw_params = xlnx_sdi_card_hw_params,
+};
+
+static const struct snd_soc_ops xlnx_i2s_card_ops = {
+	.hw_params = xlnx_i2s_card_hw_params,
+};
+
+static const struct snd_soc_ops xlnx_hdmi_card_ops = {
+	.hw_params = xlnx_hdmi_card_hw_params,
+};
+
+static const struct snd_soc_ops xlnx_dp_card_ops = {
+	.hw_params = xlnx_dp_card_hw_params,
+};
+
+static const struct snd_soc_ops xlnx_spdif_card_ops = {
+	.hw_params = xlnx_spdif_card_hw_params,
+};
+
+SND_SOC_DAILINK_DEFS(xlnx_i2s_capture,
+		     DAILINK_COMP_ARRAY(COMP_CPU("xlnx_i2s_capture")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_PLATFORM(NULL)));
+
+SND_SOC_DAILINK_DEFS(xlnx_i2s_playback,
+		     DAILINK_COMP_ARRAY(COMP_CPU("xlnx_i2s_playback")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_PLATFORM(NULL)));
+
+SND_SOC_DAILINK_DEFS(xlnx_hdmi_tx,
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "xlnx_hdmi_tx")),
+		     DAILINK_COMP_ARRAY(COMP_PLATFORM(NULL)));
+
+SND_SOC_DAILINK_DEFS(xlnx_hdmi_rx,
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "xlnx_hdmi_rx")),
+		     DAILINK_COMP_ARRAY(COMP_PLATFORM(NULL)));
+
+SND_SOC_DAILINK_DEFS(xlnx_dp_tx,
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "xlnx_dp_tx")),
+		     DAILINK_COMP_ARRAY(COMP_PLATFORM(NULL)));
+
+SND_SOC_DAILINK_DEFS(xlnx_dp_rx,
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "xlnx_dp_rx")),
+		     DAILINK_COMP_ARRAY(COMP_PLATFORM(NULL)));
+
+SND_SOC_DAILINK_DEFS(xlnx_sdi_tx,
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "xlnx_sdi_tx")),
+		     DAILINK_COMP_ARRAY(COMP_PLATFORM(NULL)));
+
+SND_SOC_DAILINK_DEFS(xlnx_sdi_rx,
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "xlnx_sdi_rx")),
+		     DAILINK_COMP_ARRAY(COMP_PLATFORM(NULL)));
+
+SND_SOC_DAILINK_DEFS(xlnx_spdif_tx,
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "xlnx_spdif_tx")),
+		     DAILINK_COMP_ARRAY(COMP_PLATFORM(NULL)));
+
+SND_SOC_DAILINK_DEFS(xlnx_spdif_rx,
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "xlnx_spdif_rx")),
+		     DAILINK_COMP_ARRAY(COMP_PLATFORM(NULL)));
+
+static struct snd_soc_dai_link xlnx_snd_dai[][XLNX_MAX_PATHS] = {
+	[I2S_AUDIO] = {
+		{
+			.name = "xilinx-i2s_playback",
+			SND_SOC_DAILINK_REG(xlnx_i2s_playback),
+			.ops = &xlnx_i2s_card_ops,
+		},
+		{
+			.name = "xilinx-i2s_capture",
+			SND_SOC_DAILINK_REG(xlnx_i2s_capture),
+			.ops = &xlnx_i2s_card_ops,
+		},
+	},
+	[HDMI_AUDIO] = {
+		{
+			.name = "xilinx-hdmi-playback",
+			SND_SOC_DAILINK_REG(xlnx_hdmi_tx),
+			.ops = &xlnx_hdmi_card_ops,
+			.dai_fmt = SND_SOC_DAIFMT_I2S |
+				   SND_SOC_DAIFMT_NB_NF |
+				   SND_SOC_DAIFMT_CBS_CFS,
+		},
+		{
+			.name = "xilinx-hdmi-capture",
+			SND_SOC_DAILINK_REG(xlnx_hdmi_rx),
+		},
+	},
+	[SDI_AUDIO] = {
+		{
+			.name = "xlnx-sdi-playback",
+			SND_SOC_DAILINK_REG(xlnx_sdi_tx),
+			.ops = &xlnx_sdi_card_ops,
+		},
+		{
+			.name = "xlnx-sdi-capture",
+			SND_SOC_DAILINK_REG(xlnx_sdi_rx),
+		},
+	},
+	[SPDIF_AUDIO] = {
+		{
+			.name = "xilinx-spdif_playback",
+			SND_SOC_DAILINK_REG(xlnx_spdif_tx),
+			.ops = &xlnx_spdif_card_ops,
+		},
+		{
+			.name = "xilinx-spdif_capture",
+			SND_SOC_DAILINK_REG(xlnx_spdif_rx),
+			.ops = &xlnx_spdif_card_ops,
+		},
+	},
+	[DP_AUDIO] = {
+		{
+			.name = "xilinx-dp-playback",
+			SND_SOC_DAILINK_REG(xlnx_dp_tx),
+			.ops = &xlnx_dp_card_ops,
+			.dai_fmt = SND_SOC_DAIFMT_I2S |
+				   SND_SOC_DAIFMT_NB_NF |
+				   SND_SOC_DAIFMT_CBS_CFS,
+		},
+		{
+			.name = "xilinx-dp-capture",
+			SND_SOC_DAILINK_REG(xlnx_dp_rx),
+		},
+	},
+};
+
+static int find_link(struct device_node *node, int direction)
+{
+	int ret;
+	u32 i, size;
+	const char **link_names = dev_compat[direction];
+
+	size = ARRAY_SIZE(dev_compat[direction]);
+
+	for (i = 0; i < size; i++) {
+		ret = of_device_is_compatible(node, link_names[i]);
+		if (ret)
+			return i;
+	}
+	return -ENODEV;
+}
+
+static int xlnx_snd_probe(struct platform_device *pdev)
+{
+	u32 i, max_links = 0, start_count = 0;
+	size_t sz;
+	char *buf;
+	int ret, audio_interface;
+	struct snd_soc_dai_link *dai;
+	struct pl_card_data *prv;
+	struct platform_device *iface_pdev;
+
+	struct snd_soc_card *card;
+	struct device_node **node = pdev->dev.platform_data;
+
+	if (!node)
+		return -ENODEV;
+
+	if (node[XLNX_PLAYBACK] && node[XLNX_CAPTURE]) {
+		max_links = 2;
+		start_count = XLNX_PLAYBACK;
+	} else if (node[XLNX_PLAYBACK]) {
+		max_links = 1;
+		start_count = XLNX_PLAYBACK;
+	} else if (node[XLNX_CAPTURE]) {
+		max_links = 1;
+		start_count = XLNX_CAPTURE;
+	}
+
+	card = devm_kzalloc(&pdev->dev, sizeof(struct snd_soc_card),
+			    GFP_KERNEL);
+	if (!card)
+		return -ENOMEM;
+
+	card->dev = &pdev->dev;
+
+	card->dai_link = devm_kzalloc(card->dev,
+				      sizeof(*dai) * max_links,
+				      GFP_KERNEL);
+	if (!card->dai_link)
+		return -ENOMEM;
+
+	prv = devm_kzalloc(card->dev,
+			   sizeof(struct pl_card_data),
+			   GFP_KERNEL);
+	if (!prv)
+		return -ENOMEM;
+
+	card->num_links = 0;
+	for (i = start_count; i < (start_count + max_links); i++) {
+		struct device_node *pnode = of_parse_phandle(node[i],
+							     "xlnx,snd-pcm", 0);
+		if (!pnode) {
+			dev_err(card->dev, "platform node not found\n");
+			of_node_put(pnode);
+			return -ENODEV;
+		}
+
+		/*
+		 * Check for either playback or capture is enough, as
+		 * same clock is used for both.
+		 */
+		if (i == XLNX_PLAYBACK) {
+			iface_pdev = of_find_device_by_node(pnode);
+			if (!iface_pdev) {
+				of_node_put(pnode);
+				return -ENODEV;
+			}
+
+			prv->mclk = devm_clk_get(&iface_pdev->dev, "aud_mclk");
+			if (IS_ERR(prv->mclk))
+				return PTR_ERR(prv->mclk);
+		}
+		of_node_put(pnode);
+
+		if (max_links == 2)
+			dai = &card->dai_link[i];
+		else
+			dai = &card->dai_link[0];
+
+		audio_interface = find_link(node[i], i);
+		switch (audio_interface) {
+		case I2S_AUDIO:
+			*dai = xlnx_snd_dai[I2S_AUDIO][i];
+			dai->platforms->of_node = pnode;
+			dai->cpus->of_node = node[i];
+			card->num_links++;
+			snd_soc_card_set_drvdata(card, prv);
+			dev_dbg(card->dev, "%s registered\n",
+				card->dai_link[i].name);
+			break;
+		case HDMI_AUDIO:
+			*dai = xlnx_snd_dai[HDMI_AUDIO][i];
+			dai->platforms->of_node = pnode;
+			dai->codecs->of_node = node[i];
+			card->num_links++;
+			/* TODO: support multiple sampling rates */
+			prv->mclk_ratio = 384;
+			snd_soc_card_set_drvdata(card, prv);
+			dev_dbg(card->dev, "%s registered\n",
+				card->dai_link[i].name);
+			break;
+		case SDI_AUDIO:
+			*dai = xlnx_snd_dai[SDI_AUDIO][i];
+			dai->platforms->of_node = pnode;
+			dai->codecs->of_node = node[i];
+			card->num_links++;
+			/* TODO: support multiple sampling rates */
+			prv->mclk_ratio = 384;
+			snd_soc_card_set_drvdata(card, prv);
+			dev_dbg(card->dev, "%s registered\n",
+				card->dai_link[i].name);
+			break;
+		case SPDIF_AUDIO:
+			*dai = xlnx_snd_dai[SPDIF_AUDIO][i];
+			dai->platforms->of_node = pnode;
+			dai->codecs->of_node = node[i];
+			card->num_links++;
+			prv->mclk_ratio = 384;
+			snd_soc_card_set_drvdata(card, prv);
+			dev_dbg(card->dev, "%s registered\n",
+				card->dai_link[i].name);
+			break;
+		case DP_AUDIO:
+			*dai = xlnx_snd_dai[DP_AUDIO][i];
+			dai->platforms->of_node = pnode;
+			dai->codecs->of_node = node[i];
+			card->num_links++;
+			/* TODO: support multiple sampling rates */
+			prv->mclk_ratio = 512;
+			snd_soc_card_set_drvdata(card, prv);
+			dev_dbg(card->dev, "%s registered\n",
+				card->dai_link[i].name);
+			break;
+		default:
+			dev_err(card->dev, "Invalid audio interface\n");
+			return -ENODEV;
+		}
+	}
+
+	if (card->num_links) {
+		/*
+		 *  Example : i2s card name = xlnx-i2s-snd-card-0
+		 *  length = number of chars in "xlnx-i2s-snd-card"
+		 *	    + 1 ('-'), + 1 (card instance num)
+		 *	    + 1 ('\0')
+		 */
+		sz = strlen(xlnx_snd_card_name[audio_interface]) + 3;
+		buf = devm_kzalloc(card->dev, sz, GFP_KERNEL);
+		if (!buf)
+			return -ENOMEM;
+
+		prv->xlnx_snd_dev_id = ida_simple_get(&xlnx_snd_card_dev, 0,
+						      XLNX_MAX_PL_SND_DEV,
+						      GFP_KERNEL);
+		if (prv->xlnx_snd_dev_id < 0)
+			return prv->xlnx_snd_dev_id;
+
+		snprintf(buf, sz, "%s-%d", xlnx_snd_card_name[audio_interface],
+			 prv->xlnx_snd_dev_id);
+		card->name = buf;
+
+		ret = devm_snd_soc_register_card(card->dev, card);
+		if (ret) {
+			dev_err(card->dev, "%s registration failed\n",
+				card->name);
+			ida_simple_remove(&xlnx_snd_card_dev,
+					  prv->xlnx_snd_dev_id);
+			return ret;
+		}
+
+		dev_set_drvdata(card->dev, prv);
+		dev_info(card->dev, "%s registered\n", card->name);
+	}
+
+	return 0;
+}
+
+static void xlnx_snd_remove(struct platform_device *pdev)
+{
+	struct pl_card_data *pdata = dev_get_drvdata(&pdev->dev);
+
+	ida_simple_remove(&xlnx_snd_card_dev, pdata->xlnx_snd_dev_id);
+}
+
+static struct platform_driver xlnx_snd_driver = {
+	.driver = {
+		.name = "xlnx_snd_card",
+	},
+	.probe = xlnx_snd_probe,
+	.remove = xlnx_snd_remove,
+};
+
+module_platform_driver(xlnx_snd_driver);
+
+MODULE_DESCRIPTION("Xilinx FPGA sound card driver");
+MODULE_AUTHOR("Maruthi Srinivas Bayyavarapu");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/xilinx/xlnx_sdi_audio.c b/sound/soc/xilinx/xlnx_sdi_audio.c
new file mode 100644
index 000000000..08ed45bb0
--- /dev/null
+++ b/sound/soc/xilinx/xlnx_sdi_audio.c
@@ -0,0 +1,561 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx SDI embed and extract audio support
+ *
+ * Copyright (c) 2018 Xilinx Pvt., Ltd
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/wait.h>
+#include <drm/drm_modes.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#define DRIVER_NAME "xlnx-sdi-audio"
+
+#define XSDIAUD_CNTRL_REG_OFFSET		0x00
+#define XSDIAUD_SOFT_RST_REG_OFFSET		0x04
+#define XSDIAUD_VER_REG_OFFSET			0x08
+#define XSDIAUD_INT_EN_REG_OFFSET		0x0C
+#define XSDIAUD_INT_STS_REG_OFFSET		0x10
+#define XSDIAUD_EMB_VID_CNTRL_REG_OFFSET	0X14
+#define XSDIAUD_AUD_CNTRL_REG_OFFSET		0x18
+#define XSDIAUD_CH_VALID_REG_OFFSET		0x20
+#define XSDIAUD_CH_MUTE_REG_OFFSET		0x30
+#define XSDIAUD_ACTIVE_GRP_REG_OFFSET		0X40
+#define XSDIAUD_EXT_CH_STAT0_REG_OFFSET		0X48
+#define XSDIAUD_EXT_SRATE_STS_REG_OFFSET	0X70
+#define XSDIAUD_GUI_PARAM_REG_OFFSET		0XFC
+
+#define XSDIAUD_CNTRL_EN_MASK		BIT(0)
+#define XSDIAUD_SOFT_RST_CONFIG_MASK	BIT(0)
+#define XSDIAUD_SOFT_RST_CORE_MASK	BIT(1)
+#define XSDIAUD_VER_MAJOR_MASK		GENMASK(31, 24)
+#define XSDIAUD_VER_MINOR_MASK		GENMASK(23, 16)
+
+#define XSDIAUD_EXT_GROUP_1_STS_MASK	BIT(0)
+#define XSDIAUD_EXT_AUDSTS_UPDATE_MASK	BIT(8)
+#define XSDIAUD_EMB_VID_CNT_ELE_SHIFT	(16)
+#define XSDIAUD_EMB_VID_CNT_ELE_MASK	BIT(16)
+#define XSDIAUD_EMB_VID_CNT_TSCAN_MASK	BIT(8)
+#define XSDIAUD_EMB_VID_CNT_TSCAN_SHIFT	(8)
+#define XSDIAUD_EMB_VID_CNT_TRATE_SHIFT	(4)
+#define XSDIAUD_EMB_AUD_CNT_SS_MASK	BIT(3)
+#define XSDIAUD_EMB_AUD_CNT_ASYNC_AUDIO	BIT(4)
+
+#define CH_STATUS_UPDATE_TIMEOUT	40
+
+enum IP_MODE {
+	EMBED,
+	EXTRACT,
+};
+
+enum channel_id {
+	CHAN_ID_0 = 1,
+	CHAN_ID_1,
+};
+
+enum sdi_transport_family {
+	SDI_TRANSPORT_FAMILY_1920,
+	SDI_TRANSPORT_FAMILY_1280,
+	SDI_TRANSPORT_FAMILY_2048,
+	SDI_TRANSPORT_FAMILY_NTSC = 8,
+	SDI_TRANSPORT_FAMILY_PAL = 9,
+};
+
+/**
+ * enum sdi_audio_samplerate - audio sampling rate
+ * @XSDIAUD_SAMPRATE0:	48 KHz
+ * @XSDIAUD_SAMPRATE1:	44.1 KHz
+ * @XSDIAUD_SAMPRATE2:	32 KHz
+ */
+enum sdi_audio_samplerate {
+	XSDIAUD_SAMPRATE0,
+	XSDIAUD_SAMPRATE1,
+	XSDIAUD_SAMPRATE2
+};
+
+/**
+ * enum sdi_audio_samplesize - bits per sample
+ * @XSDIAUD_SAMPSIZE0:	20 Bit Audio Sample
+ * @XSDIAUD_SAMPSIZE1:	24 Bit Audio Sample
+ */
+enum sdi_audio_samplesize {
+	XSDIAUD_SAMPSIZE0,
+	XSDIAUD_SAMPSIZE1
+};
+
+struct dev_ctx {
+	enum IP_MODE mode;
+	void __iomem *base;
+	struct device *dev;
+	struct drm_display_mode *video_mode;
+	struct snd_pcm_substream *stream;
+	struct clk *axi_clk;
+	struct clk *axis_clk;
+	struct clk *aud_clk;
+	bool rx_srate_updated;
+	wait_queue_head_t srate_q;
+};
+
+static irqreturn_t xtract_irq_handler(int irq, void *dev_id)
+{
+	u32 irq_sts, irq_en, active_grps;
+	struct dev_ctx *ctx = dev_id;
+
+	irq_sts = ioread32(ctx->base + XSDIAUD_INT_STS_REG_OFFSET);
+	active_grps = ioread32(ctx->base + XSDIAUD_ACTIVE_GRP_REG_OFFSET);
+	if ((irq_sts & XSDIAUD_EXT_AUDSTS_UPDATE_MASK) &&
+	    (active_grps & XSDIAUD_EXT_GROUP_1_STS_MASK)) {
+		writel(XSDIAUD_EXT_AUDSTS_UPDATE_MASK,
+		       ctx->base + XSDIAUD_INT_STS_REG_OFFSET);
+		irq_en = ioread32(ctx->base + XSDIAUD_INT_EN_REG_OFFSET);
+		/* Disable further interrupts. sample rate status got updated*/
+		writel(irq_en & ~XSDIAUD_EXT_AUDSTS_UPDATE_MASK,
+		       ctx->base + XSDIAUD_INT_EN_REG_OFFSET);
+
+		ctx->rx_srate_updated = true;
+		wake_up_interruptible(&ctx->srate_q);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+static void audio_enable(void __iomem *aud_base)
+{
+	u32 val;
+
+	val = ioread32(aud_base + XSDIAUD_CNTRL_REG_OFFSET);
+	val |= XSDIAUD_CNTRL_EN_MASK;
+	writel(val, aud_base + XSDIAUD_CNTRL_REG_OFFSET);
+}
+
+static void audio_disable(void __iomem *aud_base)
+{
+	u32 val;
+
+	val = ioread32(aud_base + XSDIAUD_CNTRL_REG_OFFSET);
+	val &= ~XSDIAUD_CNTRL_EN_MASK;
+	writel(val, aud_base + XSDIAUD_CNTRL_REG_OFFSET);
+}
+
+static void audio_reset_core(void __iomem *aud_base, bool reset)
+{
+	u32 val;
+
+	if (reset) {
+		/* reset the core */
+		val = ioread32(aud_base + XSDIAUD_SOFT_RST_REG_OFFSET);
+		val |= XSDIAUD_SOFT_RST_CORE_MASK;
+		writel(val, aud_base + XSDIAUD_SOFT_RST_REG_OFFSET);
+	} else {
+		/* bring the core out of reset */
+		val = ioread32(aud_base + XSDIAUD_SOFT_RST_REG_OFFSET);
+		val &= ~XSDIAUD_SOFT_RST_CORE_MASK;
+		writel(val, aud_base + XSDIAUD_SOFT_RST_REG_OFFSET);
+	}
+}
+
+static int xlnx_sdi_rx_pcm_startup(struct snd_pcm_substream *substream,
+				   struct snd_soc_dai *dai)
+{
+	int err;
+	u32 val, sample_rate;
+
+	struct dev_ctx *ctx = dev_get_drvdata(dai->dev);
+	void __iomem *base = ctx->base;
+	unsigned long jiffies = msecs_to_jiffies(CH_STATUS_UPDATE_TIMEOUT);
+
+	audio_enable(base);
+	writel(XSDIAUD_EXT_AUDSTS_UPDATE_MASK,
+	       ctx->base + XSDIAUD_INT_EN_REG_OFFSET);
+	err = wait_event_interruptible_timeout(ctx->srate_q,
+					       ctx->rx_srate_updated,
+					       jiffies);
+
+	if (!err) {
+		dev_err(ctx->dev, "Didn't get valid audio property update\n");
+		return -EINVAL;
+	}
+	ctx->rx_srate_updated = false;
+
+	val = ioread32(base + XSDIAUD_EXT_SRATE_STS_REG_OFFSET);
+	/* As both channels contain same sample rate, read either of them */
+	switch (val & CHAN_ID_1) {
+	case 0:
+		sample_rate = 48000;
+		break;
+	case 1:
+		sample_rate = 44100;
+		break;
+	case 2:
+		sample_rate = 32000;
+		break;
+	}
+
+	dev_dbg(ctx->dev,
+		"sdi rx audio enabled : sample rate = %d\n", sample_rate);
+	return 0;
+}
+
+static void xlnx_sdi_rx_pcm_shutdown(struct snd_pcm_substream *substream,
+				     struct snd_soc_dai *dai)
+{
+	struct dev_ctx *ctx = dev_get_drvdata(dai->dev);
+
+	audio_disable(ctx->base);
+
+	dev_info(dai->dev, " sdi rx audio disabled\n");
+}
+
+static int xlnx_sdi_tx_pcm_startup(struct snd_pcm_substream *substream,
+				   struct snd_soc_dai *dai)
+{
+	struct dev_ctx *ctx = dev_get_drvdata(dai->dev);
+
+	audio_enable(ctx->base);
+	ctx->stream = substream;
+
+	dev_info(ctx->dev, " sdi tx audio enabled\n");
+	return 0;
+}
+
+static int xlnx_sdi_tx_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *dai)
+{
+	u32 val = 0;
+	u32 num_channels, sample_rate, sig_bits;
+
+	struct dev_ctx *ctx = dev_get_drvdata(dai->dev);
+	void __iomem *base = ctx->base;
+
+	/* video mode properties needed by audio driver are shared to audio
+	 * driver through a pointer in platform data. This is used here in
+	 * audio driver. The solution may be needed to modify/extend to avoid
+	 * probable error scenarios
+	 */
+	if (!ctx->video_mode || !ctx->video_mode->vdisplay ||
+	    !drm_mode_vrefresh(ctx->video_mode)) {
+		dev_err(ctx->dev, "couldn't find video display properties\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * map video properties.
+	 * Note: 1920x1080 and 2048x1080 are the resolutions of sub images for
+	 * 3840x2160 and 4096x2160 resolutions respectively.
+	 */
+	switch (ctx->video_mode->hdisplay) {
+	case 1920:
+	case 3840:
+		val = SDI_TRANSPORT_FAMILY_1920;
+		break;
+	case 1280:
+		val |= SDI_TRANSPORT_FAMILY_1280;
+		break;
+	case 2048:
+	case 4096:
+		val |= SDI_TRANSPORT_FAMILY_2048;
+		break;
+	case 720:
+		if ((ctx->video_mode->flags & DRM_MODE_FLAG_INTERLACE) &&
+		    ctx->video_mode->vdisplay == 243)
+			val |= SDI_TRANSPORT_FAMILY_NTSC;
+		else if ((ctx->video_mode->flags & DRM_MODE_FLAG_INTERLACE) &&
+			 ctx->video_mode->vdisplay == 288)
+			val |= SDI_TRANSPORT_FAMILY_PAL;
+		else
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (drm_mode_vrefresh(ctx->video_mode)) {
+	case 24:
+		val |= (3 << XSDIAUD_EMB_VID_CNT_TRATE_SHIFT);
+		break;
+	case 25:
+		val |= (5 << XSDIAUD_EMB_VID_CNT_TRATE_SHIFT);
+		break;
+	case 30:
+		val |= (7 << XSDIAUD_EMB_VID_CNT_TRATE_SHIFT);
+		break;
+	case 48:
+		val |= (8 << XSDIAUD_EMB_VID_CNT_TRATE_SHIFT);
+		break;
+	case 50:
+		val |= (9 << XSDIAUD_EMB_VID_CNT_TRATE_SHIFT);
+		break;
+	case 60:
+		val |= (11 << XSDIAUD_EMB_VID_CNT_TRATE_SHIFT);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (!(ctx->video_mode->flags & DRM_MODE_FLAG_INTERLACE))
+		val |= XSDIAUD_EMB_VID_CNT_TSCAN_MASK;
+
+	val |= XSDIAUD_EMB_VID_CNT_ELE_MASK;
+
+	writel(val, base + XSDIAUD_EMB_VID_CNTRL_REG_OFFSET);
+
+	/* map audio properties */
+	num_channels = params_channels(params);
+	sample_rate = params_rate(params);
+	sig_bits = snd_pcm_format_width(params_format(params));
+
+	dev_info(ctx->dev,
+		 "stream params: channels = %d sample_rate = %d bits = %d\n",
+		 num_channels, sample_rate, sig_bits);
+
+	val = 0;
+	val |= XSDIAUD_EMB_AUD_CNT_ASYNC_AUDIO;
+
+	switch (sample_rate) {
+	case 48000:
+		val |= XSDIAUD_SAMPRATE0;
+		break;
+	case 44100:
+		val |= XSDIAUD_SAMPRATE1;
+		break;
+	case 32000:
+		val |= XSDIAUD_SAMPRATE2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (sig_bits == 24)
+		val |= XSDIAUD_EMB_AUD_CNT_SS_MASK;
+
+	writel(val, base + XSDIAUD_AUD_CNTRL_REG_OFFSET);
+
+	writel(BIT(num_channels) - 1, base + XSDIAUD_CH_VALID_REG_OFFSET);
+
+	return 0;
+}
+
+static void xlnx_sdi_tx_pcm_shutdown(struct snd_pcm_substream *substream,
+				     struct snd_soc_dai *dai)
+{
+	struct dev_ctx *ctx = dev_get_drvdata(dai->dev);
+	void __iomem *base = ctx->base;
+
+	audio_disable(base);
+	ctx->stream = NULL;
+
+	dev_info(ctx->dev, " sdi tx audio disabled\n");
+}
+
+static const struct snd_soc_component_driver xlnx_sdi_component = {
+	.name = "xlnx-sdi-dai-component",
+};
+
+static const struct snd_soc_dai_ops xlnx_sdi_rx_dai_ops = {
+	.startup = xlnx_sdi_rx_pcm_startup,
+	.shutdown = xlnx_sdi_rx_pcm_shutdown,
+};
+
+static struct snd_soc_dai_driver xlnx_sdi_rx_dai = {
+	.name = "xlnx_sdi_rx",
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 8,
+		.rates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
+			SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.ops = &xlnx_sdi_rx_dai_ops,
+};
+
+static const struct snd_soc_dai_ops xlnx_sdi_tx_dai_ops = {
+	.startup =	xlnx_sdi_tx_pcm_startup,
+	.hw_params =	xlnx_sdi_tx_hw_params,
+	.shutdown =	xlnx_sdi_tx_pcm_shutdown,
+};
+
+static struct snd_soc_dai_driver xlnx_sdi_tx_dai = {
+	.name = "xlnx_sdi_tx",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 8,
+		.rates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
+			SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.ops = &xlnx_sdi_tx_dai_ops,
+};
+
+static int xlnx_sdi_audio_probe(struct platform_device *pdev)
+{
+	u32 val, irq;
+	int ret;
+	struct dev_ctx *ctx;
+	struct device *video_dev;
+	struct device_node *video_node;
+	struct platform_device *video_pdev;
+	struct snd_soc_dai_driver *snd_dai;
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+
+	/* TODO - remove before upstreaming */
+	if (of_device_is_compatible(node, "xlnx,v-uhdsdi-audio-1.0")) {
+		dev_err(&pdev->dev, "driver doesn't support sdi audio v1.0\n");
+		return -ENODEV;
+	}
+
+	ctx = devm_kzalloc(&pdev->dev, sizeof(struct dev_ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENODEV;
+
+	ctx->axi_clk = devm_clk_get_enabled(&pdev->dev, "s_axi_aclk");
+	if (IS_ERR(ctx->axi_clk)) {
+		ret = PTR_ERR(ctx->axi_clk);
+		dev_err(&pdev->dev, "failed to get s_axi_aclk(%d)\n", ret);
+		return ret;
+	}
+
+	ctx->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(ctx->base))
+		return PTR_ERR(ctx->base);
+
+	ctx->dev = &pdev->dev;
+
+	val = ioread32(ctx->base + XSDIAUD_GUI_PARAM_REG_OFFSET);
+	if (val & BIT(6)) {
+		ctx->mode = EXTRACT;
+
+		ctx->axis_clk = devm_clk_get_enabled(&pdev->dev, "m_axis_clk");
+		if (IS_ERR(ctx->axis_clk)) {
+			ret = PTR_ERR(ctx->axis_clk);
+			dev_err(&pdev->dev, "failed to get m_axis_clk(%d)\n",
+				ret);
+			return ret;
+		}
+
+		ctx->aud_clk = devm_clk_get_enabled(&pdev->dev, "sdi_extract_clk");
+		if (IS_ERR(ctx->aud_clk)) {
+			ret = PTR_ERR(ctx->aud_clk);
+			dev_err(&pdev->dev, "failed to get sdi_extract_clk(%d)\n",
+				ret);
+			return ret;
+		}
+
+		irq = platform_get_irq(pdev, 0);
+		if (irq < 0) {
+			dev_err(&pdev->dev, "No IRQ resource found\n");
+			return irq;
+		}
+		ret = devm_request_irq(&pdev->dev, irq,
+				       xtract_irq_handler,
+				       0, "XLNX_SDI_AUDIO_XTRACT", ctx);
+		if (ret) {
+			dev_err(&pdev->dev, "extract irq request failed\n");
+			return -ENODEV;
+		}
+
+		init_waitqueue_head(&ctx->srate_q);
+
+		snd_dai = &xlnx_sdi_rx_dai;
+	} else {
+		ctx->mode = EMBED;
+		ctx->axis_clk = devm_clk_get_enabled(&pdev->dev, "s_axis_clk");
+		if (IS_ERR(ctx->axis_clk)) {
+			ret = PTR_ERR(ctx->axis_clk);
+			dev_err(&pdev->dev, "failed to get s_axis_clk(%d)\n",
+				ret);
+			return ret;
+		}
+
+		ctx->aud_clk = devm_clk_get_enabled(&pdev->dev, "sdi_embed_clk");
+		if (IS_ERR(ctx->aud_clk)) {
+			ret = PTR_ERR(ctx->aud_clk);
+			dev_err(&pdev->dev, "failed to get aud_clk(%d)\n",
+				ret);
+			return ret;
+		}
+
+		video_node = of_graph_get_remote_node(pdev->dev.of_node, 0, 0);
+		if (!video_node) {
+			dev_err(ctx->dev, "video_node not found\n");
+			of_node_put(video_node);
+			return -ENODEV;
+		}
+
+		video_pdev = of_find_device_by_node(video_node);
+		if (!video_pdev) {
+			of_node_put(video_node);
+			return -ENODEV;
+		}
+
+		video_dev = &video_pdev->dev;
+		ctx->video_mode =
+			(struct drm_display_mode *)video_dev->platform_data;
+		/* invalid 'platform_data' implies video driver is not loaded */
+		if (!ctx->video_mode) {
+			of_node_put(video_node);
+			return -EPROBE_DEFER;
+		}
+
+		snd_dai = &xlnx_sdi_tx_dai;
+		of_node_put(video_node);
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &xlnx_sdi_component,
+					      snd_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "couldn't register codec DAI\n");
+		return ret;
+	}
+
+	dev_set_drvdata(&pdev->dev, ctx);
+
+	audio_reset_core(ctx->base, true);
+	audio_reset_core(ctx->base, false);
+
+	dev_info(&pdev->dev, "xlnx sdi codec dai component registered\n");
+	return 0;
+}
+
+static void xlnx_sdi_audio_remove(struct platform_device *pdev)
+{
+	struct dev_ctx *ctx = dev_get_drvdata(&pdev->dev);
+
+	audio_disable(ctx->base);
+	audio_reset_core(ctx->base, true);
+}
+
+static const struct of_device_id xlnx_sdi_audio_of_match[] = {
+	{ .compatible = "xlnx,v-uhdsdi-audio-1.0"},
+	{ .compatible = "xlnx,v-uhdsdi-audio-2.0"},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xlnx_sdi_audio_of_match);
+
+static struct platform_driver xlnx_sdi_audio_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.of_match_table = xlnx_sdi_audio_of_match,
+	},
+	.probe = xlnx_sdi_audio_probe,
+	.remove = xlnx_sdi_audio_remove,
+};
+
+module_platform_driver(xlnx_sdi_audio_driver);
+
+MODULE_DESCRIPTION("xilinx sdi audio codec driver");
+MODULE_AUTHOR("Maruthi Srinivas Bayyavarapu");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/xilinx/xlnx_snd_common.h b/sound/soc/xilinx/xlnx_snd_common.h
new file mode 100644
index 000000000..f19d8de0f
--- /dev/null
+++ b/sound/soc/xilinx/xlnx_snd_common.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Xilinx ASoC sound card support
+ *
+ * Copyright (C) 2018 Xilinx, Inc.
+ */
+
+#ifndef _XLNX_SND_COMMON_H
+#define _XLNX_SND_COMMON_H
+
+enum {
+	XLNX_PLAYBACK = 0,
+	XLNX_CAPTURE = 1,
+	XLNX_MAX_PATHS = 2
+};
+
+struct pl_card_data {
+	u32 mclk_val;
+	u32 mclk_ratio;
+	int xlnx_snd_dev_id;
+	struct clk *mclk;
+};
+#endif /* _XLNX_SND_COMMON_H */
diff --git a/sound/soc/xilinx/xlnx_spdif.c b/sound/soc/xilinx/xlnx_spdif.c
index 7febb3830..4a511d76c 100644
--- a/sound/soc/xilinx/xlnx_spdif.c
+++ b/sound/soc/xilinx/xlnx_spdif.c
@@ -24,32 +24,43 @@
 #define XLNX_SPDIF_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
 
 #define XSPDIF_IRQ_STS_REG		0x20
+#define XSPDIF_IRQ_STS_CH_STS_MASK	BIT(5)
 #define XSPDIF_IRQ_ENABLE_REG		0x28
 #define XSPDIF_SOFT_RESET_REG		0x40
+#define XSPDIF_SOFT_RESET_VAL		0xA
 #define XSPDIF_CONTROL_REG		0x44
+#define XSPDIF_CONTROL_ENABLE_MASK	BIT(0)
+#define XSPDIF_CONTROL_FIFO_FLUSH_MASK	BIT(1)
+#define XSPDIF_CONTROL_CLK_CFG_MASK	GENMASK(5, 2)
+#define XSPDIF_CONTROL_CLK_CFG_SHIFT	2
 #define XSPDIF_CHAN_0_STS_REG		0x4C
-#define XSPDIF_GLOBAL_IRQ_ENABLE_REG	0x1C
+#define XSPDIF_GLOBAL_IRQ_REG		0x1C
+#define XSPDIF_GLOBAL_IRQ_ENABLE_MASK	BIT(31)
 #define XSPDIF_CH_A_USER_DATA_REG_0	0x64
 
-#define XSPDIF_CORE_ENABLE_MASK		BIT(0)
-#define XSPDIF_FIFO_FLUSH_MASK		BIT(1)
-#define XSPDIF_CH_STS_MASK		BIT(5)
-#define XSPDIF_GLOBAL_IRQ_ENABLE	BIT(31)
-#define XSPDIF_CLOCK_CONFIG_BITS_MASK	GENMASK(5, 2)
-#define XSPDIF_CLOCK_CONFIG_BITS_SHIFT	2
-#define XSPDIF_SOFT_RESET_VALUE		0xA
-
-#define MAX_CHANNELS			2
-#define AES_SAMPLE_WIDTH		32
-#define CH_STATUS_UPDATE_TIMEOUT	40
+#define XSPDIF_MAX_CHANNELS		2
+#define XSPDIF_AES_SAMPLE_WIDTH		32
+#define XSPDIF_CH_STS_UPDATE_TIMEOUT	40
+
+enum {
+	CLK_DIV_BY_4,
+	CLK_DIV_BY_8,
+	CLK_DIV_BY_16,
+	CLK_DIV_BY_24,
+	CLK_DIV_BY_32,
+	CLK_DIV_BY_48,
+	CLK_DIV_BY_64,
+};
 
 struct spdif_dev_data {
-	u32 mode;
-	u32 aclk;
-	bool rx_chsts_updated;
+	wait_queue_head_t chsts_q;
 	void __iomem *base;
 	struct clk *axi_clk;
-	wait_queue_head_t chsts_q;
+	struct clk *axis_clk;
+	struct clk *aud_clk;
+	u32 mode;
+	unsigned long aclk;
+	bool rx_chsts_updated;
 };
 
 static irqreturn_t xlnx_spdifrx_irq_handler(int irq, void *arg)
@@ -57,13 +68,13 @@ static irqreturn_t xlnx_spdifrx_irq_handler(int irq, void *arg)
 	u32 val;
 	struct spdif_dev_data *ctx = arg;
 
-	val = readl(ctx->base + XSPDIF_IRQ_STS_REG);
-	if (val & XSPDIF_CH_STS_MASK) {
-		writel(val & XSPDIF_CH_STS_MASK,
+	val = ioread32(ctx->base + XSPDIF_IRQ_STS_REG);
+	if (val & XSPDIF_IRQ_STS_CH_STS_MASK) {
+		writel(val & XSPDIF_IRQ_STS_CH_STS_MASK,
 		       ctx->base + XSPDIF_IRQ_STS_REG);
-		val = readl(ctx->base +
-			    XSPDIF_IRQ_ENABLE_REG);
-		writel(val & ~XSPDIF_CH_STS_MASK,
+		val = ioread32(ctx->base +
+			       XSPDIF_IRQ_ENABLE_REG);
+		writel(val & ~XSPDIF_IRQ_STS_CH_STS_MASK,
 		       ctx->base + XSPDIF_IRQ_ENABLE_REG);
 
 		ctx->rx_chsts_updated = true;
@@ -80,15 +91,15 @@ static int xlnx_spdif_startup(struct snd_pcm_substream *substream,
 	u32 val;
 	struct spdif_dev_data *ctx = dev_get_drvdata(dai->dev);
 
-	val = readl(ctx->base + XSPDIF_CONTROL_REG);
-	val |= XSPDIF_FIFO_FLUSH_MASK;
+	val = ioread32(ctx->base + XSPDIF_CONTROL_REG);
+	val |= XSPDIF_CONTROL_FIFO_FLUSH_MASK;
 	writel(val, ctx->base + XSPDIF_CONTROL_REG);
 
 	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
-		writel(XSPDIF_CH_STS_MASK,
+		writel(XSPDIF_IRQ_STS_CH_STS_MASK,
 		       ctx->base + XSPDIF_IRQ_ENABLE_REG);
-		writel(XSPDIF_GLOBAL_IRQ_ENABLE,
-		       ctx->base + XSPDIF_GLOBAL_IRQ_ENABLE_REG);
+		writel(XSPDIF_GLOBAL_IRQ_ENABLE_MASK,
+		       ctx->base + XSPDIF_GLOBAL_IRQ_REG);
 	}
 
 	return 0;
@@ -99,7 +110,7 @@ static void xlnx_spdif_shutdown(struct snd_pcm_substream *substream,
 {
 	struct spdif_dev_data *ctx = dev_get_drvdata(dai->dev);
 
-	writel(XSPDIF_SOFT_RESET_VALUE, ctx->base + XSPDIF_SOFT_RESET_REG);
+	writel(XSPDIF_SOFT_RESET_VAL, ctx->base + XSPDIF_SOFT_RESET_REG);
 }
 
 static int xlnx_spdif_hw_params(struct snd_pcm_substream *substream,
@@ -109,38 +120,40 @@ static int xlnx_spdif_hw_params(struct snd_pcm_substream *substream,
 	u32 val, clk_div, clk_cfg;
 	struct spdif_dev_data *ctx = dev_get_drvdata(dai->dev);
 
-	clk_div = DIV_ROUND_CLOSEST(ctx->aclk, MAX_CHANNELS * AES_SAMPLE_WIDTH *
+	ctx->aclk = clk_get_rate(ctx->aud_clk);
+	clk_div = DIV_ROUND_CLOSEST(ctx->aclk, XSPDIF_MAX_CHANNELS *
+				    XSPDIF_AES_SAMPLE_WIDTH *
 				    params_rate(params));
 
 	switch (clk_div) {
 	case 4:
-		clk_cfg = 0;
+		clk_cfg = CLK_DIV_BY_4;
 		break;
 	case 8:
-		clk_cfg = 1;
+		clk_cfg = CLK_DIV_BY_8;
 		break;
 	case 16:
-		clk_cfg = 2;
+		clk_cfg = CLK_DIV_BY_16;
 		break;
 	case 24:
-		clk_cfg = 3;
+		clk_cfg = CLK_DIV_BY_24;
 		break;
 	case 32:
-		clk_cfg = 4;
+		clk_cfg = CLK_DIV_BY_32;
 		break;
 	case 48:
-		clk_cfg = 5;
+		clk_cfg = CLK_DIV_BY_48;
 		break;
 	case 64:
-		clk_cfg = 6;
+		clk_cfg = CLK_DIV_BY_64;
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	val = readl(ctx->base + XSPDIF_CONTROL_REG);
-	val &= ~XSPDIF_CLOCK_CONFIG_BITS_MASK;
-	val |= clk_cfg << XSPDIF_CLOCK_CONFIG_BITS_SHIFT;
+	val = ioread32(ctx->base + XSPDIF_CONTROL_REG);
+	val &= ~XSPDIF_CONTROL_CLK_CFG_MASK;
+	val |= clk_cfg << XSPDIF_CONTROL_CLK_CFG_SHIFT;
 	writel(val, ctx->base + XSPDIF_CONTROL_REG);
 
 	return 0;
@@ -150,7 +163,7 @@ static int rx_stream_detect(struct snd_soc_dai *dai)
 {
 	int err;
 	struct spdif_dev_data *ctx = dev_get_drvdata(dai->dev);
-	unsigned long jiffies = msecs_to_jiffies(CH_STATUS_UPDATE_TIMEOUT);
+	unsigned long jiffies = msecs_to_jiffies(XSPDIF_CH_STS_UPDATE_TIMEOUT);
 
 	/* start capture only if stream is detected within 40ms timeout */
 	err = wait_event_interruptible_timeout(ctx->chsts_q,
@@ -172,12 +185,12 @@ static int xlnx_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 	int ret = 0;
 	struct spdif_dev_data *ctx = dev_get_drvdata(dai->dev);
 
-	val = readl(ctx->base + XSPDIF_CONTROL_REG);
+	val = ioread32(ctx->base + XSPDIF_CONTROL_REG);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		val |= XSPDIF_CORE_ENABLE_MASK;
+		val |= XSPDIF_CONTROL_ENABLE_MASK;
 		writel(val, ctx->base + XSPDIF_CONTROL_REG);
 		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
 			ret = rx_stream_detect(dai);
@@ -185,7 +198,7 @@ static int xlnx_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		val &= ~XSPDIF_CORE_ENABLE_MASK;
+		val &= ~XSPDIF_CONTROL_ENABLE_MASK;
 		writel(val, ctx->base + XSPDIF_CONTROL_REG);
 		break;
 	default:
@@ -248,51 +261,59 @@ static int xlnx_spdif_probe(struct platform_device *pdev)
 	if (!ctx)
 		return -ENOMEM;
 
-	ctx->axi_clk = devm_clk_get(dev, "s_axi_aclk");
+	ctx->axi_clk = devm_clk_get_enabled(dev, "s_axi_aclk");
 	if (IS_ERR(ctx->axi_clk)) {
 		ret = PTR_ERR(ctx->axi_clk);
 		dev_err(dev, "failed to get s_axi_aclk(%d)\n", ret);
 		return ret;
 	}
-	ret = clk_prepare_enable(ctx->axi_clk);
-	if (ret) {
-		dev_err(dev, "failed to enable s_axi_aclk(%d)\n", ret);
-		return ret;
-	}
 
 	ctx->base = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(ctx->base)) {
-		ret = PTR_ERR(ctx->base);
-		goto clk_err;
-	}
+	if (IS_ERR(ctx->base))
+		return PTR_ERR(ctx->base);
+
 	ret = of_property_read_u32(node, "xlnx,spdif-mode", &ctx->mode);
 	if (ret < 0) {
 		dev_err(dev, "cannot get SPDIF mode\n");
-		goto clk_err;
+		return ret;
 	}
 	if (ctx->mode) {
+		ctx->axis_clk = devm_clk_get_enabled(dev, "s_axis_aclk");
+		if (IS_ERR(ctx->axis_clk)) {
+			ret = PTR_ERR(ctx->axis_clk);
+			dev_err(dev, "failed to get s_axis_aclk(%d)\n", ret);
+			return ret;
+		}
 		dai_drv = &xlnx_spdif_tx_dai;
 	} else {
+		ctx->axis_clk = devm_clk_get(dev, "m_axis_aclk");
+		if (IS_ERR(ctx->axis_clk)) {
+			ret = PTR_ERR(ctx->axis_clk);
+			dev_err(dev, "failed to get m_axis_aclk(%d)\n", ret);
+			return ret;
+		}
+
 		ret = platform_get_irq(pdev, 0);
 		if (ret < 0)
-			goto clk_err;
+			return ret;
+
 		ret = devm_request_irq(dev, ret,
 				       xlnx_spdifrx_irq_handler,
 				       0, "XLNX_SPDIF_RX", ctx);
 		if (ret) {
 			dev_err(dev, "spdif rx irq request failed\n");
-			ret = -ENODEV;
-			goto clk_err;
+			return -ENODEV;
 		}
 
 		init_waitqueue_head(&ctx->chsts_q);
 		dai_drv = &xlnx_spdif_rx_dai;
 	}
 
-	ret = of_property_read_u32(node, "xlnx,aud_clk_i", &ctx->aclk);
-	if (ret < 0) {
-		dev_err(dev, "cannot get aud_clk_i value\n");
-		goto clk_err;
+	ctx->aud_clk = devm_clk_get_enabled(dev, "aud_clk_i");
+	if (IS_ERR(ctx->aud_clk)) {
+		ret = PTR_ERR(ctx->aud_clk);
+		dev_err(dev, "failed to get aud_aclk(%d)\n", ret);
+		return ret;
 	}
 
 	dev_set_drvdata(dev, ctx);
@@ -301,22 +322,13 @@ static int xlnx_spdif_probe(struct platform_device *pdev)
 					      dai_drv, 1);
 	if (ret) {
 		dev_err(dev, "SPDIF component registration failed\n");
-		goto clk_err;
+		return ret;
 	}
 
-	writel(XSPDIF_SOFT_RESET_VALUE, ctx->base + XSPDIF_SOFT_RESET_REG);
+	writel(XSPDIF_SOFT_RESET_VAL, ctx->base + XSPDIF_SOFT_RESET_REG);
 	dev_info(dev, "%s DAI registered\n", dai_drv->name);
 
-clk_err:
-	clk_disable_unprepare(ctx->axi_clk);
-	return ret;
-}
-
-static void xlnx_spdif_remove(struct platform_device *pdev)
-{
-	struct spdif_dev_data *ctx = dev_get_drvdata(&pdev->dev);
-
-	clk_disable_unprepare(ctx->axi_clk);
+	return 0;
 }
 
 static struct platform_driver xlnx_spdif_driver = {
@@ -325,7 +337,6 @@ static struct platform_driver xlnx_spdif_driver = {
 		.of_match_table = xlnx_spdif_of_match,
 	},
 	.probe = xlnx_spdif_probe,
-	.remove = xlnx_spdif_remove,
 };
 module_platform_driver(xlnx_spdif_driver);
 
