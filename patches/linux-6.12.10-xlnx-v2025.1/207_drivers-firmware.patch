--- linux-6.12.10/Documentation/ABI/stable/sysfs-driver-firmware-zynqmp	2025-07-02 11:58:25.928966600 +0900
+++ linux-xlnx-2025.1/Documentation/ABI/stable/sysfs-driver-firmware-zynqmp	2025-07-02 12:01:10.523725800 +0900
@@ -254,3 +254,16 @@
 		The expected result is 500.
 
 Users:		Xilinx
+
+What:		/sys/devices/platform/firmware\:zynqmp-firmware/last_reset_reason
+Date:		Nov 2023
+KernelVersion:	6.7
+Contact:	"Ronak Jain" <ronak.jain@amd.com>
+Description:
+		This sysfs interface allows to get last reset reason.
+
+		Usage:
+		Get last reset reason
+		# cat /sys/devices/platform/firmware\:zynqmp-firmware/last_reset_reason
+
+Users:		Xilinx
--- linux-6.12.10/Documentation/devicetree/bindings/firmware/xilinx/xlnx,zynqmp-firmware.yaml	2025-07-02 11:58:26.910889600 +0900
+++ linux-xlnx-2025.1/Documentation/devicetree/bindings/firmware/xilinx/xlnx,zynqmp-firmware.yaml	2025-07-02 12:01:11.631867600 +0900
@@ -32,6 +32,9 @@
               - xlnx,versal-net-firmware
           - const: xlnx,versal-firmware
 
+      - description: For implementations complying for Versal Gen 2.
+        const: xlnx,versal2-firmware
+
   method:
     description: |
                  The method of calling the PM-API firmware layer.
@@ -98,12 +101,18 @@
     description: Compatible of the FPGA device.
     type: object
 
+  versal-sec-cfg:
+    $ref: /schemas/nvmem/xlnx,versal-sec-cfg.yaml#
+    description: Secure configuration driver
+    type: object
+
   zynqmp-aes:
     $ref: /schemas/crypto/xlnx,zynqmp-aes.yaml#
     description: The ZynqMP AES-GCM hardened cryptographic accelerator is
       used to encrypt or decrypt the data with provided key and initialization
       vector.
     type: object
+    deprecated: true
 
 required:
   - compatible
--- linux-6.12.10/drivers/firmware/xilinx/Kconfig	2025-07-02 11:58:39.766035000 +0900
+++ linux-xlnx-2025.1/drivers/firmware/xilinx/Kconfig	2025-07-02 12:01:23.392109000 +0900
@@ -23,4 +23,12 @@
 	  Say yes to enable ZynqMP firmware interface debug APIs.
 	  If in doubt, say N.
 
+config ZYNQMP_FIRMWARE_SECURE
+	bool "Enable Xilinx Zynq MPSoC secure firmware loading APIs"
+	help
+	  Firmware secure driver is used as an interface to load
+	  Authenticated and/or Encrypted firmware with single loadable
+	  partition. Say yes to enable ZynqMP secure firmware loading
+	  APIs.If in doubt, say N
+
 endmenu
--- linux-6.12.10/drivers/firmware/xilinx/Makefile	2025-07-02 11:58:39.767034000 +0900
+++ linux-xlnx-2025.1/drivers/firmware/xilinx/Makefile	2025-07-02 12:01:23.392109000 +0900
@@ -1,5 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
 # Makefile for Xilinx firmwares
 
-obj-$(CONFIG_ZYNQMP_FIRMWARE) += zynqmp.o
+obj-$(CONFIG_ZYNQMP_FIRMWARE) += zynqmp-core.o zynqmp-pm.o zynqmp-sem.o zynqmp-fpga.o zynqmp-nvm.o zynqmp-pdi.o zynqmp-crypto.o
 obj-$(CONFIG_ZYNQMP_FIRMWARE_DEBUG) += zynqmp-debug.o
+obj-$(CONFIG_ZYNQMP_FIRMWARE_SECURE) += zynqmp-secure.o
--- /dev/null
+++ linux-xlnx-2025.1/drivers/firmware/xilinx/zynqmp-core.c	2025-07-02 12:01:23.393081900 +0900
@@ -0,0 +1,934 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx Zynq MPSoC Firmware layer core APIs.
+ *
+ * Copyright (C), 2025 Advanced Micro Devices, Inc.
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/dma-mapping.h>
+#include <linux/hashtable.h>
+#include <linux/mfd/core.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+
+#include <linux/firmware/xlnx-zynqmp.h>
+#include "zynqmp-debug.h"
+
+/* Max HashMap Order for PM API feature check (1<<7 = 128) */
+#define PM_API_FEATURE_CHECK_MAX_ORDER	7
+
+/* IOCTL/QUERY feature payload size */
+#define FEATURE_PAYLOAD_SIZE		2
+
+static bool feature_check_enabled;
+static DEFINE_HASHTABLE(pm_api_features_map, PM_API_FEATURE_CHECK_MAX_ORDER);
+static u32 ioctl_features[FEATURE_PAYLOAD_SIZE];
+static u32 query_features[FEATURE_PAYLOAD_SIZE];
+
+static u32 sip_svc_version;
+static struct platform_device *em_dev;
+
+static const struct mfd_cell firmware_devs[] = {
+	{
+		.name = "zynqmp_power_controller",
+	},
+};
+
+/**
+ * struct pm_api_feature_data - PM API Feature data
+ * @pm_api_id:		PM API Id, used as key to index into hashmap
+ * @feature_status:	status of PM API feature: valid, invalid
+ * @hentry:		hlist_node that hooks this entry into hashtable
+ */
+struct pm_api_feature_data {
+	u32 pm_api_id;
+	int feature_status;
+	struct hlist_node hentry;
+};
+
+struct platform_fw_data {
+	/*
+	 * Invokes the platform-specific feature check PM FW API call.
+	 * Uses either the basic or extended SMCCC frame format based on the
+	 * platform.
+	 */
+	int (*do_feature_check)(const u32 api_id, u32 *ret_payload);
+
+	/*
+	 * Invokes all other platform-specific PM FW APIs.
+	 * Uses either the basic or extended SMCCC frame format based
+	 * on the platform.
+	 */
+	int (*zynqmp_pm_fw_call)(u32 pm_api_id, u32 *ret_payload,
+				 u32 num_args, va_list *arg_list);
+
+	/*
+	 * Prepares the PLM command header for the platform.
+	 * The header will either use the PM_API_FEATURES or PM_FEATURE_CHECK,
+	 * depending on the platform.
+	 */
+	uint64_t (*prep_pm_cmd_header)(u32 module_id);
+
+	/*
+	 * Indicates whether the word swap required for the memory address
+	 * while loading PDI image based on the platform
+	 */
+	bool load_pdi_word_swap;
+};
+
+static struct platform_fw_data *active_platform_fw_data;
+
+/**
+ * zynqmp_pm_ret_code() - Convert PMU-FW error codes to Linux error codes
+ * @ret_status:		PMUFW return code
+ *
+ * Return: corresponding Linux error code
+ */
+static int zynqmp_pm_ret_code(u32 ret_status)
+{
+	switch (ret_status) {
+	case XST_PM_SUCCESS:
+	case XST_PM_DOUBLE_REQ:
+		return 0;
+	case XST_PM_NO_FEATURE:
+		return -ENOTSUPP;
+	case XST_PM_INVALID_VERSION:
+		return -EOPNOTSUPP;
+	case XST_PM_NO_ACCESS:
+		return -EACCES;
+	case XST_PM_ABORT_SUSPEND:
+		return -ECANCELED;
+	case XST_PM_MULT_USER:
+		return -EUSERS;
+	case XST_PM_INTERNAL:
+	case XST_PM_CONFLICT:
+	case XST_PM_INVALID_NODE:
+	case XST_PM_INVALID_CRC:
+	default:
+		return -EINVAL;
+	}
+}
+
+static noinline int do_fw_call_fail(u32 *ret_payload, u32 num_args, ...)
+{
+	return -ENODEV;
+}
+
+/*
+ * PM function call wrapper
+ * Invoke do_fw_call_smc or do_fw_call_hvc, depending on the configuration
+ */
+static int (*do_fw_call)(u32 *ret_payload, u32, ...) = do_fw_call_fail;
+
+/**
+ * do_fw_call_smc() - Call system-level platform management layer (SMC)
+ * @num_args:		Number of variable arguments should be <= 8
+ * @ret_payload:	Returned value array
+ *
+ * Invoke platform management function via SMC call (no hypervisor present).
+ *
+ * Return: Returns status, either success or error+reason
+ */
+static noinline int do_fw_call_smc(u32 *ret_payload, u32 num_args, ...)
+{
+	struct arm_smccc_res res;
+	u64 args[8] = {0};
+	va_list arg_list;
+	u8 i;
+
+	if (num_args > 8)
+		return -EINVAL;
+
+	va_start(arg_list, num_args);
+
+	for (i = 0; i < num_args; i++)
+		args[i] = va_arg(arg_list, u64);
+
+	va_end(arg_list);
+
+	arm_smccc_smc(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], &res);
+
+	if (ret_payload) {
+		ret_payload[0] = lower_32_bits(res.a0);
+		ret_payload[1] = upper_32_bits(res.a0);
+		ret_payload[2] = lower_32_bits(res.a1);
+		ret_payload[3] = upper_32_bits(res.a1);
+		ret_payload[4] = lower_32_bits(res.a2);
+		ret_payload[5] = upper_32_bits(res.a2);
+		ret_payload[6] = lower_32_bits(res.a3);
+	}
+
+	return zynqmp_pm_ret_code((enum pm_ret_status)res.a0);
+}
+
+/**
+ * do_fw_call_hvc() - Call system-level platform management layer (HVC)
+ * @num_args:		Number of variable arguments should be <= 8
+ * @ret_payload:	Returned value array
+ *
+ * Invoke platform management function via HVC
+ * HVC-based for communication through hypervisor
+ * (no direct communication with ATF).
+ *
+ * Return: Returns status, either success or error+reason
+ */
+static noinline int do_fw_call_hvc(u32 *ret_payload, u32 num_args, ...)
+{
+	struct arm_smccc_res res;
+	u64 args[8] = {0};
+	va_list arg_list;
+	u8 i;
+
+	if (num_args > 8)
+		return -EINVAL;
+
+	va_start(arg_list, num_args);
+
+	for (i = 0; i < num_args; i++)
+		args[i] = va_arg(arg_list, u64);
+
+	va_end(arg_list);
+
+	arm_smccc_hvc(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], &res);
+
+	if (ret_payload) {
+		ret_payload[0] = lower_32_bits(res.a0);
+		ret_payload[1] = upper_32_bits(res.a0);
+		ret_payload[2] = lower_32_bits(res.a1);
+		ret_payload[3] = upper_32_bits(res.a1);
+		ret_payload[4] = lower_32_bits(res.a2);
+		ret_payload[5] = upper_32_bits(res.a2);
+		ret_payload[6] = lower_32_bits(res.a3);
+	}
+
+	return zynqmp_pm_ret_code((enum pm_ret_status)res.a0);
+}
+
+static uint64_t prep_pm_hdr_feature_check(u32 module_id)
+{
+	/* Ignore module_id argument but it is PM_MODULE_ID=0 used here */
+	return PM_SIP_SVC | PM_FEATURE_CHECK;
+}
+
+static uint64_t prep_pm_hdr_api_features(u32 module_id)
+{
+	return PM_SIP_SVC | FIELD_PREP(MODULE_ID_MASK, module_id) | PM_API_FEATURES;
+}
+
+/**
+ * do_feature_check_for_tfa_apis - Perform feature check for TF-A APIs.
+ * @api_id: API ID to be checked.
+ * @ret_payload: Pointer to store the firmware's response payload.
+ *
+ * Prepares the command header and payload for TF-A APIs and makes the FW call
+ *
+ * Return:
+ * - 0 on success
+ * - -EOPNOTSUPP if the firmware call fails.
+ * - -ENODEV if the active_platform_fw_data is NULL.
+ */
+static int do_feature_check_for_tfa_apis(const u32 api_id, u32 *ret_payload)
+{
+	u32 module_id;
+	u64 smc_arg[2];
+	int ret;
+
+	if (!active_platform_fw_data)
+		return -ENODEV;
+
+	module_id = FIELD_GET(MODULE_ID_MASK, api_id);
+
+	smc_arg[0] = active_platform_fw_data->prep_pm_cmd_header(module_id);
+	smc_arg[1] = api_id;
+
+	ret = do_fw_call(ret_payload, 2, smc_arg[0], smc_arg[1]);
+
+	if (ret)
+		return -EOPNOTSUPP;
+
+	return ret_payload[1];
+}
+
+/**
+ * do_feature_check_extended - Perform feature check for an API ID
+ *				 using extended SMCCC format.
+ * @api_id: API ID to be checked.
+ * @ret_payload: Pointer to store the firmware's response payload.
+ *
+ * Determines the appropriate API (PM_FEATURE_CHECK or PM_API_FEATURES) based on
+ * the module ID in the given API ID. Frames the arguments in the extended
+ * SMCCC format, executes the firmware call, and processes the result.
+ *
+ * Return:
+ * - 0 on success
+ * - -EOPNOTSUPP if the firmware call fails.
+ */
+static int do_feature_check_extended(const u32 api_id, u32 *ret_payload)
+{
+	int ret;
+	u64 smc_arg[2];
+	u32 module_id;
+	u32 feature_check_api_id;
+
+	module_id = FIELD_GET(MODULE_ID_MASK, api_id);
+
+	/*
+	 * Feature check of APIs belonging to PM and XSEM are handled by calling
+	 * PM_FEATURE_CHECK API. For other modules, call PM_API_FEATURES API.
+	 */
+	if (module_id == PM_MODULE_ID || module_id == XSEM_MODULE_ID)
+		feature_check_api_id = PM_FEATURE_CHECK;
+	else
+		feature_check_api_id = PM_API_FEATURES;
+
+	if (module_id == PM_MODULE_ID)
+		module_id = XPM_MODULE_ID;
+
+	/* Frame extended SMC format */
+	smc_arg[0] = PM_SIP_SVC | PASS_THROUGH_FW_CMD_ID;
+	smc_arg[1] = ((api_id & API_ID_MASK)  << 32) |
+		      FIELD_PREP(MODULE_ID_MASK, module_id) |
+		      feature_check_api_id;
+
+	ret = do_fw_call(ret_payload, 2, smc_arg[0], smc_arg[1]);
+	if (ret)
+		return -EOPNOTSUPP;
+
+	return ret_payload[1];
+}
+
+/**
+ * do_feature_check_basic - Perform feature check for an API ID with
+ *			    basic SMC format.
+ * @api_id: API ID to be checked.
+ * @ret_payload: Pointer to store the firmware's response payload.
+ *
+ * Determines the appropriate API (PM_FEATURE_CHECK or PM_API_FEATURES) based on
+ * the module ID in the given API ID. Frames the SMC call arguments in the basic
+ * format, executes the firmware call, and processes the result.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+static int do_feature_check_basic(const u32 api_id, u32 *ret_payload)
+{
+	u32 module_id;
+	u64 smc_arg[2];
+	u32 feature_check_api_id;
+	int ret;
+
+	module_id = FIELD_GET(MODULE_ID_MASK, api_id);
+
+	/*
+	 * Feature check of APIs belonging to PM, XSEM are handled by calling
+	 * PM_FEATURE_CHECK API. For other modules, call PM_API_FEATURES API.
+	 */
+	if (module_id == PM_MODULE_ID || module_id == XSEM_MODULE_ID)
+		feature_check_api_id = PM_FEATURE_CHECK;
+	else
+		feature_check_api_id = PM_API_FEATURES;
+
+	smc_arg[0] = PM_SIP_SVC | FIELD_PREP(MODULE_ID_MASK, module_id) | feature_check_api_id;
+	smc_arg[1] = (api_id & API_ID_MASK);
+
+	ret = do_fw_call(ret_payload, 2, smc_arg[0], smc_arg[1]);
+	if (ret)
+		ret = -EOPNOTSUPP;
+	else
+		ret = ret_payload[1];
+
+	return ret;
+}
+
+/**
+ * dispatch_feature_check - Dispatch feature check based on module ID.
+ * @api_id: API ID to be checked.
+ * @ret_payload: Pointer to store the firmware's response payload.
+ *
+ * Determines the appropriate feature check function to call based on the
+ * module ID extracted from the API ID. If the module ID corresponds to
+ * TF-A, it calls do_feature_check_for_tfa_apis(); otherwise, it calls
+ * do_feature_check_basic which uses basic SMCCC format
+ *
+ * Return: Returns status, either success or error+reason
+ */
+static int dispatch_feature_check(const u32 api_id, u32 *ret_payload)
+{
+	u32 module_id;
+
+	module_id = FIELD_GET(MODULE_ID_MASK, api_id);
+
+	if (module_id == TF_A_MODULE_ID)
+		return do_feature_check_for_tfa_apis(api_id, ret_payload);
+
+	if (active_platform_fw_data)
+		return active_platform_fw_data->do_feature_check(api_id, ret_payload);
+
+	return -ENODEV;
+}
+
+static int do_feature_check_call(const u32 api_id)
+{
+	int ret;
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	struct pm_api_feature_data *feature_data;
+
+	/* Check for existing entry in hash table for given api */
+	hash_for_each_possible(pm_api_features_map, feature_data, hentry,
+			       api_id) {
+		if (feature_data->pm_api_id == api_id)
+			return feature_data->feature_status;
+	}
+
+	/* Add new entry if not present */
+	feature_data = kmalloc(sizeof(*feature_data), GFP_ATOMIC);
+	if (!feature_data)
+		return -ENOMEM;
+
+	feature_data->pm_api_id = api_id;
+	ret = dispatch_feature_check(api_id, ret_payload);
+
+	feature_data->feature_status = ret;
+	hash_add(pm_api_features_map, &feature_data->hentry, api_id);
+
+	if (api_id == PM_IOCTL)
+		/* Store supported IOCTL IDs mask */
+		memcpy(ioctl_features, &ret_payload[2], FEATURE_PAYLOAD_SIZE * 4);
+	else if (api_id == PM_QUERY_DATA)
+		/* Store supported QUERY IDs mask */
+		memcpy(query_features, &ret_payload[2], FEATURE_PAYLOAD_SIZE * 4);
+
+	return ret;
+}
+
+/**
+ * zynqmp_pm_feature() - Check whether given feature is supported or not and
+ *			 store supported IOCTL/QUERY ID mask
+ * @api_id:		API ID to check
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_feature(const u32 api_id)
+{
+	int ret;
+
+	if (!feature_check_enabled)
+		return 0;
+
+	ret = do_feature_check_call(api_id);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_feature);
+
+/**
+ * zynqmp_pm_is_function_supported() - Check whether given IOCTL/QUERY function
+ *				       is supported or not
+ * @api_id:		PM_IOCTL or PM_QUERY_DATA
+ * @id:			IOCTL or QUERY function IDs
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_is_function_supported(const u32 api_id, const u32 id)
+{
+	int ret;
+	u32 *bit_mask;
+
+	/* Input arguments validation */
+	if (id >= 64 || (api_id != PM_IOCTL && api_id != PM_QUERY_DATA))
+		return -EINVAL;
+
+	/* Check feature check API version */
+	ret = do_feature_check_call(PM_FEATURE_CHECK);
+	if (ret < 0)
+		return ret;
+
+	/* Check if feature check version 2 is supported or not */
+	if ((ret & FIRMWARE_VERSION_MASK) == PM_API_VERSION_2) {
+		/*
+		 * Call feature check for IOCTL/QUERY API to get IOCTL ID or
+		 * QUERY ID feature status.
+		 */
+		ret = do_feature_check_call(api_id);
+		if (ret < 0)
+			return ret;
+
+		bit_mask = (api_id == PM_IOCTL) ? ioctl_features : query_features;
+
+		if ((bit_mask[(id / 32)] & BIT((id % 32))) == 0U)
+			return -EOPNOTSUPP;
+	} else {
+		return -ENODATA;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_is_function_supported);
+
+/**
+ * __zynqmp_pm_fw_call_extended() - Invoke the system-level platform management layer
+ *			caller function depending on the configuration
+ * @pm_api_id:		Requested PM-API call
+ * @ret_payload:	Returned value array
+ * @num_args:		Number of arguments to requested PM-API call
+ * @arg_list:		va_list initialized with va_start, containing arguments passed
+ *			to the firmware.
+ *
+ * Invoke platform management function for SMC or HVC call, depending on
+ * configuration.
+ * Following SMC Calling Convention (SMCCC) for SMC64:
+ * Pm Function Identifier,
+ * PM_SIP_SVC + PASS_THROUGH_FW_CMD_ID =
+ *	((SMC_TYPE_FAST << FUNCID_TYPE_SHIFT)
+ *	((SMC_64) << FUNCID_CC_SHIFT)
+ *	((SIP_START) << FUNCID_OEN_SHIFT)
+ *	(PASS_THROUGH_FW_CMD_ID))
+ *
+ * PM_SIP_SVC - Registered ZynqMP SIP Service Call.
+ * PASS_THROUGH_FW_CMD_ID - Fixed SiP SVC call ID for FW specific calls.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+static int __zynqmp_pm_fw_call_extended(u32 pm_api_id, u32 *ret_payload,
+					u32 num_args, va_list *arg_list)
+{
+	/*
+	 * Added SIP service call Function Identifier
+	 * Make sure to stay in x0 register
+	 */
+	u64 smc_arg[SMC_ARG_CNT_64];
+	int ret, i;
+	u32 args[SMC_ARG_CNT_32] = {0};
+	u32 module_id;
+
+	/*
+	 * According to the SMCCC: The total number of registers available for
+	 * arguments is 16.
+	 *
+	 * In the Extended SMC format, 3 registers are used for headers, leaving
+	 * up to 13 registers for arguments.
+	 */
+	if (num_args > SMC_ARG_CNT_32)
+		return -EINVAL;
+
+	/* Check if feature is supported or not */
+	ret = zynqmp_pm_feature(pm_api_id);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < num_args; i++)
+		args[i] = va_arg(*arg_list, u32);
+
+	module_id = FIELD_GET(PLM_MODULE_ID_MASK, pm_api_id);
+
+	if (module_id == 0)
+		module_id = XPM_MODULE_ID;
+
+	smc_arg[0] = PM_SIP_SVC | PASS_THROUGH_FW_CMD_ID;
+	smc_arg[1] = ((u64)args[0] << 32U) | FIELD_PREP(PLM_MODULE_ID_MASK, module_id) |
+		      (pm_api_id & API_ID_MASK);
+	for (i = 1; i < (SMC_ARG_CNT_64 - 1); i++)
+		smc_arg[i + 1] = ((u64)args[(i * 2)] << 32U) | args[(i * 2) - 1];
+
+	return do_fw_call(ret_payload, 8, smc_arg[0], smc_arg[1], smc_arg[2], smc_arg[3],
+			  smc_arg[4], smc_arg[5], smc_arg[6], smc_arg[7]);
+}
+
+/**
+ * zynqmp_pm_fw_call_extended - Invoke a PM function with variable arguments
+ * @pm_api_id: ID of the PM API to be called
+ * @ret_payload: Pointer to the buffer for storing the return payload
+ * @num_args: Number of arguments to pass to the PM API function
+ *
+ * This function serves as a wrapper around zynqmp_pm_invoke_fn_extended(),
+ * facilitating the invocation of platform management (PM) functions that
+ * require an extended SMC (Secure Monitor Call) format with variable
+ * arguments. Specifically, the PM_QUERY_DATA API necessitates this extended
+ * payload format, making it essential to retain zynqmp_pm_fw_call_extended
+ * with variable arguments.
+ *
+ * Return: 0 on success; a negative error code on failure.
+ */
+int zynqmp_pm_fw_call_extended(u32 pm_api_id, u32 *ret_payload, u32 num_args, ...)
+{
+	va_list arg_list;
+	int ret;
+
+	va_start(arg_list, num_args);
+	ret = __zynqmp_pm_fw_call_extended(pm_api_id, ret_payload,
+					   num_args, &arg_list);
+	va_end(arg_list);
+	return ret;
+}
+
+/**
+ * __zynqmp_pm_fw_call_basic() - Invoke the system-level platform management layer
+ *				 supporting basic SMC format.
+ *
+ * @pm_api_id:		Requested PM-API call
+ * @ret_payload:	Returned value array
+ * @num_args:		Number of arguments to requested PM-API call
+ * @arg_list:		va_list initialized with va_start, containing arguments passed
+ *			to the firmware.
+ *
+ * Invoke platform management function for SMC or HVC call, depending on
+ * configuration.
+ * Following SMC Calling Convention (SMCCC) for SMC64:
+ * Pm Function Identifier,
+ * PM_SIP_SVC + PM_API_ID =
+ *	((SMC_TYPE_FAST << FUNCID_TYPE_SHIFT)
+ *	((SMC_64) << FUNCID_CC_SHIFT)
+ *	((SIP_START) << FUNCID_OEN_SHIFT)
+ *	((PM_API_ID) & FUNCID_NUM_MASK))
+ *
+ * PM_SIP_SVC	- Registered ZynqMP SIP Service Call.
+ * PM_API_ID	- Platform Management API ID.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+static int __zynqmp_pm_fw_call_basic(u32 pm_api_id, u32 *ret_payload,
+				     u32 num_args, va_list *arg_list)
+{
+	/*
+	 * Added SIP service call Function Identifier
+	 * Make sure to stay in x0 register
+	 */
+	u64 smc_arg[8];
+	int ret, i;
+	u32 args[SMC_ARG_CNT_BASIC_32] = {0};
+
+	/*
+	 * According to the SMCCC: The total number of registers available for
+	 * arguments is 16.
+	 *
+	 * In the Basic SMC format, 2 registers are used for headers, leaving
+	 * up to 14 registers for arguments.
+	 */
+	if (num_args > SMC_ARG_CNT_BASIC_32)
+		return -EINVAL;
+
+	/* Check if feature is supported or not */
+	ret = zynqmp_pm_feature(pm_api_id);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < num_args; i++)
+		args[i] = va_arg(*arg_list, u32);
+
+	smc_arg[0] = PM_SIP_SVC | pm_api_id;
+	for (i = 0; i < 7; i++)
+		smc_arg[i + 1] = ((u64)args[(i * 2) + 1] << 32) | args[i * 2];
+
+	return do_fw_call(ret_payload, 8, smc_arg[0], smc_arg[1], smc_arg[2], smc_arg[3],
+			  smc_arg[4], smc_arg[5], smc_arg[6], smc_arg[7]);
+}
+
+/**
+ * zynqmp_pm_invoke_fn() - Invokes the platform-specific PM FW API.
+ * @pm_api_id:		Requested PM-API call
+ * @ret_payload:	Returned value array
+ * @num_args:		Number of arguments to requested PM-API call
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_invoke_fn(u32 pm_api_id, u32 *ret_payload, u32 num_args, ...)
+{
+	va_list arg_list;
+	u32 module_id;
+	int ret = -ENODEV;
+
+	/*
+	 * According to the SMCCC: The total number of registers available for
+	 * arguments is 16.
+	 *
+	 * In the Basic SMC format, 2 registers are used for headers, leaving
+	 * up to 14 registers for arguments.
+	 *
+	 * In the Extended SMC format, 3 registers are used for headers, leaving
+	 * up to 13 registers for arguments.
+	 *
+	 * To accommodate both formats, this comparison imposes a limit of 14
+	 * arguments. This ensures that callers do not exceed the maximum number
+	 * of registers available for arguments in either format. Each specific
+	 * handler (basic or extended) will further validate the exact number of
+	 * arguments based on its respective format requirements.
+	 */
+	if (num_args > 14)
+		return -EINVAL;
+
+	va_start(arg_list, num_args);
+
+	module_id = FIELD_GET(MODULE_ID_MASK, pm_api_id);
+
+	/*
+	 * Invoke the platform-specific PM FW API.
+	 * based on the platform type.
+	 *
+	 * The only exception is the TF-A module, which supports the basic
+	 * SMC format only
+	 */
+	if (module_id == TF_A_MODULE_ID)
+		ret = __zynqmp_pm_fw_call_basic(pm_api_id, ret_payload, num_args, &arg_list);
+	else
+		if (active_platform_fw_data)
+			ret = active_platform_fw_data->zynqmp_pm_fw_call(pm_api_id, ret_payload,
+									 num_args, &arg_list);
+
+	va_end(arg_list);
+	return ret;
+}
+
+/**
+ * zynqmp_pm_load_pdi_word_swap - Perform word swapping on a memory address.
+ * @address: Memory address to be word-swapped.
+ * @swapped_address: Pointer to store the resulting swapped address.
+ *
+ * This function checks if the active platform's firmware data specifies that
+ * word swapping is required when loading a Programmable Device Image (PDI).
+ * If so, it performs the necessary word swapping on the provided memory
+ * address. The swapped address is stored in the provided pointer.
+ *
+ * Return:
+ * - 0 on success.
+ * - -ENODEV if the active_platform_fw_data is NULL.
+ */
+int zynqmp_pm_load_pdi_word_swap(const u64 address, u64 *swapped_address)
+{
+	if (!active_platform_fw_data)
+		return -ENODEV;
+
+	if (active_platform_fw_data->load_pdi_word_swap)
+		*swapped_address = (address << 32) | (address >> 32);
+	else
+		*swapped_address = address;
+
+	return 0;
+}
+
+/**
+ * zynqmp_pm_get_sip_svc_version() - Get SiP service call version
+ * @version:	Returned version value
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_get_sip_svc_version(u32 *version)
+{
+	struct arm_smccc_res res;
+	u64 args[SMC_ARG_CNT_64] = {0};
+
+	if (!version)
+		return -EINVAL;
+
+	/* Check if SiP SVC version already verified */
+	if (sip_svc_version > 0) {
+		*version = sip_svc_version;
+		return 0;
+	}
+
+	args[0] = GET_SIP_SVC_VERSION;
+
+	arm_smccc_smc(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], &res);
+
+	*version = ((lower_32_bits(res.a0) << 16U) | lower_32_bits(res.a1));
+
+	return zynqmp_pm_ret_code(XST_PM_SUCCESS);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_sip_svc_version);
+
+/**
+ * get_set_conduit_method() - Choose SMC or HVC based communication
+ * @np:		Pointer to the device_node structure
+ *
+ * Use SMC or HVC-based functions to communicate with EL2/EL3.
+ *
+ * Return: Returns 0 on success or error code
+ */
+static int get_set_conduit_method(struct device_node *np)
+{
+	const char *method;
+
+	if (of_property_read_string(np, "method", &method)) {
+		pr_warn("%s missing \"method\" property\n", __func__);
+		return -ENXIO;
+	}
+
+	if (!strcmp("hvc", method)) {
+		do_fw_call = do_fw_call_hvc;
+	} else if (!strcmp("smc", method)) {
+		do_fw_call = do_fw_call_smc;
+	} else {
+		pr_warn("%s Invalid \"method\" property: %s\n",
+			__func__, method);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int zynqmp_firmware_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct zynqmp_devinfo *devinfo;
+	u32 pm_api_version;
+	u32 pm_tz_version;
+	u32 pm_family_code;
+	u32 pm_sub_family_code;
+	int ret;
+
+	ret = get_set_conduit_method(dev->of_node);
+	if (ret)
+		return ret;
+
+	active_platform_fw_data = (struct platform_fw_data *)device_get_match_data(dev);
+	if (!active_platform_fw_data)
+		return -EINVAL;
+
+	/* Get SiP SVC version number */
+	ret = zynqmp_pm_get_sip_svc_version(&sip_svc_version);
+	if (ret)
+		return ret;
+
+	ret = do_feature_check_call(PM_FEATURE_CHECK);
+	if (ret >= 0 && ((ret & FIRMWARE_VERSION_MASK) >= PM_API_VERSION_1))
+		feature_check_enabled = true;
+
+	devinfo = devm_kzalloc(dev, sizeof(*devinfo), GFP_KERNEL);
+	if (!devinfo)
+		return -ENOMEM;
+
+	devinfo->dev = dev;
+
+	platform_set_drvdata(pdev, devinfo);
+
+	/* Check PM API version number */
+	ret = zynqmp_pm_get_api_version(&pm_api_version);
+	if (ret)
+		return ret;
+
+	if (pm_api_version < ZYNQMP_PM_VERSION) {
+		panic("%s Platform Management API version error. Expected: v%d.%d - Found: v%d.%d\n",
+		      __func__,
+		      ZYNQMP_PM_VERSION_MAJOR, ZYNQMP_PM_VERSION_MINOR,
+		      pm_api_version >> 16, pm_api_version & 0xFFFF);
+	}
+
+	pr_info("%s Platform Management API v%d.%d\n", __func__,
+		pm_api_version >> 16, pm_api_version & 0xFFFF);
+
+	/* Get the Family code and sub family code of platform */
+	ret = zynqmp_pm_get_family_info(&pm_family_code, &pm_sub_family_code);
+	if (ret < 0)
+		return ret;
+
+	/* Check trustzone version number */
+	ret = zynqmp_pm_get_trustzone_version(&pm_tz_version);
+	if (ret)
+		panic("Legacy trustzone found without version support\n");
+
+	if (pm_tz_version < ZYNQMP_TZ_VERSION)
+		panic("%s Trustzone version error. Expected: v%d.%d - Found: v%d.%d\n",
+		      __func__,
+		      ZYNQMP_TZ_VERSION_MAJOR, ZYNQMP_TZ_VERSION_MINOR,
+		      pm_tz_version >> 16, pm_tz_version & 0xFFFF);
+
+	pr_info("%s Trustzone version v%d.%d\n", __func__,
+		pm_tz_version >> 16, pm_tz_version & 0xFFFF);
+
+	ret = mfd_add_devices(&pdev->dev, PLATFORM_DEVID_NONE, firmware_devs,
+			      ARRAY_SIZE(firmware_devs), NULL, 0, NULL);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add MFD devices %d\n", ret);
+		return ret;
+	}
+
+	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
+	if (ret < 0) {
+		dev_err(dev, "no usable DMA configuration");
+		return ret;
+	}
+
+	ret = zynqmp_firmware_pm_sysfs_entry(pdev);
+	if (ret) {
+		pr_err("%s() Failed to create sysfs file with error%d\n",
+		       __func__, ret);
+		return ret;
+	}
+
+	ret = zynqmp_firmware_pdi_sysfs_entry(pdev);
+	if (ret) {
+		pr_err("%s() Failed to create sysfs binary file with error%d\n",
+		       __func__, ret);
+		return ret;
+	}
+
+	zynqmp_pm_api_debugfs_init();
+
+	if (pm_family_code == VERSAL_FAMILY_CODE) {
+		em_dev = platform_device_register_data(&pdev->dev, "xlnx_event_manager",
+						       -1, NULL, 0);
+		if (IS_ERR(em_dev))
+			dev_err_probe(&pdev->dev, PTR_ERR(em_dev), "EM register fail with error\n");
+	}
+
+	return of_platform_populate(dev->of_node, NULL, NULL, dev);
+}
+
+static void zynqmp_firmware_remove(struct platform_device *pdev)
+{
+	struct pm_api_feature_data *feature_data;
+	struct hlist_node *tmp;
+	int i;
+
+	mfd_remove_devices(&pdev->dev);
+	zynqmp_pm_api_debugfs_exit();
+
+	hash_for_each_safe(pm_api_features_map, i, tmp, feature_data, hentry) {
+		hash_del(&feature_data->hentry);
+		kfree(feature_data);
+	}
+
+	platform_device_unregister(em_dev);
+}
+
+static const struct platform_fw_data platform_fw_data_versal2 = {
+	.do_feature_check = do_feature_check_extended,
+	.zynqmp_pm_fw_call = __zynqmp_pm_fw_call_extended,
+	.prep_pm_cmd_header = prep_pm_hdr_api_features,
+	/* TF-A does only transparent forwarding do word swapping here */
+	.load_pdi_word_swap = true,
+};
+
+static const struct platform_fw_data platform_fw_data_zynqmp_and_versal = {
+	.do_feature_check = do_feature_check_basic,
+	.zynqmp_pm_fw_call = __zynqmp_pm_fw_call_basic,
+	.prep_pm_cmd_header = prep_pm_hdr_feature_check,
+	/* the word swapping is done in TF-A */
+	.load_pdi_word_swap = false,
+};
+
+static const struct of_device_id zynqmp_firmware_of_match[] = {
+	{
+		.compatible = "xlnx,zynqmp-firmware",
+		.data = &platform_fw_data_zynqmp_and_versal,
+	},
+	{
+		.compatible = "xlnx,versal-firmware",
+		.data = &platform_fw_data_zynqmp_and_versal,
+	},
+	{
+		.compatible = "xlnx,versal2-firmware",
+		.data = &platform_fw_data_versal2,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, zynqmp_firmware_of_match);
+
+static struct platform_driver zynqmp_firmware_driver = {
+	.driver = {
+		.name = "zynqmp_firmware",
+		.of_match_table = zynqmp_firmware_of_match,
+	},
+	.probe = zynqmp_firmware_probe,
+	.remove_new = zynqmp_firmware_remove,
+};
+module_platform_driver(zynqmp_firmware_driver);
--- /dev/null
+++ linux-xlnx-2025.1/drivers/firmware/xilinx/zynqmp-crypto.c	2025-07-02 12:01:23.393081900 +0900
@@ -0,0 +1,432 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Firmware layer for XilSecure APIs.
+ *
+ * Copyright (C), 2025 Advanced Micro Devices, Inc.
+ */
+
+#include <linux/firmware/xlnx-zynqmp.h>
+
+int zynqmp_pm_secure_load(const u64 src_addr, u64 key_addr, u64 *dst)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret_value;
+
+	if (!dst)
+		return -EINVAL;
+
+	ret_value = zynqmp_pm_invoke_fn(PM_SECURE_IMAGE, ret_payload, 4,
+					lower_32_bits(src_addr),
+					upper_32_bits(src_addr),
+					lower_32_bits(key_addr),
+					upper_32_bits(key_addr));
+	*dst = ((u64)ret_payload[1] << 32) | ret_payload[2];
+
+	return ret_value;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_secure_load);
+
+/**
+ * zynqmp_pm_sha_hash - Access the SHA engine to calculate the hash
+ * @address:	Address of the data/ Address of output buffer where
+ *		hash should be stored.
+ * @size:	Size of the data.
+ * @flags:
+ *	BIT(0) - for initializing csudma driver and SHA3(Here address
+ *		 and size inputs can be NULL).
+ *	BIT(1) - to call Sha3_Update API which can be called multiple
+ *		 times when data is not contiguous.
+ *	BIT(2) - to get final hash of the whole updated data.
+ *		 Hash will be overwritten at provided address with
+ *		 48 bytes.
+ *
+ * Return:	Returns status, either success or error code.
+ */
+int zynqmp_pm_sha_hash(const u64 address, const u32 size, const u32 flags)
+{
+	u32 lower_addr = lower_32_bits(address);
+	u32 upper_addr = upper_32_bits(address);
+
+	return zynqmp_pm_invoke_fn(PM_SECURE_SHA, NULL, 4, upper_addr, lower_addr, size, flags);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_sha_hash);
+
+int versal_pm_puf_registration(const u64 in_addr)
+{
+	return zynqmp_pm_invoke_fn(XPUF_API_PUF_REGISTRATION, NULL,
+				   2, lower_32_bits(in_addr),
+				   upper_32_bits(in_addr));
+}
+EXPORT_SYMBOL_GPL(versal_pm_puf_registration);
+
+int versal_pm_puf_clear_id(void)
+{
+	return zynqmp_pm_invoke_fn(XPUF_API_PUF_CLEAR_PUF_ID, NULL,
+				   2, NULL, NULL);
+}
+EXPORT_SYMBOL_GPL(versal_pm_puf_clear_id);
+
+int versal_pm_puf_regeneration(const u64 in_addr)
+{
+	return zynqmp_pm_invoke_fn(XPUF_API_PUF_REGENERATION, NULL,
+				   2, lower_32_bits(in_addr),
+				   upper_32_bits(in_addr));
+}
+EXPORT_SYMBOL_GPL(versal_pm_puf_regeneration);
+
+/**
+ * zynqmp_pm_efuse_access - Provides access to efuse memory.
+ * @address:	Address of the efuse params structure
+ * @out:		Returned output value
+ *
+ * Return:	Returns status, either success or error code.
+ */
+int zynqmp_pm_efuse_access(const u64 address, u32 *out)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	if (!out)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_EFUSE_ACCESS, ret_payload, 2,
+				  upper_32_bits(address),
+				  lower_32_bits(address));
+	*out = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_efuse_access);
+
+/**
+ * versal_pm_efuse_read - Reads efuse.
+ * @address: Address of the payload
+ * @offset: Efuse offset
+ * @size: Size of data to be read
+ *
+ * This function provides support to read data from eFuse.
+ *
+ * Return: status, either success or error code.
+ */
+int versal_pm_efuse_read(const u64 address, u32 offset, u32 size)
+{
+	return zynqmp_pm_invoke_fn(PM_EFUSE_READ_VERSAL, NULL, 4, offset,
+				   lower_32_bits(address),
+				   upper_32_bits(address), size);
+}
+EXPORT_SYMBOL_GPL(versal_pm_efuse_read);
+
+/**
+ * versal_pm_efuse_write - Write efuse
+ * @address: Address of the payload
+ * @operationid: operationid which includes module and API id
+ * @envdis: Environment disable variable
+ *
+ * This function provides support to write data into eFuse.
+ *
+ * Return: status, either success or error+reason
+ */
+int versal_pm_efuse_write(const u64 address, const u32 operationid,
+			  const u8 envdis)
+{
+	return zynqmp_pm_invoke_fn(operationid, NULL, 3, lower_32_bits(address),
+				   upper_32_bits(address), envdis);
+}
+EXPORT_SYMBOL_GPL(versal_pm_efuse_write);
+
+/**
+ * versal_pm_sha_hash - Access the SHA engine to calculate the hash
+ * @src:	Address of the data
+ * @dst:	Address of the output buffer
+ * @size:	Size of the data.
+ *
+ * Return:	Returns status, either success or error code.
+ */
+int versal_pm_sha_hash(const u64 src, const u64 dst, const u32 size)
+{
+	return zynqmp_pm_invoke_fn(XSECURE_API_SHA3_UPDATE, NULL, 5,
+				   lower_32_bits(src), upper_32_bits(src),
+				   size,
+				   lower_32_bits(dst), upper_32_bits(dst));
+}
+EXPORT_SYMBOL_GPL(versal_pm_sha_hash);
+
+/**
+ * versal_pm_rsa_encrypt - Access RSA hardware to encrypt the data with RSA.
+ * @in_params:	Address of the input parameter
+ * @in_addr:	Address of input buffer
+ *
+ * Return:	Returns status, either success or error code.
+ */
+int versal_pm_rsa_encrypt(const u64 in_params, const u64 in_addr)
+{
+	return zynqmp_pm_invoke_fn(XSECURE_API_RSA_PUBLIC_ENCRYPT, NULL, 4,
+				   lower_32_bits(in_params),
+				   upper_32_bits(in_params),
+				   lower_32_bits(in_addr),
+				   upper_32_bits(in_addr));
+}
+EXPORT_SYMBOL_GPL(versal_pm_rsa_encrypt);
+
+/**
+ * versal_pm_rsa_decrypt - Access RSA hardware to decrypt the data with RSA.
+ * @in_params:	Address of the input parameter
+ * @in_addr:	Address of input buffer
+ *
+ * Return:	Returns status, either success or error code.
+ */
+int versal_pm_rsa_decrypt(const u64 in_params, const u64 in_addr)
+{
+	return zynqmp_pm_invoke_fn(XSECURE_API_RSA_PRIVATE_DECRYPT, NULL, 4,
+				   lower_32_bits(in_params),
+				   upper_32_bits(in_params),
+				   lower_32_bits(in_addr),
+				   upper_32_bits(in_addr));
+}
+EXPORT_SYMBOL_GPL(versal_pm_rsa_decrypt);
+
+/**
+ * versal_pm_ecdsa_validate_key - Access ECDSA hardware to validate key
+ * @key_addr:	Address of the key
+ * @curve_id:	Type of ECC curve
+ *
+ * Return:	Returns status, either success or error code.
+ */
+int versal_pm_ecdsa_validate_key(const u64 key_addr, const u32 curve_id)
+{
+	return zynqmp_pm_invoke_fn(XSECURE_API_ELLIPTIC_VALIDATE_KEY,
+				   NULL, 3, curve_id,
+				   lower_32_bits(key_addr),
+				   upper_32_bits(key_addr));
+}
+EXPORT_SYMBOL_GPL(versal_pm_ecdsa_validate_key);
+
+/**
+ * versal_pm_ecdsa_verify_sign - Access ECDSA hardware to verify sign
+ * @sign_param_addr:	Address of the sign params
+ *
+ * Return:	Returns status, either success or error code.
+ */
+int versal_pm_ecdsa_verify_sign(const u64 sign_param_addr)
+{
+	return zynqmp_pm_invoke_fn(XSECURE_API_ELLIPTIC_VERIFY_SIGN,
+				   NULL, 2, lower_32_bits(sign_param_addr),
+				   upper_32_bits(sign_param_addr));
+}
+EXPORT_SYMBOL_GPL(versal_pm_ecdsa_verify_sign);
+
+/**
+ * versal_pm_aes_key_write - Write AES key registers
+ * @keylen:	Size of the input key to be written
+ * @keysrc:	Key Source to be selected to which provided
+ *			key should be updated
+ * @keyaddr:	Address of a buffer which should contain the key
+ *			to be written
+ *
+ * This function provides support to write AES volatile user keys.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int versal_pm_aes_key_write(const u32 keylen,
+			    const u32 keysrc, const u64 keyaddr)
+{
+	return zynqmp_pm_invoke_fn(XSECURE_API_AES_WRITE_KEY, NULL, 4,
+				   keylen, keysrc,
+				   lower_32_bits(keyaddr),
+				   upper_32_bits(keyaddr));
+}
+EXPORT_SYMBOL_GPL(versal_pm_aes_key_write);
+
+/**
+ * versal_pm_aes_key_zero - Zeroise AES User key registers
+ * @keysrc:	Key Source to be selected to which provided
+ *		key should be updated
+ *
+ * This function provides support to zeroise AES volatile user keys.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int versal_pm_aes_key_zero(const u32 keysrc)
+{
+	return zynqmp_pm_invoke_fn(XSECURE_API_AES_KEY_ZERO, NULL, 1, keysrc);
+}
+EXPORT_SYMBOL_GPL(versal_pm_aes_key_zero);
+
+/**
+ * versal_pm_aes_op_init - Init AES operation
+ * @hw_req:	AES op init structure address
+ *
+ * This function provides support to init AES operation.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int versal_pm_aes_op_init(const u64 hw_req)
+{
+	return zynqmp_pm_invoke_fn(XSECURE_API_AES_OP_INIT, NULL, 2,
+				   lower_32_bits(hw_req),
+				   upper_32_bits(hw_req));
+}
+EXPORT_SYMBOL_GPL(versal_pm_aes_op_init);
+
+/**
+ * versal_pm_aes_update_aad - AES update aad
+ * @aad_addr:	AES aad address
+ * @aad_len:	AES aad data length
+ *
+ * This function provides support to update AAD data.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int versal_pm_aes_update_aad(const u64 aad_addr, const u32 aad_len)
+{
+	return zynqmp_pm_invoke_fn(XSECURE_API_AES_UPDATE_AAD, NULL, 3,
+				   lower_32_bits(aad_addr),
+				   upper_32_bits(aad_addr),
+				   aad_len);
+}
+EXPORT_SYMBOL_GPL(versal_pm_aes_update_aad);
+
+/**
+ * versal_pm_aes_enc_update - Access AES hardware to encrypt the data using
+ * AES-GCM core.
+ * @in_params:	Address of the AesParams structure
+ * @in_addr:	Address of input buffer
+ *
+ * Return:	Returns status, either success or error code.
+ */
+int versal_pm_aes_enc_update(const u64 in_params, const u64 in_addr)
+{
+	return zynqmp_pm_invoke_fn(XSECURE_API_AES_ENCRYPT_UPDATE, NULL, 4,
+				   lower_32_bits(in_params),
+				   upper_32_bits(in_params),
+				   lower_32_bits(in_addr),
+				   upper_32_bits(in_addr));
+}
+EXPORT_SYMBOL_GPL(versal_pm_aes_enc_update);
+
+/**
+ * versal_pm_aes_enc_final - Access AES hardware to store the GCM tag
+ * @gcm_addr:	Address of the gcm tag
+ *
+ * Return:	Returns status, either success or error code.
+ */
+int versal_pm_aes_enc_final(const u64 gcm_addr)
+{
+	return zynqmp_pm_invoke_fn(XSECURE_API_AES_ENCRYPT_FINAL, NULL, 2,
+				   lower_32_bits(gcm_addr),
+				   upper_32_bits(gcm_addr));
+}
+EXPORT_SYMBOL_GPL(versal_pm_aes_enc_final);
+
+/**
+ * versal_pm_aes_dec_update - Access AES hardware to decrypt the data using
+ * AES-GCM core.
+ * @in_params:	Address of the AesParams structure
+ * @in_addr:	Address of input buffer
+ *
+ * Return:	Returns status, either success or error code.
+ */
+int versal_pm_aes_dec_update(const u64 in_params, const u64 in_addr)
+{
+	return zynqmp_pm_invoke_fn(XSECURE_API_AES_DECRYPT_UPDATE, NULL, 4,
+				   lower_32_bits(in_params),
+				   upper_32_bits(in_params),
+				   lower_32_bits(in_addr),
+				   upper_32_bits(in_addr));
+}
+EXPORT_SYMBOL_GPL(versal_pm_aes_dec_update);
+
+/**
+ * versal_pm_aes_dec_final - Access AES hardware to get the GCM tag
+ * @gcm_addr:	Address of the gcm tag
+ *
+ * Return:	Returns status, either success or error code.
+ */
+int versal_pm_aes_dec_final(const u64 gcm_addr)
+{
+	return zynqmp_pm_invoke_fn(XSECURE_API_AES_DECRYPT_FINAL, NULL, 2,
+				   lower_32_bits(gcm_addr),
+				   upper_32_bits(gcm_addr));
+}
+EXPORT_SYMBOL_GPL(versal_pm_aes_dec_final);
+
+/**
+ * versal_pm_aes_init - Init AES block
+ *
+ * This function initialise AES block.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int versal_pm_aes_init(void)
+{
+	return zynqmp_pm_invoke_fn(XSECURE_API_AES_INIT, NULL, 0);
+}
+EXPORT_SYMBOL_GPL(versal_pm_aes_init);
+
+/**
+ * zynqmp_pm_aes_engine - Access AES hardware to encrypt/decrypt the data using
+ * AES-GCM core.
+ * @address:	Address of the AesParams structure.
+ * @out:	Returned output value
+ *
+ * Return:	Returns status, either success or error code.
+ */
+int zynqmp_pm_aes_engine(const u64 address, u32 *out)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	if (!out)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_SECURE_AES, ret_payload, 2, upper_32_bits(address),
+				  lower_32_bits(address));
+	*out = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_aes_engine);
+
+/**
+ * xlnx_get_crypto_dev_data() - Get crypto dev data of platform
+ * @feature_map:	List of available feature map of all platform
+ *
+ * Return: Returns crypto dev data, either address crypto dev or ERR PTR
+ */
+void *xlnx_get_crypto_dev_data(struct xlnx_feature *feature_map)
+{
+	struct xlnx_feature *feature;
+	u32 v;
+	u32 pm_family_code;
+	u32 pm_sub_family_code;
+	int ret;
+
+	ret = zynqmp_pm_get_api_version(&v);
+	if (ret)
+		return ERR_PTR(ret);
+
+	/* Get the Family code and sub family code of platform */
+	ret = zynqmp_pm_get_family_info(&pm_family_code, &pm_sub_family_code);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
+	feature = feature_map;
+	for (; feature->family; feature++) {
+		if (feature->family == pm_family_code &&
+		    (feature->subfamily == ALL_SUB_FAMILY_CODE ||
+		     pm_sub_family_code <= VERSAL_SUB_FAMILY_CODE_MAX)) {
+			if (feature->family == ZYNQMP_FAMILY_CODE ||
+			    feature->family == VERSAL_FAMILY_CODE) {
+				ret = zynqmp_pm_feature(feature->feature_id);
+				if (ret < 0)
+					return ERR_PTR(ret);
+			} else {
+				return ERR_PTR(-ENODEV);
+			}
+
+			return feature->data;
+		}
+	}
+	return ERR_PTR(-ENODEV);
+}
+EXPORT_SYMBOL_GPL(xlnx_get_crypto_dev_data);
--- linux-6.12.10/drivers/firmware/xilinx/zynqmp-debug.c	2025-07-02 11:58:39.767034000 +0900
+++ linux-xlnx-2025.1/drivers/firmware/xilinx/zynqmp-debug.c	2025-07-02 12:01:23.393081900 +0900
@@ -31,13 +31,52 @@
 
 #define PM_API(id)		 {id, #id, strlen(#id)}
 static struct pm_api_info pm_api_list[] = {
+	PM_API(PM_FORCE_POWERDOWN),
+	PM_API(PM_REQUEST_WAKEUP),
+	PM_API(PM_SYSTEM_SHUTDOWN),
+	PM_API(PM_REQUEST_NODE),
+	PM_API(PM_RELEASE_NODE),
+	PM_API(PM_SET_REQUIREMENT),
 	PM_API(PM_GET_API_VERSION),
+	PM_API(PM_GET_NODE_STATUS),
+	PM_API(PM_REGISTER_NOTIFIER),
+	PM_API(PM_RESET_ASSERT),
+	PM_API(PM_RESET_GET_STATUS),
+	PM_API(PM_GET_CHIPID),
+	PM_API(PM_PINCTRL_SET_FUNCTION),
+	PM_API(PM_PINCTRL_CONFIG_PARAM_GET),
+	PM_API(PM_PINCTRL_CONFIG_PARAM_SET),
+	PM_API(PM_IOCTL),
+	PM_API(PM_CLOCK_ENABLE),
+	PM_API(PM_CLOCK_DISABLE),
+	PM_API(PM_CLOCK_GETSTATE),
+	PM_API(PM_CLOCK_SETDIVIDER),
+	PM_API(PM_CLOCK_GETDIVIDER),
+	PM_API(PM_CLOCK_SETPARENT),
+	PM_API(PM_CLOCK_GETPARENT),
 	PM_API(PM_QUERY_DATA),
 };
 
 static struct dentry *firmware_debugfs_root;
 
 /**
+ * zynqmp_pm_ioctl - PM IOCTL for device control and configs
+ * @node:	Node ID of the device
+ * @ioctl:	ID of the requested IOCTL
+ * @arg1:	Argument 1 of requested IOCTL call
+ * @arg2:	Argument 2 of requested IOCTL call
+ * @arg3:	Argument 3 of requested IOCTL call
+ * @out:	Returned output value
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+static int zynqmp_pm_ioctl(const u32 node, const u32 ioctl, const u32 arg1,
+			   const u32 arg2, const u32 arg3, u32 *out)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, out, 5, node, ioctl, arg1, arg2, arg3);
+}
+
+/**
  * zynqmp_pm_argument_value() - Extract argument value from a PM-API request
  * @arg:	Entered PM-API argument in string format
  *
@@ -95,6 +134,139 @@
 		sprintf(debugfs_buf, "PM-API Version = %d.%d\n",
 			pm_api_version >> 16, pm_api_version & 0xffff);
 		break;
+	case PM_FORCE_POWERDOWN:
+		ret = zynqmp_pm_force_pwrdwn(pm_api_arg[0],
+					     pm_api_arg[1] ? pm_api_arg[1] :
+					     ZYNQMP_PM_REQUEST_ACK_NO);
+		break;
+	case PM_REQUEST_WAKEUP:
+		ret = zynqmp_pm_request_wake(pm_api_arg[0],
+					     pm_api_arg[1], pm_api_arg[2],
+					     pm_api_arg[3] ? pm_api_arg[3] :
+					     ZYNQMP_PM_REQUEST_ACK_NO);
+		break;
+	case PM_SYSTEM_SHUTDOWN:
+		ret = zynqmp_pm_system_shutdown(pm_api_arg[0], pm_api_arg[1]);
+		break;
+	case PM_REQUEST_NODE:
+		ret = zynqmp_pm_request_node(pm_api_arg[0],
+					     pm_api_arg[1] ? pm_api_arg[1] :
+					     ZYNQMP_PM_CAPABILITY_ACCESS,
+					     pm_api_arg[2] ? pm_api_arg[2] : 0,
+					     pm_api_arg[3] ? pm_api_arg[3] :
+					     ZYNQMP_PM_REQUEST_ACK_BLOCKING);
+		break;
+	case PM_RELEASE_NODE:
+		ret = zynqmp_pm_release_node(pm_api_arg[0]);
+		break;
+	case PM_SET_REQUIREMENT:
+		ret = zynqmp_pm_set_requirement(pm_api_arg[0],
+						pm_api_arg[1] ? pm_api_arg[1] :
+						ZYNQMP_PM_CAPABILITY_CONTEXT,
+						pm_api_arg[2] ?
+						pm_api_arg[2] : 0,
+						pm_api_arg[3] ? pm_api_arg[3] :
+						ZYNQMP_PM_REQUEST_ACK_BLOCKING);
+		break;
+	case PM_GET_NODE_STATUS:
+		ret = zynqmp_pm_get_node_status(pm_api_arg[0],
+						&pm_api_ret[0],
+						&pm_api_ret[1],
+						&pm_api_ret[2]);
+		if (!ret)
+			sprintf(debugfs_buf,
+				"GET_NODE_STATUS:\n\tNodeId: %llu\n\tStatus: %u\n\tRequirements: %u\n\tUsage: %u\n",
+				pm_api_arg[0], pm_api_ret[0],
+				pm_api_ret[1], pm_api_ret[2]);
+		break;
+	case PM_REGISTER_NOTIFIER:
+		ret = zynqmp_pm_register_notifier(pm_api_arg[0],
+						  pm_api_arg[1] ?
+						  pm_api_arg[1] : 0,
+						  pm_api_arg[2] ?
+						  pm_api_arg[2] : 0,
+						  pm_api_arg[3] ?
+						  pm_api_arg[3] : 0);
+		break;
+	case PM_RESET_ASSERT:
+		ret = zynqmp_pm_reset_assert(pm_api_arg[0], pm_api_arg[1]);
+		break;
+	case PM_RESET_GET_STATUS:
+		ret = zynqmp_pm_reset_get_status(pm_api_arg[0], &pm_api_ret[0]);
+		if (!ret)
+			sprintf(debugfs_buf, "Reset status: %u\n",
+				pm_api_ret[0]);
+		break;
+	case PM_GET_CHIPID:
+		ret = zynqmp_pm_get_chipid(&pm_api_ret[0], &pm_api_ret[1]);
+		if (!ret)
+			sprintf(debugfs_buf, "Idcode: %#x, Version:%#x\n",
+				pm_api_ret[0], pm_api_ret[1]);
+		break;
+	case PM_PINCTRL_SET_FUNCTION:
+		ret = zynqmp_pm_pinctrl_set_function(pm_api_arg[0],
+						     pm_api_arg[1]);
+		break;
+	case PM_PINCTRL_CONFIG_PARAM_GET:
+		ret = zynqmp_pm_pinctrl_get_config(pm_api_arg[0], pm_api_arg[1],
+						   &pm_api_ret[0]);
+		if (!ret)
+			sprintf(debugfs_buf,
+				"Pin: %llu, Param: %llu, Value: %u\n",
+				pm_api_arg[0], pm_api_arg[1],
+				pm_api_ret[0]);
+		break;
+	case PM_PINCTRL_CONFIG_PARAM_SET:
+		ret = zynqmp_pm_pinctrl_set_config(pm_api_arg[0],
+						   pm_api_arg[1],
+						   pm_api_arg[2]);
+		break;
+	case PM_IOCTL:
+		ret = zynqmp_pm_ioctl(pm_api_arg[0], pm_api_arg[1],
+				      pm_api_arg[2], pm_api_arg[3],
+				      pm_api_arg[4], &pm_api_ret[0]);
+		if (!ret && (pm_api_arg[1] == IOCTL_GET_RPU_OPER_MODE ||
+			     pm_api_arg[1] == IOCTL_GET_PLL_FRAC_MODE ||
+			     pm_api_arg[1] == IOCTL_GET_PLL_FRAC_DATA ||
+			     pm_api_arg[1] == IOCTL_READ_GGS ||
+			     pm_api_arg[1] == IOCTL_READ_PGGS ||
+			     pm_api_arg[1] == IOCTL_READ_REG))
+			sprintf(debugfs_buf, "IOCTL return value: %u\n",
+				pm_api_ret[1]);
+		if (!ret && pm_api_arg[1] == IOCTL_GET_QOS)
+			sprintf(debugfs_buf, "Default QoS: %u\nCurrent QoS: %u\n",
+				pm_api_ret[1], pm_api_ret[2]);
+		break;
+	case PM_CLOCK_ENABLE:
+		ret = zynqmp_pm_clock_enable(pm_api_arg[0]);
+		break;
+	case PM_CLOCK_DISABLE:
+		ret = zynqmp_pm_clock_disable(pm_api_arg[0]);
+		break;
+	case PM_CLOCK_GETSTATE:
+		ret = zynqmp_pm_clock_getstate(pm_api_arg[0], &pm_api_ret[0]);
+		if (!ret)
+			sprintf(debugfs_buf, "Clock state: %u\n",
+				pm_api_ret[0]);
+		break;
+	case PM_CLOCK_SETDIVIDER:
+		ret = zynqmp_pm_clock_setdivider(pm_api_arg[0], pm_api_arg[1]);
+		break;
+	case PM_CLOCK_GETDIVIDER:
+		ret = zynqmp_pm_clock_getdivider(pm_api_arg[0], &pm_api_ret[0]);
+		if (!ret)
+			sprintf(debugfs_buf, "Divider Value: %d\n",
+				pm_api_ret[0]);
+		break;
+	case PM_CLOCK_SETPARENT:
+		ret = zynqmp_pm_clock_setparent(pm_api_arg[0], pm_api_arg[1]);
+		break;
+	case PM_CLOCK_GETPARENT:
+		ret = zynqmp_pm_clock_getparent(pm_api_arg[0], &pm_api_ret[0]);
+		if (!ret)
+			sprintf(debugfs_buf,
+				"Clock parent Index: %u\n", pm_api_ret[0]);
+		break;
 	case PM_QUERY_DATA:
 		qdata.qid = pm_api_arg[0];
 		qdata.arg1 = pm_api_arg[1];
@@ -150,7 +322,7 @@
 	char *kern_buff, *tmp_buff;
 	char *pm_api_req;
 	u32 pm_id = 0;
-	u64 pm_api_arg[4] = {0, 0, 0, 0};
+	u64 pm_api_arg[5] = {0, 0, 0, 0, 0};
 	/* Return values from PM APIs calls */
 	u32 pm_api_ret[4] = {0, 0, 0, 0};
 
--- /dev/null
+++ linux-xlnx-2025.1/drivers/firmware/xilinx/zynqmp-fpga.c	2025-07-02 12:01:23.394097700 +0900
@@ -0,0 +1,169 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Firmware layer for XilFPGA APIs.
+ *
+ * Copyright (C), 2025 Advanced Micro Devices, Inc.
+ */
+
+#include <linux/export.h>
+#include <linux/firmware/xlnx-zynqmp.h>
+#include <linux/kernel.h>
+
+/**
+ * zynqmp_pm_fpga_load - Perform the fpga load
+ * @address:	Address to write to
+ * @size:	pl bitstream size
+ * @flags:	Bitstream type
+ *	-XILINX_ZYNQMP_PM_FPGA_FULL:  FPGA full reconfiguration
+ *	-XILINX_ZYNQMP_PM_FPGA_PARTIAL: FPGA partial reconfiguration
+ *
+ * This function provides access to pmufw. To transfer
+ * the required bitstream into PL.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_fpga_load(const u64 address, const u32 size, const u32 flags)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	ret = zynqmp_pm_invoke_fn(PM_FPGA_LOAD, ret_payload, 4, lower_32_bits(address),
+				  upper_32_bits(address), size, flags);
+	if (ret_payload[0])
+		return -ret_payload[0];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_fpga_load);
+
+/**
+ * zynqmp_pm_fpga_get_status - Read value from PCAP status register
+ * @value: Value to read
+ *
+ * This function provides access to the pmufw to get the PCAP
+ * status
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_fpga_get_status(u32 *value)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	if (!value)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_FPGA_GET_STATUS, ret_payload, 0);
+	*value = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_fpga_get_status);
+
+/**
+ * zynqmp_pm_fpga_get_config_status - Get the FPGA configuration status.
+ * @value: Buffer to store FPGA configuration status.
+ *
+ * This function provides access to the pmufw to get the FPGA configuration
+ * status
+ *
+ * Return: 0 on success, a negative value on error
+ */
+int zynqmp_pm_fpga_get_config_status(u32 *value)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	if (!value)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_FPGA_READ, ret_payload, 4,
+				  XILINX_ZYNQMP_PM_FPGA_CONFIG_STAT_OFFSET, 0, 0,
+				  XILINX_ZYNQMP_PM_FPGA_READ_CONFIG_REG);
+
+	*value = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_fpga_get_config_status);
+
+/**
+ * zynqmp_pm_fpga_get_version -Get xilfpga component version info
+ * @value: Value to read
+ *
+ * This function provides access to the pmufw to get the xilfpga
+ * component version info.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_fpga_get_version(u32 *value)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	if (!value)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_FPGA_GET_VERSION, ret_payload, 0);
+	*value = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_fpga_get_version);
+
+/**
+ * zynqmp_pm_fpga_get_feature_list - Get xilfpga component supported feature
+ * list.
+ * @value: Value to read
+ *
+ * This function provides access to the pmufw to get the xilfpga component
+ * supported feature list.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_fpga_get_feature_list(u32 *value)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	if (!value)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_FPGA_GET_FEATURE_LIST, ret_payload, 0);
+
+	*value = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_fpga_get_feature_list);
+
+/**
+ * zynqmp_pm_fpga_read - Perform the fpga configuration readback
+ * @reg_numframes: Configuration register offset (or) Number of frames to read
+ * @phys_address: Physical Address of the buffer
+ * @readback_type: Type of fpga readback operation
+ * @value: Value to read
+ *
+ * This function provides access to xilfpga library to perform
+ * fpga configuration readback.
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_fpga_read(const u32 reg_numframes, const u64 phys_address,
+			u32 readback_type, u32 *value)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	if (!value)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_FPGA_READ, ret_payload, 4, reg_numframes,
+				  lower_32_bits(phys_address),
+				  upper_32_bits(phys_address),
+				  readback_type);
+	*value = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_fpga_read);
--- /dev/null
+++ linux-xlnx-2025.1/drivers/firmware/xilinx/zynqmp-nvm.c	2025-07-02 12:01:23.394097700 +0900
@@ -0,0 +1,85 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Firmware layer for XilNVM APIs.
+ *
+ * Copyright (C), 2025 Advanced Micro Devices, Inc.
+ */
+
+#include <linux/export.h>
+#include <linux/firmware/xlnx-zynqmp.h>
+#include <linux/kernel.h>
+
+/**
+ * zynqmp_pm_bbram_write_aeskey - Write AES key in BBRAM
+ * @keylen:	Size of the input key to be written
+ * @keyaddr: Address of a buffer which should contain the key
+ *			to be written
+ *
+ * This function provides support to write AES keys into BBRAM.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_bbram_write_aeskey(u32 keylen, const u64 keyaddr)
+{
+	return zynqmp_pm_invoke_fn(PM_BBRAM_WRITE_KEY, NULL, 4, keylen,
+				   lower_32_bits(keyaddr),
+				   upper_32_bits(keyaddr));
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_bbram_write_aeskey);
+
+/**
+ * zynqmp_pm_bbram_write_usrdata - Write user data in BBRAM
+ * @data: User data to be written in BBRAM
+ *
+ * This function provides support to write user data into BBRAM.
+ * The size of the user data must be 4 bytes.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_bbram_write_usrdata(u32 data)
+{
+	return zynqmp_pm_invoke_fn(PM_BBRAM_WRITE_USERDATA, NULL, 1, data);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_bbram_write_usrdata);
+
+/**
+ * zynqmp_pm_bbram_read_usrdata - Read user data in BBRAM
+ * @outaddr: Address of a buffer to store the user data read from BBRAM
+ *
+ * This function provides support to read user data in BBRAM.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_bbram_read_usrdata(const u64 outaddr)
+{
+	return zynqmp_pm_invoke_fn(PM_BBRAM_READ_USERDATA, NULL, 1, outaddr);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_bbram_read_usrdata);
+
+/**
+ * zynqmp_pm_bbram_zeroize - Zeroizes AES key in BBRAM
+ *
+ * Description:
+ * This function provides support to zeroize AES key in BBRAM.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_bbram_zeroize(void)
+{
+	return zynqmp_pm_invoke_fn(PM_BBRAM_ZEROIZE, NULL, 0);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_bbram_zeroize);
+
+/**
+ * zynqmp_pm_bbram_lock_userdata - Locks user data for write
+ *
+ * Description:
+ * This function disables writing user data into BBRAM.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_bbram_lock_userdata(void)
+{
+	return zynqmp_pm_invoke_fn(PM_BBRAM_LOCK_USERDATA, NULL, 0);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_bbram_lock_userdata);
--- /dev/null
+++ linux-xlnx-2025.1/drivers/firmware/xilinx/zynqmp-pdi.c	2025-07-02 12:01:23.394097700 +0900
@@ -0,0 +1,261 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Firmware layer for XilPDI APIs.
+ *
+ * Copyright (C), 2025 Advanced Micro Devices, Inc.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/export.h>
+#include <linux/firmware.h>
+#include <linux/firmware/xlnx-zynqmp.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+/* firmware required uid buff size */
+#define UID_BUFF_SIZE	786
+#define UID_SET_LEN	4
+#define UID_LEN		4
+
+static char image_name[NAME_MAX];
+
+/**
+ * zynqmp_pm_get_uid_info - It is used to get image Info List
+ * @address:	Buffer address
+ * @size:	Number of bytes required to read from the firmware.
+ * @count:	Number of bytes read from the firmware.
+ *
+ * This function provides support to used to get image Info List
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_get_uid_info(const u64 address, const u32 size, u32 *count)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	if (!count)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_GET_UID_INFO_LIST, ret_payload, 3,
+				  upper_32_bits(address),
+				  lower_32_bits(address),
+				  size);
+
+	*count = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_uid_info);
+
+/**
+ * zynqmp_pm_get_meta_header - It is used to get image meta header Info
+ * @src:	PDI Image source buffer address.
+ * @dst:	Meta-header destination buffer address
+ * @size:	Size of the PDI image.
+ * @count:	Number of bytes read from the firmware.
+ *
+ * This function provides a support to get the image meta header Info
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_get_meta_header(const u64 src, const u64 dst,
+			      const u32 size, u32 *count)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	if (!count)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_GET_META_HEADER_INFO_LIST, ret_payload, 5,
+				  upper_32_bits(src), lower_32_bits(src),
+				  upper_32_bits(dst), lower_32_bits(dst),
+				  size);
+
+	*count = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_meta_header);
+
+/**
+ * zynqmp_pm_load_pdi - Load and process PDI
+ * @src:	Source device where PDI is located
+ * @address:	PDI src address
+ *
+ * This function provides support to load PDI from linux
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_load_pdi(const u32 src, const u64 address)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+	u64 swapped_address;
+
+	ret = zynqmp_pm_load_pdi_word_swap(address, &swapped_address);
+	if (ret)
+		return ret;
+
+	ret = zynqmp_pm_invoke_fn(PM_LOAD_PDI, ret_payload, 3, src,
+				  lower_32_bits(swapped_address),
+				  upper_32_bits(swapped_address));
+	if (ret_payload[0])
+		return ret_payload[0];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_load_pdi);
+
+/**
+ * zynqmp_pm_rsa - Access RSA hardware to encrypt/decrypt the data with RSA.
+ * @address:	Address of the data
+ * @size:	Size of the data.
+ * @flags:
+ *		BIT(0) - Encryption/Decryption
+ *			 0 - RSA decryption with private key
+ *			 1 - RSA encryption with public key.
+ *
+ * Return:	Returns status, either success or error code.
+ */
+int zynqmp_pm_rsa(const u64 address, const u32 size, const u32 flags)
+{
+	u32 lower_32_bits = lower_32_bits(address);
+	u32 upper_32_bits = upper_32_bits(address);
+
+	return zynqmp_pm_invoke_fn(PM_SECURE_RSA, NULL, 4, upper_32_bits,
+				   lower_32_bits, size, flags);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_rsa);
+
+static ssize_t firmware_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	unsigned int len;
+
+	len = strscpy(image_name, buf, NAME_MAX);
+	/* lose terminating \n */
+	if (image_name[len - 1] == '\n')
+		image_name[len - 1] = 0;
+
+	return count;
+}
+static DEVICE_ATTR_WO(firmware);
+
+static const struct attribute *firmware_attrs[] = {
+	&dev_attr_firmware.attr,
+	NULL,
+};
+
+static ssize_t firmware_uid_get_data(struct file *filp, struct kobject *kobj,
+				     struct bin_attribute *attr, char *buf,
+				     loff_t off, size_t count)
+{
+	struct device *kdev = kobj_to_dev(kobj);
+	dma_addr_t dma_addr = 0;
+	char *kbuf;
+	u32 size;
+	int ret;
+
+	kbuf = dma_alloc_coherent(kdev, UID_BUFF_SIZE, &dma_addr, GFP_KERNEL);
+	if (!kbuf)
+		return -ENOMEM;
+
+	/* Read from the firmware memory */
+	ret = zynqmp_pm_get_uid_info(dma_addr, UID_BUFF_SIZE, &size);
+	if (ret) {
+		dma_free_coherent(kdev, UID_BUFF_SIZE, kbuf, dma_addr);
+		return ret;
+	}
+
+	size = size * UID_SET_LEN * UID_LEN;
+	memcpy(buf, kbuf, size);
+	dma_free_coherent(kdev, UID_BUFF_SIZE, kbuf, dma_addr);
+
+	return size;
+}
+
+static const struct bin_attribute uid_attr = {
+	.attr.name = "uid-read",
+	.attr.mode = 00400,
+	.size = 1,
+	.read = firmware_uid_get_data,
+};
+
+static ssize_t firmware_meta_header_get_data(struct file *filp,
+					     struct kobject *kobj,
+					     struct bin_attribute *attr,
+					     char *buf, loff_t off,
+					     size_t count)
+{
+	struct device *kdev = kobj_to_dev(kobj);
+	const struct firmware *fw;
+	dma_addr_t dma_addr = 0;
+	char *kbuf;
+	u32 size;
+	int ret;
+
+	ret = request_firmware(&fw, image_name, kdev);
+	if (ret) {
+		dev_err(kdev, "Error requesting firmware %s\n", image_name);
+		return ret;
+	}
+
+	kbuf = dma_alloc_coherent(kdev, fw->size, &dma_addr, GFP_KERNEL);
+	if (!kbuf) {
+		ret = -ENOMEM;
+		goto free_firmware;
+	}
+
+	memcpy(kbuf, fw->data, fw->size);
+
+	/* Read from the firmware memory */
+	ret = zynqmp_pm_get_meta_header(dma_addr, dma_addr, fw->size, &size);
+	if (ret)
+		goto free_dma;
+
+	memcpy(buf, kbuf, size);
+	ret = size;
+
+free_dma:
+	dma_free_coherent(kdev, fw->size, kbuf, dma_addr);
+free_firmware:
+	release_firmware(fw);
+
+	return ret;
+}
+
+static const struct bin_attribute meta_header_attr = {
+	.attr.name = "meta-header-read",
+	.attr.mode = 00400,
+	.size = 1,
+	.read = firmware_meta_header_get_data,
+};
+
+int zynqmp_firmware_pdi_sysfs_entry(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = sysfs_create_files(&pdev->dev.kobj, firmware_attrs);
+	if (ret) {
+		pr_err("%s() Failed to create firmware attrs, err=%d\n",
+		       __func__, ret);
+		return ret;
+	}
+
+	ret = sysfs_create_bin_file(&pdev->dev.kobj, &uid_attr);
+	if (ret) {
+		pr_err("%s() Failed to create sysfs binary file for uid-read with error%d\n",
+		       __func__, ret);
+		return ret;
+	}
+
+	ret = sysfs_create_bin_file(&pdev->dev.kobj, &meta_header_attr);
+	if (ret)
+		pr_err("%s() Failed to create sysfs binary file for meta-header-read with error%d\n",
+		       __func__, ret);
+
+	return ret;
+}
--- /dev/null
+++ linux-xlnx-2025.1/drivers/firmware/xilinx/zynqmp-pm.c	2025-07-02 12:01:23.395076500 +0900
@@ -0,0 +1,1752 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx Zynq MPSoC Firmware layer
+ *
+ *  Copyright (C) 2014-2022 Xilinx, Inc.
+ *  Copyright (C) 2022 - 2025, Advanced Micro Devices, Inc.
+ *
+ *  Michal Simek <michal.simek@amd.com>
+ *  Davorin Mista <davorin.mista@aggios.com>
+ *  Jolly Shah <jollys@xilinx.com>
+ *  Rajan Vaja <rajanv@xilinx.com>
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/compiler.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/firmware.h>
+#include <linux/init.h>
+#include <linux/mfd/core.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/hashtable.h>
+
+#include <linux/firmware/xlnx-zynqmp.h>
+#include <linux/firmware/xlnx-event-manager.h>
+#include "zynqmp-debug.h"
+
+/* CRL registers and bitfields */
+#define CRL_APB_BASE			0xFF5E0000U
+/* BOOT_PIN_CTRL- Used to control the mode pins after boot */
+#define CRL_APB_BOOT_PIN_CTRL		(CRL_APB_BASE + (0x250U))
+/* BOOT_PIN_CTRL_MASK- out_val[11:8], out_en[3:0] */
+#define CRL_APB_BOOTPIN_CTRL_MASK	0xF0FU
+
+static unsigned long register_address;
+
+int zynqmp_pm_register_sgi(u32 sgi_num, u32 reset)
+{
+	int ret;
+
+	ret = zynqmp_pm_invoke_fn(TF_A_PM_REGISTER_SGI, NULL, 2, sgi_num, reset);
+	if (ret != -EOPNOTSUPP && !ret)
+		return ret;
+
+	/* try old implementation as fallback strategy if above fails */
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 3, IOCTL_REGISTER_SGI, sgi_num, reset);
+}
+
+/**
+ * zynqmp_pm_get_api_version() - Get version number of PMU PM firmware
+ * @version:	Returned version value
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_get_api_version(u32 *version)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	static u32 pm_api_version;
+	int ret;
+
+	if (!version)
+		return -EINVAL;
+
+	/* Check is PM API version already verified */
+	if (pm_api_version > 0) {
+		*version = pm_api_version;
+		return 0;
+	}
+	ret = zynqmp_pm_invoke_fn(PM_GET_API_VERSION, ret_payload, 0);
+	*version = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_api_version);
+
+/**
+ * zynqmp_pm_get_chipid - Get silicon ID registers
+ * @idcode:     IDCODE register
+ * @version:    version register
+ *
+ * Return:      Returns the status of the operation and the idcode and version
+ *              registers in @idcode and @version.
+ */
+int zynqmp_pm_get_chipid(u32 *idcode, u32 *version)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	if (!idcode || !version)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_GET_CHIPID, ret_payload, 0);
+	*idcode = ret_payload[1];
+	*version = ret_payload[2];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_chipid);
+
+/**
+ * zynqmp_pm_get_family_info() - Get family info of platform
+ * @family:	Returned family code value
+ * @subfamily:	Returned sub-family code value
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_get_family_info(u32 *family, u32 *subfamily)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	u32 idcode;
+	static u32 pm_family_code;
+	static u32 pm_sub_family_code;
+	int ret;
+
+	/* Check is family or sub-family code already received */
+	if (pm_family_code && pm_sub_family_code) {
+		*family = pm_family_code;
+		*subfamily = pm_sub_family_code;
+		return 0;
+	}
+
+	ret = zynqmp_pm_invoke_fn(PM_GET_CHIPID, ret_payload, 0);
+	if (ret < 0)
+		return ret;
+
+	idcode = ret_payload[1];
+	pm_family_code = FIELD_GET(FAMILY_CODE_MASK, idcode);
+	pm_sub_family_code = FIELD_GET(SUB_FAMILY_CODE_MASK, idcode);
+	*family = pm_family_code;
+	*subfamily = pm_sub_family_code;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_family_info);
+
+/**
+ * zynqmp_pm_get_trustzone_version() - Get secure trustzone firmware version
+ * @version:	Returned version value
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_get_trustzone_version(u32 *version)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	static u32 pm_tz_version;
+	int ret;
+
+	if (!version)
+		return -EINVAL;
+
+	/* Check is PM trustzone version already verified */
+	if (pm_tz_version > 0) {
+		*version = pm_tz_version;
+		return 0;
+	}
+	ret = zynqmp_pm_invoke_fn(PM_GET_TRUSTZONE_VERSION, ret_payload, 0);
+	*version = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_trustzone_version);
+
+/**
+ * zynqmp_pm_query_data() - Get query data from firmware
+ * @qdata:	Variable to the zynqmp_pm_query_data structure
+ * @out:	Returned output value
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_query_data(struct zynqmp_pm_query_data qdata, u32 *out)
+{
+	int ret, i = 0;
+	u32 sip_svc_version;
+	u32 ret_payload[PAYLOAD_ARG_CNT] = {0};
+
+	/* Get SiP SVC version number */
+	ret = zynqmp_pm_get_sip_svc_version(&sip_svc_version);
+	if (ret)
+		return ret;
+
+	if (sip_svc_version >= SIP_SVC_PASSTHROUGH_VERSION) {
+		ret = zynqmp_pm_fw_call_extended(PM_QUERY_DATA, ret_payload, 4,
+						 qdata.qid, qdata.arg1,
+						 qdata.arg2, qdata.arg3);
+		/* To support backward compatibility */
+		if (!ret && !ret_payload[0]) {
+			/*
+			 * TF-A passes return status on 0th index but
+			 * api to get clock name reads data from 0th
+			 * index so pass data at 0th index instead of
+			 * return status
+			 */
+			if (qdata.qid == PM_QID_CLOCK_GET_NAME ||
+			    qdata.qid == PM_QID_PINCTRL_GET_FUNCTION_NAME)
+				i = 1;
+
+			for (; i < PAYLOAD_ARG_CNT; i++, out++)
+				*out = ret_payload[i];
+
+			return ret;
+		}
+	}
+
+	ret = zynqmp_pm_invoke_fn(PM_QUERY_DATA, out, 4, qdata.qid,
+				  qdata.arg1, qdata.arg2, qdata.arg3);
+
+	/*
+	 * For clock name query, all bytes in SMC response are clock name
+	 * characters and return code is always success. For invalid clocks,
+	 * clock name bytes would be zeros.
+	 */
+	return qdata.qid == PM_QID_CLOCK_GET_NAME ? 0 : ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_query_data);
+
+/**
+ * zynqmp_pm_clock_enable() - Enable the clock for given id
+ * @clock_id:	ID of the clock to be enabled
+ *
+ * This function is used by master to enable the clock
+ * including peripherals and PLL clocks.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_clock_enable(u32 clock_id)
+{
+	return zynqmp_pm_invoke_fn(PM_CLOCK_ENABLE, NULL, 1, clock_id);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_clock_enable);
+
+/**
+ * zynqmp_pm_clock_disable() - Disable the clock for given id
+ * @clock_id:	ID of the clock to be disable
+ *
+ * This function is used by master to disable the clock
+ * including peripherals and PLL clocks.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_clock_disable(u32 clock_id)
+{
+	return zynqmp_pm_invoke_fn(PM_CLOCK_DISABLE, NULL, 1, clock_id);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_clock_disable);
+
+/**
+ * zynqmp_pm_clock_getstate() - Get the clock state for given id
+ * @clock_id:	ID of the clock to be queried
+ * @state:	1/0 (Enabled/Disabled)
+ *
+ * This function is used by master to get the state of clock
+ * including peripherals and PLL clocks.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_clock_getstate(u32 clock_id, u32 *state)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	ret = zynqmp_pm_invoke_fn(PM_CLOCK_GETSTATE, ret_payload, 1, clock_id);
+	*state = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_clock_getstate);
+
+/**
+ * zynqmp_pm_clock_setdivider() - Set the clock divider for given id
+ * @clock_id:	ID of the clock
+ * @divider:	divider value
+ *
+ * This function is used by master to set divider for any clock
+ * to achieve desired rate.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_clock_setdivider(u32 clock_id, u32 divider)
+{
+	return zynqmp_pm_invoke_fn(PM_CLOCK_SETDIVIDER, NULL, 2, clock_id, divider);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_clock_setdivider);
+
+/**
+ * zynqmp_pm_clock_getdivider() - Get the clock divider for given id
+ * @clock_id:	ID of the clock
+ * @divider:	divider value
+ *
+ * This function is used by master to get divider values
+ * for any clock.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_clock_getdivider(u32 clock_id, u32 *divider)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	ret = zynqmp_pm_invoke_fn(PM_CLOCK_GETDIVIDER, ret_payload, 1, clock_id);
+	*divider = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_clock_getdivider);
+
+/**
+ * zynqmp_pm_clock_setparent() - Set the clock parent for given id
+ * @clock_id:	ID of the clock
+ * @parent_id:	parent id
+ *
+ * This function is used by master to set parent for any clock.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_clock_setparent(u32 clock_id, u32 parent_id)
+{
+	return zynqmp_pm_invoke_fn(PM_CLOCK_SETPARENT, NULL, 2, clock_id, parent_id);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_clock_setparent);
+
+/**
+ * zynqmp_pm_clock_getparent() - Get the clock parent for given id
+ * @clock_id:	ID of the clock
+ * @parent_id:	parent id
+ *
+ * This function is used by master to get parent index
+ * for any clock.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_clock_getparent(u32 clock_id, u32 *parent_id)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	ret = zynqmp_pm_invoke_fn(PM_CLOCK_GETPARENT, ret_payload, 1, clock_id);
+	*parent_id = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_clock_getparent);
+
+/**
+ * zynqmp_pm_set_pll_frac_mode() - PM API for set PLL mode
+ *
+ * @clk_id:	PLL clock ID
+ * @mode:	PLL mode (PLL_MODE_FRAC/PLL_MODE_INT)
+ *
+ * This function sets PLL mode
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_set_pll_frac_mode(u32 clk_id, u32 mode)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, 0, IOCTL_SET_PLL_FRAC_MODE, clk_id, mode);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_set_pll_frac_mode);
+
+/**
+ * zynqmp_pm_get_pll_frac_mode() - PM API for get PLL mode
+ *
+ * @clk_id:	PLL clock ID
+ * @mode:	PLL mode
+ *
+ * This function return current PLL mode
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_get_pll_frac_mode(u32 clk_id, u32 *mode)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, mode, 3, 0, IOCTL_GET_PLL_FRAC_MODE, clk_id);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_pll_frac_mode);
+
+/**
+ * zynqmp_pm_set_pll_frac_data() - PM API for setting pll fraction data
+ *
+ * @clk_id:	PLL clock ID
+ * @data:	fraction data
+ *
+ * This function sets fraction data.
+ * It is valid for fraction mode only.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_set_pll_frac_data(u32 clk_id, u32 data)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, 0, IOCTL_SET_PLL_FRAC_DATA, clk_id, data);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_set_pll_frac_data);
+
+/**
+ * zynqmp_pm_get_pll_frac_data() - PM API for getting pll fraction data
+ *
+ * @clk_id:	PLL clock ID
+ * @data:	fraction data
+ *
+ * This function returns fraction data value.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_get_pll_frac_data(u32 clk_id, u32 *data)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, data, 3, 0, IOCTL_GET_PLL_FRAC_DATA, clk_id);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_pll_frac_data);
+
+/**
+ * zynqmp_pm_set_sd_tapdelay() -  Set tap delay for the SD device
+ *
+ * @node_id:	Node ID of the device
+ * @type:	Type of tap delay to set (input/output)
+ * @value:	Value to set fot the tap delay
+ *
+ * This function sets input/output tap delay for the SD device.
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_set_sd_tapdelay(u32 node_id, u32 type, u32 value)
+{
+	u32 reg = (type == PM_TAPDELAY_INPUT) ? SD_ITAPDLY : SD_OTAPDLYSEL;
+	u32 mask = (node_id == NODE_SD_0) ? GENMASK(15, 0) : GENMASK(31, 16);
+
+	if (value) {
+		return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, node_id, IOCTL_SET_SD_TAPDELAY, type,
+					   value);
+	}
+
+	/*
+	 * Work around completely misdesigned firmware API on Xilinx ZynqMP.
+	 * The IOCTL_SET_SD_TAPDELAY firmware call allows the caller to only
+	 * ever set IOU_SLCR SD_ITAPDLY Register SD0_ITAPDLYENA/SD1_ITAPDLYENA
+	 * bits, but there is no matching call to clear those bits. If those
+	 * bits are not cleared, SDMMC tuning may fail.
+	 *
+	 * Luckily, there are PM_MMIO_READ/PM_MMIO_WRITE calls which seem to
+	 * allow complete unrestricted access to all address space, including
+	 * IOU_SLCR SD_ITAPDLY Register and all the other registers, access
+	 * to which was supposed to be protected by the current firmware API.
+	 *
+	 * Use PM_MMIO_READ/PM_MMIO_WRITE to re-implement the missing counter
+	 * part of IOCTL_SET_SD_TAPDELAY which clears SDx_ITAPDLYENA bits.
+	 */
+	return zynqmp_pm_invoke_fn(PM_MMIO_WRITE, NULL, 2, reg, mask);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_set_sd_tapdelay);
+
+/**
+ * zynqmp_pm_sd_dll_reset() - Reset DLL logic
+ *
+ * @node_id:	Node ID of the device
+ * @type:	Reset type
+ *
+ * This function resets DLL logic for the SD device.
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_sd_dll_reset(u32 node_id, u32 type)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 3, node_id, IOCTL_SD_DLL_RESET, type);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_sd_dll_reset);
+
+/**
+ * zynqmp_pm_ospi_mux_select() - OSPI Mux selection
+ *
+ * @dev_id:	Device Id of the OSPI device.
+ * @select:	OSPI Mux select value.
+ *
+ * This function select the OSPI Mux.
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_ospi_mux_select(u32 dev_id, u32 select)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 3, dev_id, IOCTL_OSPI_MUX_SELECT, select);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_ospi_mux_select);
+
+/**
+ * zynqmp_pm_write_ggs() - PM API for writing global general storage (ggs)
+ * @index:	GGS register index
+ * @value:	Register value to be written
+ *
+ * This function writes value to GGS register.
+ *
+ * Return:      Returns status, either success or error+reason
+ */
+int zynqmp_pm_write_ggs(u32 index, u32 value)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, 0, IOCTL_WRITE_GGS, index, value);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_write_ggs);
+
+/**
+ * zynqmp_pm_read_ggs() - PM API for reading global general storage (ggs)
+ * @index:	GGS register index
+ * @value:	Register value to be written
+ *
+ * This function returns GGS register value.
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_read_ggs(u32 index, u32 *value)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, value, 3, 0, IOCTL_READ_GGS, index);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_read_ggs);
+
+/**
+ * zynqmp_pm_write_pggs() - PM API for writing persistent global general
+ *			     storage (pggs)
+ * @index:	PGGS register index
+ * @value:	Register value to be written
+ *
+ * This function writes value to PGGS register.
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_write_pggs(u32 index, u32 value)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, 0, IOCTL_WRITE_PGGS, index, value);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_write_pggs);
+
+/**
+ * zynqmp_pm_read_pggs() - PM API for reading persistent global general
+ *			     storage (pggs)
+ * @index:	PGGS register index
+ * @value:	Register value to be written
+ *
+ * This function returns PGGS register value.
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_read_pggs(u32 index, u32 *value)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, value, 3, 0, IOCTL_READ_PGGS, index);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_read_pggs);
+
+int zynqmp_pm_set_tapdelay_bypass(u32 index, u32 value)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, 0, IOCTL_SET_TAPDELAY_BYPASS, index, value);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_set_tapdelay_bypass);
+
+int zynqmp_pm_usb_set_state(u32 node, u32 state, u32 value)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, node, IOCTL_USB_SET_STATE,
+				   state, value);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_usb_set_state);
+
+int zynqmp_pm_get_last_reset_reason(u32 *reset_reason)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, reset_reason, 2, 0, IOCTL_GET_LAST_RESET_REASON);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_last_reset_reason);
+
+int zynqmp_pm_afi(u32 index, u32 value)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, 0, IOCTL_AFI, index, value);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_afi);
+
+/**
+ * zynqmp_pm_set_boot_health_status() - PM API for setting healthy boot status
+ * @value:	Status value to be written
+ *
+ * This function sets healthy bit value to indicate boot health status
+ * to firmware.
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_set_boot_health_status(u32 value)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 3, 0, IOCTL_SET_BOOT_HEALTH_STATUS, value);
+}
+
+/**
+ * zynqmp_pm_aie_operation - AI engine run time operations
+ * @node:	AI engine node id
+ * @start_col:	Starting column of AI partition
+ * @num_col:	Number of column in AI partition
+ * @operation:	ORed value of operations
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_aie_operation(u32 node, u16 start_col, u16 num_col, u32 operation)
+{
+	u32 partition;
+
+	partition = num_col;
+	partition = ((partition << 16U) | start_col);
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, node, IOCTL_AIE_OPS,
+				   partition, operation);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_aie_operation);
+
+/**
+ * versal2_pm_aie2ps_operation - AIE2PS run time operations
+ * @node:	AI engine node id
+ * @size:	Size of the DMA addr
+ * @addr_high:	higher 32 bits of DMA addr
+ * @addr_low:	lower 32 bits of DMA addr
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int versal2_pm_aie2ps_operation(u32 node, u32 size, u32 addr_high, u32 addr_low)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 5, node, IOCTL_AIE2PS_OPS,
+				   size, addr_high, addr_low);
+}
+EXPORT_SYMBOL_GPL(versal2_pm_aie2ps_operation);
+
+/**
+ * zynqmp_pm_reset_assert - Request setting of reset (1 - assert, 0 - release)
+ * @reset:		Reset to be configured
+ * @assert_flag:	Flag stating should reset be asserted (1) or
+ *			released (0)
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_reset_assert(const u32 reset,
+			   const enum zynqmp_pm_reset_action assert_flag)
+{
+	return zynqmp_pm_invoke_fn(PM_RESET_ASSERT, NULL, 2, reset, assert_flag);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_reset_assert);
+
+/**
+ * zynqmp_pm_reset_get_status - Get status of the reset
+ * @reset:      Reset whose status should be returned
+ * @status:     Returned status
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_reset_get_status(const u32 reset, u32 *status)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	if (!status)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_RESET_GET_STATUS, ret_payload, 1, reset);
+	*status = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_reset_get_status);
+
+/**
+ * zynqmp_pm_pinctrl_request - Request Pin from firmware
+ * @pin: Pin number to request
+ *
+ * This function requests pin from firmware.
+ *
+ * Return: Returns status, either success or error+reason.
+ */
+int zynqmp_pm_pinctrl_request(const u32 pin)
+{
+	return zynqmp_pm_invoke_fn(PM_PINCTRL_REQUEST, NULL, 1, pin);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_request);
+
+/**
+ * zynqmp_pm_pinctrl_release - Inform firmware that Pin control is released
+ * @pin: Pin number to release
+ *
+ * This function release pin from firmware.
+ *
+ * Return: Returns status, either success or error+reason.
+ */
+int zynqmp_pm_pinctrl_release(const u32 pin)
+{
+	return zynqmp_pm_invoke_fn(PM_PINCTRL_RELEASE, NULL, 1, pin);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_release);
+
+/**
+ * zynqmp_pm_pinctrl_set_function - Set requested function for the pin
+ * @pin: Pin number
+ * @id: Function ID to set
+ *
+ * This function sets requested function for the given pin.
+ *
+ * Return: Returns status, either success or error+reason.
+ */
+int zynqmp_pm_pinctrl_set_function(const u32 pin, const u32 id)
+{
+	return zynqmp_pm_invoke_fn(PM_PINCTRL_SET_FUNCTION, NULL, 2, pin, id);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_set_function);
+
+/**
+ * zynqmp_pm_pinctrl_get_config - Get configuration parameter for the pin
+ * @pin: Pin number
+ * @param: Parameter to get
+ * @value: Buffer to store parameter value
+ *
+ * This function gets requested configuration parameter for the given pin.
+ *
+ * Return: Returns status, either success or error+reason.
+ */
+int zynqmp_pm_pinctrl_get_config(const u32 pin, const u32 param,
+				 u32 *value)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	if (!value)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_PINCTRL_CONFIG_PARAM_GET, ret_payload, 2, pin, param);
+	*value = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_get_config);
+
+/**
+ * zynqmp_pm_pinctrl_set_config - Set configuration parameter for the pin
+ * @pin: Pin number
+ * @param: Parameter to set
+ * @value: Parameter value to set
+ *
+ * This function sets requested configuration parameter for the given pin.
+ *
+ * Return: Returns status, either success or error+reason.
+ */
+int zynqmp_pm_pinctrl_set_config(const u32 pin, const u32 param,
+				 u32 value)
+{
+	u32 pm_family_code;
+	u32 pm_sub_family_code;
+	int ret;
+
+	/* Get the Family code and sub family code of platform */
+	ret = zynqmp_pm_get_family_info(&pm_family_code, &pm_sub_family_code);
+	if (ret < 0)
+		return ret;
+
+	if (pm_family_code == ZYNQMP_FAMILY_CODE &&
+	    param == PM_PINCTRL_CONFIG_TRI_STATE) {
+		ret = zynqmp_pm_feature(PM_PINCTRL_CONFIG_PARAM_SET);
+		if (ret < PM_PINCTRL_PARAM_SET_VERSION) {
+			pr_warn("The requested pinctrl feature is not supported in the current firmware.\n"
+				"Expected firmware version is 2023.1 and above for this feature to work.\r\n");
+			return -EOPNOTSUPP;
+		}
+	}
+
+	return zynqmp_pm_invoke_fn(PM_PINCTRL_CONFIG_PARAM_SET, NULL, 3, pin, param, value);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_set_config);
+
+/**
+ * zynqmp_pm_bootmode_read() - PM Config API for read bootpin status
+ * @ps_mode: Returned output value of ps_mode
+ *
+ * This API function is to be used for notify the power management controller
+ * to read bootpin status.
+ *
+ * Return: status, either success or error+reason
+ */
+unsigned int zynqmp_pm_bootmode_read(u32 *ps_mode)
+{
+	unsigned int ret;
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+
+	ret = zynqmp_pm_invoke_fn(PM_MMIO_READ, ret_payload, 1, CRL_APB_BOOT_PIN_CTRL);
+
+	*ps_mode = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_bootmode_read);
+
+/**
+ * zynqmp_pm_bootmode_write() - PM Config API for Configure bootpin
+ * @ps_mode: Value to be written to the bootpin ctrl register
+ *
+ * This API function is to be used for notify the power management controller
+ * to configure bootpin.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_bootmode_write(u32 ps_mode)
+{
+	return zynqmp_pm_invoke_fn(PM_MMIO_WRITE, NULL, 3, CRL_APB_BOOT_PIN_CTRL,
+				   CRL_APB_BOOTPIN_CTRL_MASK, ps_mode);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_bootmode_write);
+
+/**
+ * zynqmp_pm_init_finalize() - PM call to inform firmware that the caller
+ *			       master has initialized its own power management
+ *
+ * Return: Returns status, either success or error+reason
+ *
+ * This API function is to be used for notify the power management controller
+ * about the completed power management initialization.
+ */
+int zynqmp_pm_init_finalize(void)
+{
+	return zynqmp_pm_invoke_fn(PM_PM_INIT_FINALIZE, NULL, 0);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_init_finalize);
+
+/**
+ * zynqmp_pm_config_reg_access - PM Config API for Config register access
+ * @register_access_id:	ID of the requested REGISTER_ACCESS
+ * @address:		Address of the register to be accessed
+ * @mask:		Mask to be written to the register
+ * @value:		Value to be written to the register
+ * @out:		Returned output value
+ *
+ * This function calls REGISTER_ACCESS to configure CSU/PMU registers.
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_config_reg_access(u32 register_access_id, u32 address,
+				u32 mask, u32 value, u32 *out)
+{
+	return zynqmp_pm_invoke_fn(PM_REGISTER_ACCESS, out, 4,
+				   register_access_id,
+				   address, mask, value);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_config_reg_access);
+
+/**
+ * zynqmp_pm_set_suspend_mode()	- Set system suspend mode
+ * @mode:	Mode to set for system suspend
+ *
+ * This API function is used to set mode of system suspend.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_set_suspend_mode(u32 mode)
+{
+	return zynqmp_pm_invoke_fn(PM_SET_SUSPEND_MODE, NULL, 1, mode);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_set_suspend_mode);
+
+/**
+ * zynqmp_pm_request_node() - Request a node with specific capabilities
+ * @node:		Node ID of the slave
+ * @capabilities:	Requested capabilities of the slave
+ * @qos:		Quality of service (not supported)
+ * @ack:		Flag to specify whether acknowledge is requested
+ *
+ * This function is used by master to request particular node from firmware.
+ * Every master must request node before using it.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_request_node(const u32 node, const u32 capabilities,
+			   const u32 qos, const enum zynqmp_pm_request_ack ack)
+{
+	return zynqmp_pm_invoke_fn(PM_REQUEST_NODE, NULL, 4, node, capabilities, qos, ack);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_request_node);
+
+/**
+ * zynqmp_pm_release_node() - Release a node
+ * @node:	Node ID of the slave
+ *
+ * This function is used by master to inform firmware that master
+ * has released node. Once released, master must not use that node
+ * without re-request.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_release_node(const u32 node)
+{
+	return zynqmp_pm_invoke_fn(PM_RELEASE_NODE, NULL, 1, node);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_release_node);
+
+/**
+ * zynqmp_pm_get_rpu_mode() - Get RPU mode
+ * @node_id:	Node ID of the device
+ * @rpu_mode:	return by reference value
+ *		either split or lockstep
+ *
+ * Return:	return 0 on success or error+reason.
+ *		if success, then  rpu_mode will be set
+ *		to current rpu mode.
+ */
+int zynqmp_pm_get_rpu_mode(u32 node_id, enum rpu_oper_mode *rpu_mode)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	ret = zynqmp_pm_invoke_fn(PM_IOCTL, ret_payload, 2, node_id, IOCTL_GET_RPU_OPER_MODE);
+
+	/* only set rpu_mode if no error */
+	if (ret == XST_PM_SUCCESS)
+		*rpu_mode = ret_payload[0];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_rpu_mode);
+
+/**
+ * zynqmp_pm_set_rpu_mode() - Set RPU mode
+ * @node_id:	Node ID of the device
+ * @rpu_mode:	Argument 1 to requested IOCTL call. either split or lockstep
+ *
+ *		This function is used to set RPU mode to split or
+ *		lockstep
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_set_rpu_mode(u32 node_id, enum rpu_oper_mode rpu_mode)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 3, node_id, IOCTL_SET_RPU_OPER_MODE,
+				   (u32)rpu_mode);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_set_rpu_mode);
+
+/**
+ * zynqmp_pm_set_tcm_config - configure TCM
+ * @node_id:	Firmware specific TCM subsystem ID
+ * @tcm_mode:	Argument 1 to requested IOCTL call
+ *              either PM_RPU_TCM_COMB or PM_RPU_TCM_SPLIT
+ *
+ * This function is used to set RPU mode to split or combined
+ *
+ * Return: status: 0 for success, else failure
+ */
+int zynqmp_pm_set_tcm_config(u32 node_id, enum rpu_tcm_comb tcm_mode)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 3, node_id, IOCTL_TCM_COMB_CONFIG,
+				   (u32)tcm_mode);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_set_tcm_config);
+
+/**
+ * zynqmp_pm_get_node_status - PM call to request a node's current power state
+ * @node:		ID of the component or sub-system in question
+ * @status:		Current operating state of the requested node
+ * @requirements:	Current requirements asserted on the node,
+ *			used for slave nodes only.
+ * @usage:		Usage information, used for slave nodes only:
+ *			PM_USAGE_NO_MASTER	- No master is currently using
+ *						  the node
+ *			PM_USAGE_CURRENT_MASTER	- Only requesting master is
+ *						  currently using the node
+ *			PM_USAGE_OTHER_MASTER	- Only other masters are
+ *						  currently using the node
+ *			PM_USAGE_BOTH_MASTERS	- Both the current and at least
+ *						  one other master is currently
+ *						  using the node
+ *
+ * Return:		Returns status, either success or error+reason
+ */
+int zynqmp_pm_get_node_status(const u32 node, u32 *const status,
+			      u32 *const requirements, u32 *const usage)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	if (!status || !requirements || !usage)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_GET_NODE_STATUS, ret_payload, 1, node);
+	if (ret_payload[0] == XST_PM_SUCCESS) {
+		*status = ret_payload[1];
+		*requirements = ret_payload[2];
+		*usage = ret_payload[3];
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_node_status);
+
+/**
+ * zynqmp_pm_force_pwrdwn - PM call to request for another PU or subsystem to
+ *             be powered down forcefully
+ * @node:  Node ID of the targeted PU or subsystem
+ * @ack:   Flag to specify whether acknowledge is requested
+ *
+ * Return: status, either success or error+reason
+ */
+int zynqmp_pm_force_pwrdwn(const u32 node,
+			   const enum zynqmp_pm_request_ack ack)
+{
+	return zynqmp_pm_invoke_fn(PM_FORCE_POWERDOWN, NULL, 2, node, ack);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_force_pwrdwn);
+
+/**
+ * zynqmp_pm_request_wake - PM call to wake up selected master or subsystem
+ * @node:  Node ID of the master or subsystem
+ * @set_addr:  Specifies whether the address argument is relevant
+ * @address:   Address from which to resume when woken up
+ * @ack:   Flag to specify whether acknowledge requested
+ *
+ * Return: status, either success or error+reason
+ */
+int zynqmp_pm_request_wake(const u32 node,
+			   const bool set_addr,
+			   const u64 address,
+			   const enum zynqmp_pm_request_ack ack)
+{
+	/* set_addr flag is encoded into 1st bit of address */
+	return zynqmp_pm_invoke_fn(PM_REQUEST_WAKEUP, NULL, 4, node, address | set_addr,
+				   address >> 32, ack);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_request_wake);
+
+/**
+ * zynqmp_pm_set_requirement() - PM call to set requirement for PM slaves
+ * @node:		Node ID of the slave
+ * @capabilities:	Requested capabilities of the slave
+ * @qos:		Quality of service (not supported)
+ * @ack:		Flag to specify whether acknowledge is requested
+ *
+ * This API function is to be used for slaves a PU already has requested
+ * to change its capabilities.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+int zynqmp_pm_set_requirement(const u32 node, const u32 capabilities,
+			      const u32 qos,
+			      const enum zynqmp_pm_request_ack ack)
+{
+	return zynqmp_pm_invoke_fn(PM_SET_REQUIREMENT, NULL, 4, node, capabilities, qos, ack);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_set_requirement);
+
+/**
+ * zynqmp_pm_register_notifier() - PM API for register a subsystem
+ *                                to be notified about specific
+ *                                event/error.
+ * @node:	Node ID to which the event is related.
+ * @event:	Event Mask of Error events for which wants to get notified.
+ * @wake:	Wake subsystem upon capturing the event if value 1
+ * @enable:	Enable the registration for value 1, disable for value 0
+ *
+ * This function is used to register/un-register for particular node-event
+ * combination in firmware.
+ *
+ * Return: Returns status, either success or error+reason
+ */
+
+int zynqmp_pm_register_notifier(const u32 node, const u32 event,
+				const u32 wake, const u32 enable)
+{
+	return zynqmp_pm_invoke_fn(PM_REGISTER_NOTIFIER, NULL, 4, node, event, wake, enable);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_register_notifier);
+
+/**
+ * zynqmp_pm_system_shutdown - PM call to request a system shutdown or restart
+ * @type:	Shutdown or restart? 0 for shutdown, 1 for restart
+ * @subtype:	Specifies which system should be restarted or shut down
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_system_shutdown(const u32 type, const u32 subtype)
+{
+	return zynqmp_pm_invoke_fn(PM_SYSTEM_SHUTDOWN, NULL, 2, type, subtype);
+}
+
+/**
+ * zynqmp_pm_set_feature_config - PM call to request IOCTL for feature config
+ * @id:         The config ID of the feature to be configured
+ * @value:      The config value of the feature to be configured
+ *
+ * Return:      Returns 0 on success or error value on failure.
+ */
+int zynqmp_pm_set_feature_config(enum pm_feature_config_id id, u32 value)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, 0, IOCTL_SET_FEATURE_CONFIG, id, value);
+}
+
+/**
+ * zynqmp_pm_get_feature_config - PM call to get value of configured feature
+ * @id:         The config id of the feature to be queried
+ * @payload:    Returned value array
+ *
+ * Return:      Returns 0 on success or error value on failure.
+ */
+int zynqmp_pm_get_feature_config(enum pm_feature_config_id id,
+				 u32 *payload)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, payload, 3, 0, IOCTL_GET_FEATURE_CONFIG, id);
+}
+
+/**
+ * zynqmp_pm_sec_read_reg - PM call to securely read from given offset
+ *		of the node
+ * @node_id:	Node Id of the device
+ * @offset:	Offset to be used (20-bit)
+ * @ret_value:	Output data read from the given offset after
+ *		firmware access policy is successfully enforced
+ *
+ * Return:	Returns 0 on success or error value on failure
+ */
+int zynqmp_pm_sec_read_reg(u32 node_id, u32 offset, u32 *ret_value)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	u32 count = 1;
+	int ret;
+
+	if (!ret_value)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_IOCTL, ret_payload, 4, node_id, IOCTL_READ_REG,
+				  offset, count);
+
+	*ret_value = ret_payload[1];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_sec_read_reg);
+
+/**
+ * zynqmp_pm_sec_mask_write_reg - PM call to securely write to given offset
+ *		of the node
+ * @node_id:	Node Id of the device
+ * @offset:	Offset to be used (20-bit)
+ * @mask:	Mask to be used
+ * @value:	Value to be written
+ *
+ * Return:	Returns 0 on success or error value on failure
+ */
+int zynqmp_pm_sec_mask_write_reg(const u32 node_id, const u32 offset, u32 mask,
+				 u32 value)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 5, node_id, IOCTL_MASK_WRITE_REG,
+				   offset, mask, value);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_sec_mask_write_reg);
+
+/**
+ * zynqmp_pm_get_qos - PM call to query default and current QoS of the node
+ * @node:	Node Id of the device
+ * @def_qos:	Default QoS value
+ * @qos:	Current QoS value
+ *
+ * Return:	Returns 0 on success and the default and current QoS registers in
+ *		@def_qos and @qos or error value on failure
+ */
+int zynqmp_pm_get_qos(u32 node, u32 *const def_qos, u32 *const qos)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	if (!def_qos || !qos)
+		return -EINVAL;
+
+	ret = zynqmp_pm_invoke_fn(PM_IOCTL, ret_payload, 2, node, IOCTL_GET_QOS);
+
+	*def_qos = ret_payload[1];
+	*qos = ret_payload[2];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_qos);
+
+/**
+ * zynqmp_pm_set_sd_config - PM call to set value of SD config registers
+ * @node:	SD node ID
+ * @config:	The config type of SD registers
+ * @value:	Value to be set
+ *
+ * Return:	Returns 0 on success or error value on failure.
+ */
+int zynqmp_pm_set_sd_config(u32 node, enum pm_sd_config_type config, u32 value)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, node, IOCTL_SET_SD_CONFIG, config, value);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_set_sd_config);
+
+/**
+ * zynqmp_pm_set_gem_config - PM call to set value of GEM config registers
+ * @node:	GEM node ID
+ * @config:	The config type of GEM registers
+ * @value:	Value to be set
+ *
+ * Return:	Returns 0 on success or error value on failure.
+ */
+int zynqmp_pm_set_gem_config(u32 node, enum pm_gem_config_type config,
+			     u32 value)
+{
+	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, node, IOCTL_SET_GEM_CONFIG, config, value);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_set_gem_config);
+
+/**
+ * struct zynqmp_pm_shutdown_scope - Struct for shutdown scope
+ * @subtype:	Shutdown subtype
+ * @name:	Matching string for scope argument
+ *
+ * This struct encapsulates mapping between shutdown scope ID and string.
+ */
+struct zynqmp_pm_shutdown_scope {
+	const enum zynqmp_pm_shutdown_subtype subtype;
+	const char *name;
+};
+
+static struct zynqmp_pm_shutdown_scope shutdown_scopes[] = {
+	[ZYNQMP_PM_SHUTDOWN_SUBTYPE_SUBSYSTEM] = {
+		.subtype = ZYNQMP_PM_SHUTDOWN_SUBTYPE_SUBSYSTEM,
+		.name = "subsystem",
+	},
+	[ZYNQMP_PM_SHUTDOWN_SUBTYPE_PS_ONLY] = {
+		.subtype = ZYNQMP_PM_SHUTDOWN_SUBTYPE_PS_ONLY,
+		.name = "ps_only",
+	},
+	[ZYNQMP_PM_SHUTDOWN_SUBTYPE_SYSTEM] = {
+		.subtype = ZYNQMP_PM_SHUTDOWN_SUBTYPE_SYSTEM,
+		.name = "system",
+	},
+};
+
+static struct zynqmp_pm_shutdown_scope *selected_scope =
+		&shutdown_scopes[ZYNQMP_PM_SHUTDOWN_SUBTYPE_SYSTEM];
+
+/**
+ * zynqmp_pm_is_shutdown_scope_valid - Check if shutdown scope string is valid
+ * @scope_string:	Shutdown scope string
+ *
+ * Return:		Return pointer to matching shutdown scope struct from
+ *			array of available options in system if string is valid,
+ *			otherwise returns NULL.
+ */
+static struct zynqmp_pm_shutdown_scope*
+		zynqmp_pm_is_shutdown_scope_valid(const char *scope_string)
+{
+	int count;
+
+	for (count = 0; count < ARRAY_SIZE(shutdown_scopes); count++)
+		if (sysfs_streq(scope_string, shutdown_scopes[count].name))
+			return &shutdown_scopes[count];
+
+	return NULL;
+}
+
+static ssize_t shutdown_scope_show(struct device *device,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(shutdown_scopes); i++) {
+		if (&shutdown_scopes[i] == selected_scope) {
+			strcat(buf, "[");
+			strcat(buf, shutdown_scopes[i].name);
+			strcat(buf, "]");
+		} else {
+			strcat(buf, shutdown_scopes[i].name);
+		}
+		strcat(buf, " ");
+	}
+	strcat(buf, "\n");
+
+	return strlen(buf);
+}
+
+static ssize_t shutdown_scope_store(struct device *device,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	int ret;
+	struct zynqmp_pm_shutdown_scope *scope;
+
+	scope = zynqmp_pm_is_shutdown_scope_valid(buf);
+	if (!scope)
+		return -EINVAL;
+
+	ret = zynqmp_pm_system_shutdown(ZYNQMP_PM_SHUTDOWN_TYPE_SETSCOPE_ONLY,
+					scope->subtype);
+	if (ret) {
+		pr_err("unable to set shutdown scope %s\n", buf);
+		return ret;
+	}
+
+	selected_scope = scope;
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(shutdown_scope);
+
+static ssize_t health_status_store(struct device *device,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	int ret;
+	unsigned int value;
+
+	ret = kstrtouint(buf, 10, &value);
+	if (ret)
+		return ret;
+
+	ret = zynqmp_pm_set_boot_health_status(value);
+	if (ret) {
+		dev_err(device, "unable to set healthy bit value to %u\n",
+			value);
+		return ret;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR_WO(health_status);
+
+static ssize_t ggs_show(struct device *device,
+			struct device_attribute *attr,
+			char *buf,
+			u32 reg)
+{
+	int ret;
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+
+	ret = zynqmp_pm_read_ggs(reg, ret_payload);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "0x%x\n", ret_payload[1]);
+}
+
+static ssize_t ggs_store(struct device *device,
+			 struct device_attribute *attr,
+			 const char *buf, size_t count,
+			 u32 reg)
+{
+	long value;
+	int ret;
+
+	if (reg >= GSS_NUM_REGS)
+		return -EINVAL;
+
+	ret = kstrtol(buf, 16, &value);
+	if (ret) {
+		count = -EFAULT;
+		goto err;
+	}
+
+	ret = zynqmp_pm_write_ggs(reg, value);
+	if (ret)
+		count = -EFAULT;
+err:
+	return count;
+}
+
+/* GGS register show functions */
+#define GGS0_SHOW(N)						\
+	ssize_t ggs##N##_show(struct device *device,		\
+			      struct device_attribute *attr,	\
+			      char *buf)			\
+	{							\
+		return ggs_show(device, attr, buf, N);		\
+	}
+
+static GGS0_SHOW(0);
+static GGS0_SHOW(1);
+static GGS0_SHOW(2);
+static GGS0_SHOW(3);
+
+/* GGS register store function */
+#define GGS0_STORE(N)						\
+	ssize_t ggs##N##_store(struct device *device,		\
+			       struct device_attribute *attr,	\
+			       const char *buf,			\
+			       size_t count)			\
+	{							\
+		return ggs_store(device, attr, buf, count, N);	\
+	}
+
+static GGS0_STORE(0);
+static GGS0_STORE(1);
+static GGS0_STORE(2);
+static GGS0_STORE(3);
+
+static ssize_t pggs_show(struct device *device,
+			 struct device_attribute *attr,
+			 char *buf,
+			 u32 reg)
+{
+	int ret;
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+
+	ret = zynqmp_pm_read_pggs(reg, ret_payload);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "0x%x\n", ret_payload[1]);
+}
+
+static ssize_t pggs_store(struct device *device,
+			  struct device_attribute *attr,
+			  const char *buf, size_t count,
+			  u32 reg)
+{
+	long value;
+	int ret;
+
+	if (reg >= GSS_NUM_REGS)
+		return -EINVAL;
+
+	ret = kstrtol(buf, 16, &value);
+	if (ret) {
+		count = -EFAULT;
+		goto err;
+	}
+
+	ret = zynqmp_pm_write_pggs(reg, value);
+	if (ret)
+		count = -EFAULT;
+
+err:
+	return count;
+}
+
+#define PGGS0_SHOW(N)						\
+	ssize_t pggs##N##_show(struct device *device,		\
+			       struct device_attribute *attr,	\
+			       char *buf)			\
+	{							\
+		return pggs_show(device, attr, buf, N);		\
+	}
+
+#define PGGS0_STORE(N)						\
+	ssize_t pggs##N##_store(struct device *device,		\
+				struct device_attribute *attr,	\
+				const char *buf,		\
+				size_t count)			\
+	{							\
+		return pggs_store(device, attr, buf, count, N);	\
+	}
+
+/* PGGS register show functions */
+static PGGS0_SHOW(0);
+static PGGS0_SHOW(1);
+static PGGS0_SHOW(2);
+static PGGS0_SHOW(3);
+
+/* PGGS register store functions */
+static PGGS0_STORE(0);
+static PGGS0_STORE(1);
+static PGGS0_STORE(2);
+static PGGS0_STORE(3);
+
+/* GGS register attributes */
+static DEVICE_ATTR_RW(ggs0);
+static DEVICE_ATTR_RW(ggs1);
+static DEVICE_ATTR_RW(ggs2);
+static DEVICE_ATTR_RW(ggs3);
+
+/* PGGS register attributes */
+static DEVICE_ATTR_RW(pggs0);
+static DEVICE_ATTR_RW(pggs1);
+static DEVICE_ATTR_RW(pggs2);
+static DEVICE_ATTR_RW(pggs3);
+
+static ssize_t feature_config_id_show(struct device *device,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	struct zynqmp_devinfo *devinfo = dev_get_drvdata(device);
+
+	return sysfs_emit(buf, "%d\n", devinfo->feature_conf_id);
+}
+
+static ssize_t feature_config_id_store(struct device *device,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	u32 config_id;
+	int ret;
+	struct zynqmp_devinfo *devinfo = dev_get_drvdata(device);
+
+	if (!buf)
+		return -EINVAL;
+
+	ret = kstrtou32(buf, 10, &config_id);
+	if (ret)
+		return ret;
+
+	devinfo->feature_conf_id = config_id;
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(feature_config_id);
+
+static ssize_t feature_config_value_show(struct device *device,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	int ret;
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	struct zynqmp_devinfo *devinfo = dev_get_drvdata(device);
+
+	ret = zynqmp_pm_get_feature_config(devinfo->feature_conf_id,
+					   ret_payload);
+	if (ret)
+		return ret;
+
+	return sysfs_emit(buf, "%d\n", ret_payload[1]);
+}
+
+static ssize_t feature_config_value_store(struct device *device,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	u32 value;
+	int ret;
+	struct zynqmp_devinfo *devinfo = dev_get_drvdata(device);
+
+	if (!buf)
+		return -EINVAL;
+
+	ret = kstrtou32(buf, 10, &value);
+	if (ret)
+		return ret;
+
+	ret = zynqmp_pm_set_feature_config(devinfo->feature_conf_id,
+					   value);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(feature_config_value);
+
+static ssize_t last_reset_reason_show(struct device *device,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	ret = zynqmp_pm_get_last_reset_reason(ret_payload);
+	if (ret)
+		return ret;
+
+	switch (ret_payload[1]) {
+	case PM_RESET_REASON_EXT_POR:
+		return sprintf(buf, "ext_por\n");
+	case PM_RESET_REASON_SW_POR:
+		return sprintf(buf, "sw_por\n");
+	case PM_RESET_REASON_SLR_POR:
+		return sprintf(buf, "slr_por\n");
+	case PM_RESET_REASON_ERR_POR:
+		return sprintf(buf, "err_por\n");
+	case PM_RESET_REASON_DAP_SRST:
+		return sprintf(buf, "dap_srst\n");
+	case PM_RESET_REASON_ERR_SRST:
+		return sprintf(buf, "err_srst\n");
+	case PM_RESET_REASON_SW_SRST:
+		return sprintf(buf, "sw_srst\n");
+	case PM_RESET_REASON_SLR_SRST:
+		return sprintf(buf, "slr_srst\n");
+	default:
+		return sprintf(buf, "unknown reset\n");
+	}
+}
+
+static DEVICE_ATTR_RO(last_reset_reason);
+
+static const struct attribute *zynqmp_firmware_attrs[] = {
+	&dev_attr_ggs0.attr,
+	&dev_attr_ggs1.attr,
+	&dev_attr_ggs2.attr,
+	&dev_attr_ggs3.attr,
+	&dev_attr_pggs0.attr,
+	&dev_attr_pggs1.attr,
+	&dev_attr_pggs2.attr,
+	&dev_attr_pggs3.attr,
+	&dev_attr_shutdown_scope.attr,
+	&dev_attr_health_status.attr,
+	&dev_attr_feature_config_id.attr,
+	&dev_attr_feature_config_value.attr,
+	&dev_attr_last_reset_reason.attr,
+	NULL,
+};
+
+/**
+ * config_reg_store - Write config_reg sysfs attribute
+ * @kobj:	Kobject structure
+ * @attr:	Kobject attribute structure
+ * @buf:	User entered health_status attribute string
+ * @count:	Buffer size
+ *
+ * User-space interface for setting the config register.
+ *
+ * To write any CSU/PMU register
+ * echo <address> <mask> <values> > /sys/firmware/zynqmp/config_reg
+ * Usage:
+ * echo 0x345AB234 0xFFFFFFFF 0x1234ABCD > /sys/firmware/zynqmp/config_reg
+ *
+ * To Read any CSU/PMU register, write address to the variable like below
+ * echo <address> > /sys/firmware/zynqmp/config_reg
+ *
+ * Return:	count argument if request succeeds, the corresponding error
+ *		code otherwise
+ */
+static ssize_t config_reg_store(struct kobject *kobj,
+				struct kobj_attribute *attr,
+				const char *buf, size_t count)
+{
+	char *kern_buff, *inbuf, *tok;
+	unsigned long address, value, mask;
+	int ret;
+
+	kern_buff = kzalloc(count + 1, GFP_KERNEL);
+	if (!kern_buff)
+		return -ENOMEM;
+
+	ret = strscpy(kern_buff, buf, count + 1);
+	if (ret < 0) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	inbuf = kern_buff;
+
+	/* Read the addess */
+	tok = strsep(&inbuf, " ");
+	if (!tok) {
+		ret = -EFAULT;
+		goto err;
+	}
+	ret = kstrtol(tok, 16, &address);
+	if (ret) {
+		ret = -EFAULT;
+		goto err;
+	}
+	/* Read the write value */
+	tok = strsep(&inbuf, " ");
+	/*
+	 * If parameter provided is only address, then its a read operation.
+	 * Store the address in a global variable and retrieve whenever
+	 * required.
+	 */
+	if (!tok) {
+		register_address = address;
+		goto err;
+	}
+	register_address = address;
+
+	ret = kstrtol(tok, 16, &mask);
+	if (ret) {
+		ret = -EFAULT;
+		goto err;
+	}
+	tok = strsep(&inbuf, " ");
+	if (!tok) {
+		ret = -EFAULT;
+		goto err;
+	}
+	ret = kstrtol(tok, 16, &value);
+	if (ret) {
+		ret = -EFAULT;
+		goto err;
+	}
+	ret = zynqmp_pm_config_reg_access(CONFIG_REG_WRITE, address,
+					  mask, value, NULL);
+	if (ret)
+		pr_err("unable to write value to %lx\n", value);
+err:
+	kfree(kern_buff);
+	if (ret)
+		return ret;
+	return count;
+}
+
+/**
+ * config_reg_show - Read config_reg sysfs attribute
+ * @kobj:	Kobject structure
+ * @attr:	Kobject attribute structure
+ * @buf:	User entered health_status attribute string
+ *
+ * User-space interface for getting the config register.
+ *
+ * To Read any CSU/PMU register, write address to the variable like below
+ * echo <address> > /sys/firmware/zynqmp/config_reg
+ *
+ * Then Read the address using below command
+ * cat /sys/firmware/zynqmp/config_reg
+ *
+ * Return: number of chars written to buf.
+ */
+static ssize_t config_reg_show(struct kobject *kobj,
+			       struct kobj_attribute *attr,
+			       char *buf)
+{
+	int ret;
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+
+	ret = zynqmp_pm_config_reg_access(CONFIG_REG_READ, register_address,
+					  0, 0, ret_payload);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "0x%x\n", ret_payload[1]);
+}
+
+static struct kobj_attribute zynqmp_attr_config_reg =
+					__ATTR_RW(config_reg);
+
+static struct attribute *attrs[] = {
+	&zynqmp_attr_config_reg.attr,
+	NULL,
+};
+
+static const struct attribute_group attr_group = {
+	.attrs = attrs,
+	NULL,
+};
+
+int zynqmp_firmware_pm_sysfs_entry(struct platform_device *pdev)
+{
+	struct kobject *zynqmp_kobj;
+	int ret;
+
+	zynqmp_kobj = kobject_create_and_add("zynqmp", firmware_kobj);
+	if (!zynqmp_kobj) {
+		pr_err("zynqmp: Firmware kobj add failed.\n");
+		return -ENOMEM;
+	}
+
+	ret = sysfs_create_group(zynqmp_kobj, &attr_group);
+	if (ret) {
+		pr_err("%s() sysfs creation fail with error %d\n",
+		       __func__, ret);
+		return ret;
+	}
+
+
+	ret = sysfs_create_files(&pdev->dev.kobj, zynqmp_firmware_attrs);
+	if (ret) {
+		pr_err("%s() Failed to create PM firmware attrs, err=%d\n",
+		       __func__, ret);
+	}
+
+	return ret;
+}
--- /dev/null
+++ linux-xlnx-2025.1/drivers/firmware/xilinx/zynqmp-secure.c	2025-07-02 12:01:23.395076500 +0900
@@ -0,0 +1,194 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx ZynqMP SecureFw Driver.
+ * Copyright (C) 2018 - 2022 Xilinx Inc.
+ * Copyright (C) 2022 - 2025 Advanced Micro Devices, Inc.
+ */
+
+#include <asm/cacheflush.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/firmware.h>
+#include <linux/firmware/xlnx-zynqmp.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+
+#define ZYNQMP_AES_KEY_SIZE	64
+
+static u8 key[ZYNQMP_AES_KEY_SIZE] = {0};
+static dma_addr_t dma_addr;
+static u8 *keyptr;
+static size_t dma_size;
+static char *kbuf;
+
+static ssize_t secure_load_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	const struct firmware *fw;
+	char image_name[NAME_MAX];
+	u64 dst, ret;
+	int len;
+
+	len = strscpy(image_name, buf, NAME_MAX - 1);
+	if (len > 0) {
+		if (image_name[len - 1] == '\n')
+			image_name[len - 1] = 0;
+	} else {
+		return -E2BIG;
+	}
+
+	ret = request_firmware(&fw, image_name, dev);
+	if (ret) {
+		dev_err(dev, "Error requesting firmware %s\n", image_name);
+		return ret;
+	}
+	dma_size = fw->size;
+
+	if (keyptr)
+		dma_size = fw->size + ZYNQMP_AES_KEY_SIZE;
+
+	kbuf = dma_alloc_coherent(dev, dma_size,
+				  &dma_addr, GFP_KERNEL);
+	if (!kbuf) {
+		release_firmware(fw);
+		return -ENOMEM;
+	}
+
+	memcpy(kbuf, fw->data, fw->size);
+
+	if (keyptr)
+		memcpy(kbuf + fw->size, key, ZYNQMP_AES_KEY_SIZE);
+
+	/* To ensure cache coherency */
+	caches_clean_inval_user_pou((unsigned long)kbuf,
+				    (unsigned long)kbuf + dma_size);
+
+	if (keyptr)
+		ret = zynqmp_pm_secure_load(dma_addr, dma_addr + fw->size,
+					    &dst);
+	else
+		ret = zynqmp_pm_secure_load(dma_addr, 0, &dst);
+
+	release_firmware(fw);
+
+	if (ret) {
+		dev_info(dev, "Failed to load secure image \r\n");
+		return ret;
+	}
+	dev_info(dev, "Verified image at 0x%llx\n", dst);
+
+	return count;
+}
+
+static ssize_t key_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	return snprintf(buf, ZYNQMP_AES_KEY_SIZE + 1, "%s\n", key);
+}
+
+static ssize_t key_store(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	memcpy(key, buf, count);
+	keyptr = &key[0];
+	return count;
+}
+
+static ssize_t secure_load_done_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	int ret;
+	unsigned int value;
+
+	ret = kstrtouint(buf, 10, &value);
+	if (ret)
+		return ret;
+	if (value)
+		dma_free_coherent(dev, dma_size, kbuf, dma_addr);
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(key);
+static DEVICE_ATTR_WO(secure_load);
+static DEVICE_ATTR_WO(secure_load_done);
+
+static struct attribute *securefw_attrs[] = {
+	&dev_attr_secure_load_done.attr,
+	&dev_attr_secure_load.attr,
+	&dev_attr_key.attr,
+	NULL,
+};
+
+ATTRIBUTE_GROUPS(securefw);
+
+static int securefw_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct platform_device *securefw_pdev;
+
+	securefw_pdev = pdev;
+
+	securefw_pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+
+	ret = of_dma_configure(&securefw_pdev->dev, NULL, true);
+	if (ret < 0) {
+		dev_info(&securefw_pdev->dev, "Cannot setup DMA ops\r\n");
+		return ret;
+	}
+
+	ret = sysfs_create_groups(&securefw_pdev->dev.kobj, securefw_groups);
+	if (ret)
+		return ret;
+
+	dev_info(&securefw_pdev->dev, "securefw probed\r\n");
+	return ret;
+}
+
+static void securefw_remove(struct platform_device *pdev)
+{
+	sysfs_remove_groups(&pdev->dev.kobj, securefw_groups);
+}
+
+static struct platform_driver securefw_driver = {
+	.driver = {
+		.name = "securefw",
+	},
+	.probe = securefw_probe,
+	.remove = securefw_remove,
+};
+
+static struct platform_device *securefw_dev_reg;
+
+static int __init zynqmp_secure_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&securefw_driver);
+	if (ret)
+		return ret;
+
+	securefw_dev_reg = platform_device_register_simple("securefw", -1,
+							   NULL, 0);
+	if (IS_ERR(securefw_dev_reg)) {
+		ret = PTR_ERR(securefw_dev_reg);
+		platform_driver_unregister(&securefw_driver);
+		return ret;
+	}
+	return 0;
+}
+
+static void __exit zynqmp_secure_exit(void)
+{
+	platform_device_unregister(securefw_dev_reg);
+	platform_driver_unregister(&securefw_driver);
+}
+
+module_init(zynqmp_secure_init);
+module_exit(zynqmp_secure_exit);
--- /dev/null
+++ linux-xlnx-2025.1/drivers/firmware/xilinx/zynqmp-sem.c	2025-07-02 12:01:23.396098200 +0900
@@ -0,0 +1,176 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Firmware layer for XilSEM APIs.
+ *
+ * Copyright (C), 2025 Advanced Micro Devices, Inc.
+ */
+
+#include <linux/export.h>
+#include <linux/firmware/xlnx-zynqmp.h>
+
+/**
+ * zynqmp_pm_xilsem_cntrl_ops - PM call to perform XilSEM operations
+ * @cmd:	Command for XilSEM scan control operations
+ * @slrid:	SLR id on which scan operation to be done
+ * @response:	Output response (command header, error code or status, slr id)
+ *
+ * Return: Returns 0 on success or error value on failure.
+ */
+int zynqmp_pm_xilsem_cntrl_ops(u32 cmd, u32 slrid, u32 *const response)
+{
+	u32 ret_buf[PAYLOAD_ARG_CNT];
+	int ret;
+
+	ret = zynqmp_pm_invoke_fn(PM_XSEM_HEADER | cmd, ret_buf, 1, slrid);
+	response[0] = ret_buf[1];
+	response[1] = ret_buf[2];
+	response[2] = ret_buf[3];
+	response[3] = ret_buf[4];
+	response[4] = ret_buf[5];
+	response[5] = ret_buf[6];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_xilsem_cntrl_ops);
+
+/**
+ * zynqmp_pm_xilsem_cram_errinj - PM call to perform CRAM error injection
+ * @slrid:	SLR id to inject error in CRAM
+ * @frame:	Frame number to be used for error injection
+ * @qword:	Word number to be used for error injection
+ * @bit:	Bit location to be used for error injection
+ * @row:	CFRAME row number to be used for error injection
+ * @response:	Output response (command header, error code or status, slr id)
+ *
+ * Return: Returns 0 on success or error value on failure.
+ */
+int zynqmp_pm_xilsem_cram_errinj(u32 slrid, u32 frame, u32 qword, u32 bit, u32 row,
+				 u32 *const response)
+{
+	u32 ret_buf[PAYLOAD_ARG_CNT];
+	int ret;
+
+	ret = zynqmp_pm_invoke_fn(PM_XSEM_CRAM_ERRINJ, ret_buf, 5, slrid, frame, qword, bit, row);
+	response[0] = ret_buf[1];
+	response[1] = ret_buf[2];
+	response[2] = ret_buf[3];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_xilsem_cram_errinj);
+
+/**
+ * zynqmp_pm_xilsem_cram_readecc - PM call to perform CFRAME ECC read
+ * @slrid:	SLR id on which Frame ECC read to be done
+ * @frame:	Frame number to be used for reading ECC
+ * @row:	CFRAME row number to be used for reading ECC
+ * @response:	Output response (Frame ecc header, ECC values, status)
+ *
+ * Return: Returns 0 on success or error value on failure.
+ */
+int zynqmp_pm_xilsem_cram_readecc(u32 slrid, u32 frame, u32 row, u32 *const response)
+{
+	u32 ret_buf[PAYLOAD_ARG_CNT];
+	int ret;
+
+	ret = zynqmp_pm_invoke_fn(PM_XSEM_CRAM_RD_ECC, ret_buf, 3, slrid, frame, row);
+	response[0] = ret_buf[1];
+	response[1] = ret_buf[2];
+	response[2] = ret_buf[3];
+	response[3] = ret_buf[4];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_xilsem_cram_readecc);
+
+/**
+ * zynqmp_pm_xilsem_read_cfg - PM call to perform Xilsem configuration read
+ * @slrid:	SLR id for which configuration to be read
+ * @response:	Output response (config header, Xilsem config, status)
+ *
+ * Return: Returns 0 on success or error value on failure.
+ */
+int zynqmp_pm_xilsem_read_cfg(u32 slrid, u32 *const response)
+{
+	u32 ret_buf[PAYLOAD_ARG_CNT];
+	int ret;
+
+	ret = zynqmp_pm_invoke_fn(PM_XSEM_RD_CONFIG, ret_buf, 1, slrid);
+	response[0] = ret_buf[1];
+	response[1] = ret_buf[2];
+	response[2] = ret_buf[3];
+	response[3] = ret_buf[4];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_xilsem_read_cfg);
+
+/**
+ * zynqmp_pm_xilsem_read_ssit_status - PM call to perform Xilsem SSIT status
+ * @slrid:	SLR id for which ECC read to be done
+ * @bufaddr:	Buffer address to get the status information
+ * @response:	Output response (status read header, slr id)
+ *
+ * Return: Returns 0 on success or error value on failure.
+ */
+int zynqmp_pm_xilsem_read_ssit_status(u32 slrid, u32 bufaddr, u32 *const response)
+{
+	u32 ret_buf[PAYLOAD_ARG_CNT];
+	int ret;
+
+	ret = zynqmp_pm_invoke_fn(PM_XSEM_SSIT_RD_STS, ret_buf, 2, slrid, bufaddr);
+	response[0] = ret_buf[1];
+	response[1] = ret_buf[2];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_xilsem_read_ssit_status);
+
+/**
+ * zynqmp_pm_xilsem_cram_getcrc - PM call to perform CRAM Row CRC read
+ * @slrid:	SLR id for which CRC read to be done
+ * @rowindex:	CFRAME row number to be used for reading CRC
+ * @response:	Output response (Get CRC header, CRC values, status)
+ *
+ * Return: Returns 0 on success or error value on failure.
+ */
+int zynqmp_pm_xilsem_cram_getcrc(u32 slrid, u32 rowindex, u32 *const response)
+{
+	u32 ret_buf[PAYLOAD_ARG_CNT];
+	int ret;
+
+	ret = zynqmp_pm_invoke_fn(PM_XSEM_SSIT_GET_CRC, ret_buf, 2, slrid, rowindex);
+	response[0] = ret_buf[1];
+	response[1] = ret_buf[2];
+	response[2] = ret_buf[3];
+	response[3] = ret_buf[4];
+	response[4] = ret_buf[5];
+	response[5] = ret_buf[6];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_xilsem_cram_getcrc);
+
+/**
+ * zynqmp_pm_xilsem_cram_ssit_totframes - PM call to perform total frames read
+ * @slrid:	SLR id for which total frames read to be done
+ * @row:	CFRAME row number to be used for reading ECC
+ * @framecnt: Buffer address to get toral frames data
+ * @response:	Output response (Total frames header, slr id, row, status)
+ *
+ * Return: Returns 0 on success or error value on failure.
+ */
+int zynqmp_pm_xilsem_cram_ssit_totframes(u32 slrid, u32 row, u32 framecnt, u32 *const response)
+{
+	u32 ret_buf[PAYLOAD_ARG_CNT];
+	int ret;
+
+	ret = zynqmp_pm_invoke_fn(PM_XSEM_SSIT_GET_FRAMES, ret_buf, 3, slrid, row, framecnt);
+	response[0] = ret_buf[1];
+	response[1] = ret_buf[2];
+	response[2] = ret_buf[3];
+	response[3] = ret_buf[4];
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_xilsem_cram_ssit_totframes);
--- linux-6.12.10/drivers/firmware/xilinx/zynqmp.c	2025-07-02 11:58:39.768032100 +0900
+++ linux-xlnx-2025.1/drivers/firmware/xilinx/zynqmp.c	1970-01-01 09:00:00.000000000 +0900
@@ -1,1988 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Xilinx Zynq MPSoC Firmware layer
- *
- *  Copyright (C) 2014-2022 Xilinx, Inc.
- *  Copyright (C) 2022 - 2023, Advanced Micro Devices, Inc.
- *
- *  Michal Simek <michal.simek@amd.com>
- *  Davorin Mista <davorin.mista@aggios.com>
- *  Jolly Shah <jollys@xilinx.com>
- *  Rajan Vaja <rajanv@xilinx.com>
- */
-
-#include <linux/arm-smccc.h>
-#include <linux/compiler.h>
-#include <linux/device.h>
-#include <linux/init.h>
-#include <linux/mfd/core.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_platform.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <linux/uaccess.h>
-#include <linux/hashtable.h>
-
-#include <linux/firmware/xlnx-zynqmp.h>
-#include <linux/firmware/xlnx-event-manager.h>
-#include "zynqmp-debug.h"
-
-/* Max HashMap Order for PM API feature check (1<<7 = 128) */
-#define PM_API_FEATURE_CHECK_MAX_ORDER  7
-
-/* CRL registers and bitfields */
-#define CRL_APB_BASE			0xFF5E0000U
-/* BOOT_PIN_CTRL- Used to control the mode pins after boot */
-#define CRL_APB_BOOT_PIN_CTRL		(CRL_APB_BASE + (0x250U))
-/* BOOT_PIN_CTRL_MASK- out_val[11:8], out_en[3:0] */
-#define CRL_APB_BOOTPIN_CTRL_MASK	0xF0FU
-
-/* IOCTL/QUERY feature payload size */
-#define FEATURE_PAYLOAD_SIZE		2
-
-static bool feature_check_enabled;
-static DEFINE_HASHTABLE(pm_api_features_map, PM_API_FEATURE_CHECK_MAX_ORDER);
-static u32 ioctl_features[FEATURE_PAYLOAD_SIZE];
-static u32 query_features[FEATURE_PAYLOAD_SIZE];
-
-static struct platform_device *em_dev;
-
-/**
- * struct zynqmp_devinfo - Structure for Zynqmp device instance
- * @dev:		Device Pointer
- * @feature_conf_id:	Feature conf id
- */
-struct zynqmp_devinfo {
-	struct device *dev;
-	u32 feature_conf_id;
-};
-
-/**
- * struct pm_api_feature_data - PM API Feature data
- * @pm_api_id:		PM API Id, used as key to index into hashmap
- * @feature_status:	status of PM API feature: valid, invalid
- * @hentry:		hlist_node that hooks this entry into hashtable
- */
-struct pm_api_feature_data {
-	u32 pm_api_id;
-	int feature_status;
-	struct hlist_node hentry;
-};
-
-static const struct mfd_cell firmware_devs[] = {
-	{
-		.name = "zynqmp_power_controller",
-	},
-};
-
-/**
- * zynqmp_pm_ret_code() - Convert PMU-FW error codes to Linux error codes
- * @ret_status:		PMUFW return code
- *
- * Return: corresponding Linux error code
- */
-static int zynqmp_pm_ret_code(u32 ret_status)
-{
-	switch (ret_status) {
-	case XST_PM_SUCCESS:
-	case XST_PM_DOUBLE_REQ:
-		return 0;
-	case XST_PM_NO_FEATURE:
-		return -ENOTSUPP;
-	case XST_PM_INVALID_VERSION:
-		return -EOPNOTSUPP;
-	case XST_PM_NO_ACCESS:
-		return -EACCES;
-	case XST_PM_ABORT_SUSPEND:
-		return -ECANCELED;
-	case XST_PM_MULT_USER:
-		return -EUSERS;
-	case XST_PM_INTERNAL:
-	case XST_PM_CONFLICT:
-	case XST_PM_INVALID_NODE:
-	case XST_PM_INVALID_CRC:
-	default:
-		return -EINVAL;
-	}
-}
-
-static noinline int do_fw_call_fail(u32 *ret_payload, u32 num_args, ...)
-{
-	return -ENODEV;
-}
-
-/*
- * PM function call wrapper
- * Invoke do_fw_call_smc or do_fw_call_hvc, depending on the configuration
- */
-static int (*do_fw_call)(u32 *ret_payload, u32, ...) = do_fw_call_fail;
-
-/**
- * do_fw_call_smc() - Call system-level platform management layer (SMC)
- * @num_args:		Number of variable arguments should be <= 8
- * @ret_payload:	Returned value array
- *
- * Invoke platform management function via SMC call (no hypervisor present).
- *
- * Return: Returns status, either success or error+reason
- */
-static noinline int do_fw_call_smc(u32 *ret_payload, u32 num_args, ...)
-{
-	struct arm_smccc_res res;
-	u64 args[8] = {0};
-	va_list arg_list;
-	u8 i;
-
-	if (num_args > 8)
-		return -EINVAL;
-
-	va_start(arg_list, num_args);
-
-	for (i = 0; i < num_args; i++)
-		args[i] = va_arg(arg_list, u64);
-
-	va_end(arg_list);
-
-	arm_smccc_smc(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], &res);
-
-	if (ret_payload) {
-		ret_payload[0] = lower_32_bits(res.a0);
-		ret_payload[1] = upper_32_bits(res.a0);
-		ret_payload[2] = lower_32_bits(res.a1);
-		ret_payload[3] = upper_32_bits(res.a1);
-	}
-
-	return zynqmp_pm_ret_code((enum pm_ret_status)res.a0);
-}
-
-/**
- * do_fw_call_hvc() - Call system-level platform management layer (HVC)
- * @num_args:		Number of variable arguments should be <= 8
- * @ret_payload:	Returned value array
- *
- * Invoke platform management function via HVC
- * HVC-based for communication through hypervisor
- * (no direct communication with ATF).
- *
- * Return: Returns status, either success or error+reason
- */
-static noinline int do_fw_call_hvc(u32 *ret_payload, u32 num_args, ...)
-{
-	struct arm_smccc_res res;
-	u64 args[8] = {0};
-	va_list arg_list;
-	u8 i;
-
-	if (num_args > 8)
-		return -EINVAL;
-
-	va_start(arg_list, num_args);
-
-	for (i = 0; i < num_args; i++)
-		args[i] = va_arg(arg_list, u64);
-
-	va_end(arg_list);
-
-	arm_smccc_hvc(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], &res);
-
-	if (ret_payload) {
-		ret_payload[0] = lower_32_bits(res.a0);
-		ret_payload[1] = upper_32_bits(res.a0);
-		ret_payload[2] = lower_32_bits(res.a1);
-		ret_payload[3] = upper_32_bits(res.a1);
-	}
-
-	return zynqmp_pm_ret_code((enum pm_ret_status)res.a0);
-}
-
-static int __do_feature_check_call(const u32 api_id, u32 *ret_payload)
-{
-	int ret;
-	u64 smc_arg[2];
-	u32 module_id;
-	u32 feature_check_api_id;
-
-	module_id = FIELD_GET(MODULE_ID_MASK, api_id);
-
-	/*
-	 * Feature check of APIs belonging to PM, XSEM, and TF-A are handled by calling
-	 * PM_FEATURE_CHECK API. For other modules, call PM_API_FEATURES API.
-	 */
-	if (module_id == PM_MODULE_ID || module_id == XSEM_MODULE_ID || module_id == TF_A_MODULE_ID)
-		feature_check_api_id = PM_FEATURE_CHECK;
-	else
-		feature_check_api_id = PM_API_FEATURES;
-
-	/*
-	 * Feature check of TF-A APIs is done in the TF-A layer and it expects for
-	 * MODULE_ID_MASK bits of SMC's arg[0] to be the same as PM_MODULE_ID.
-	 */
-	if (module_id == TF_A_MODULE_ID)
-		module_id = PM_MODULE_ID;
-
-	smc_arg[0] = PM_SIP_SVC | FIELD_PREP(MODULE_ID_MASK, module_id) | feature_check_api_id;
-	smc_arg[1] = (api_id & API_ID_MASK);
-
-	ret = do_fw_call(ret_payload, 2, smc_arg[0], smc_arg[1]);
-	if (ret)
-		ret = -EOPNOTSUPP;
-	else
-		ret = ret_payload[1];
-
-	return ret;
-}
-
-static int do_feature_check_call(const u32 api_id)
-{
-	int ret;
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	struct pm_api_feature_data *feature_data;
-
-	/* Check for existing entry in hash table for given api */
-	hash_for_each_possible(pm_api_features_map, feature_data, hentry,
-			       api_id) {
-		if (feature_data->pm_api_id == api_id)
-			return feature_data->feature_status;
-	}
-
-	/* Add new entry if not present */
-	feature_data = kmalloc(sizeof(*feature_data), GFP_ATOMIC);
-	if (!feature_data)
-		return -ENOMEM;
-
-	feature_data->pm_api_id = api_id;
-	ret = __do_feature_check_call(api_id, ret_payload);
-
-	feature_data->feature_status = ret;
-	hash_add(pm_api_features_map, &feature_data->hentry, api_id);
-
-	if (api_id == PM_IOCTL)
-		/* Store supported IOCTL IDs mask */
-		memcpy(ioctl_features, &ret_payload[2], FEATURE_PAYLOAD_SIZE * 4);
-	else if (api_id == PM_QUERY_DATA)
-		/* Store supported QUERY IDs mask */
-		memcpy(query_features, &ret_payload[2], FEATURE_PAYLOAD_SIZE * 4);
-
-	return ret;
-}
-
-/**
- * zynqmp_pm_feature() - Check whether given feature is supported or not and
- *			 store supported IOCTL/QUERY ID mask
- * @api_id:		API ID to check
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_feature(const u32 api_id)
-{
-	int ret;
-
-	if (!feature_check_enabled)
-		return 0;
-
-	ret = do_feature_check_call(api_id);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_feature);
-
-/**
- * zynqmp_pm_is_function_supported() - Check whether given IOCTL/QUERY function
- *				       is supported or not
- * @api_id:		PM_IOCTL or PM_QUERY_DATA
- * @id:			IOCTL or QUERY function IDs
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_is_function_supported(const u32 api_id, const u32 id)
-{
-	int ret;
-	u32 *bit_mask;
-
-	/* Input arguments validation */
-	if (id >= 64 || (api_id != PM_IOCTL && api_id != PM_QUERY_DATA))
-		return -EINVAL;
-
-	/* Check feature check API version */
-	ret = do_feature_check_call(PM_FEATURE_CHECK);
-	if (ret < 0)
-		return ret;
-
-	/* Check if feature check version 2 is supported or not */
-	if ((ret & FIRMWARE_VERSION_MASK) == PM_API_VERSION_2) {
-		/*
-		 * Call feature check for IOCTL/QUERY API to get IOCTL ID or
-		 * QUERY ID feature status.
-		 */
-		ret = do_feature_check_call(api_id);
-		if (ret < 0)
-			return ret;
-
-		bit_mask = (api_id == PM_IOCTL) ? ioctl_features : query_features;
-
-		if ((bit_mask[(id / 32)] & BIT((id % 32))) == 0U)
-			return -EOPNOTSUPP;
-	} else {
-		return -ENODATA;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_is_function_supported);
-
-/**
- * zynqmp_pm_invoke_fn() - Invoke the system-level platform management layer
- *			   caller function depending on the configuration
- * @pm_api_id:		Requested PM-API call
- * @ret_payload:	Returned value array
- * @num_args:		Number of arguments to requested PM-API call
- *
- * Invoke platform management function for SMC or HVC call, depending on
- * configuration.
- * Following SMC Calling Convention (SMCCC) for SMC64:
- * Pm Function Identifier,
- * PM_SIP_SVC + PM_API_ID =
- *	((SMC_TYPE_FAST << FUNCID_TYPE_SHIFT)
- *	((SMC_64) << FUNCID_CC_SHIFT)
- *	((SIP_START) << FUNCID_OEN_SHIFT)
- *	((PM_API_ID) & FUNCID_NUM_MASK))
- *
- * PM_SIP_SVC	- Registered ZynqMP SIP Service Call.
- * PM_API_ID	- Platform Management API ID.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_invoke_fn(u32 pm_api_id, u32 *ret_payload, u32 num_args, ...)
-{
-	/*
-	 * Added SIP service call Function Identifier
-	 * Make sure to stay in x0 register
-	 */
-	u64 smc_arg[8];
-	int ret, i;
-	va_list arg_list;
-	u32 args[14] = {0};
-
-	if (num_args > 14)
-		return -EINVAL;
-
-	va_start(arg_list, num_args);
-
-	/* Check if feature is supported or not */
-	ret = zynqmp_pm_feature(pm_api_id);
-	if (ret < 0)
-		return ret;
-
-	for (i = 0; i < num_args; i++)
-		args[i] = va_arg(arg_list, u32);
-
-	va_end(arg_list);
-
-	smc_arg[0] = PM_SIP_SVC | pm_api_id;
-	for (i = 0; i < 7; i++)
-		smc_arg[i + 1] = ((u64)args[(i * 2) + 1] << 32) | args[i * 2];
-
-	return do_fw_call(ret_payload, 8, smc_arg[0], smc_arg[1], smc_arg[2], smc_arg[3],
-			  smc_arg[4], smc_arg[5], smc_arg[6], smc_arg[7]);
-}
-
-static u32 pm_api_version;
-static u32 pm_tz_version;
-static u32 pm_family_code;
-static u32 pm_sub_family_code;
-
-int zynqmp_pm_register_sgi(u32 sgi_num, u32 reset)
-{
-	int ret;
-
-	ret = zynqmp_pm_invoke_fn(TF_A_PM_REGISTER_SGI, NULL, 2, sgi_num, reset);
-	if (ret != -EOPNOTSUPP && !ret)
-		return ret;
-
-	/* try old implementation as fallback strategy if above fails */
-	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 3, IOCTL_REGISTER_SGI, sgi_num, reset);
-}
-
-/**
- * zynqmp_pm_get_api_version() - Get version number of PMU PM firmware
- * @version:	Returned version value
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_get_api_version(u32 *version)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	int ret;
-
-	if (!version)
-		return -EINVAL;
-
-	/* Check is PM API version already verified */
-	if (pm_api_version > 0) {
-		*version = pm_api_version;
-		return 0;
-	}
-	ret = zynqmp_pm_invoke_fn(PM_GET_API_VERSION, ret_payload, 0);
-	*version = ret_payload[1];
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_get_api_version);
-
-/**
- * zynqmp_pm_get_chipid - Get silicon ID registers
- * @idcode:     IDCODE register
- * @version:    version register
- *
- * Return:      Returns the status of the operation and the idcode and version
- *              registers in @idcode and @version.
- */
-int zynqmp_pm_get_chipid(u32 *idcode, u32 *version)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	int ret;
-
-	if (!idcode || !version)
-		return -EINVAL;
-
-	ret = zynqmp_pm_invoke_fn(PM_GET_CHIPID, ret_payload, 0);
-	*idcode = ret_payload[1];
-	*version = ret_payload[2];
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_get_chipid);
-
-/**
- * zynqmp_pm_get_family_info() - Get family info of platform
- * @family:	Returned family code value
- * @subfamily:	Returned sub-family code value
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_get_family_info(u32 *family, u32 *subfamily)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	u32 idcode;
-	int ret;
-
-	/* Check is family or sub-family code already received */
-	if (pm_family_code && pm_sub_family_code) {
-		*family = pm_family_code;
-		*subfamily = pm_sub_family_code;
-		return 0;
-	}
-
-	ret = zynqmp_pm_invoke_fn(PM_GET_CHIPID, ret_payload, 0);
-	if (ret < 0)
-		return ret;
-
-	idcode = ret_payload[1];
-	pm_family_code = FIELD_GET(FAMILY_CODE_MASK, idcode);
-	pm_sub_family_code = FIELD_GET(SUB_FAMILY_CODE_MASK, idcode);
-	*family = pm_family_code;
-	*subfamily = pm_sub_family_code;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_get_family_info);
-
-/**
- * zynqmp_pm_get_trustzone_version() - Get secure trustzone firmware version
- * @version:	Returned version value
- *
- * Return: Returns status, either success or error+reason
- */
-static int zynqmp_pm_get_trustzone_version(u32 *version)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	int ret;
-
-	if (!version)
-		return -EINVAL;
-
-	/* Check is PM trustzone version already verified */
-	if (pm_tz_version > 0) {
-		*version = pm_tz_version;
-		return 0;
-	}
-	ret = zynqmp_pm_invoke_fn(PM_GET_TRUSTZONE_VERSION, ret_payload, 0);
-	*version = ret_payload[1];
-
-	return ret;
-}
-
-/**
- * get_set_conduit_method() - Choose SMC or HVC based communication
- * @np:		Pointer to the device_node structure
- *
- * Use SMC or HVC-based functions to communicate with EL2/EL3.
- *
- * Return: Returns 0 on success or error code
- */
-static int get_set_conduit_method(struct device_node *np)
-{
-	const char *method;
-
-	if (of_property_read_string(np, "method", &method)) {
-		pr_warn("%s missing \"method\" property\n", __func__);
-		return -ENXIO;
-	}
-
-	if (!strcmp("hvc", method)) {
-		do_fw_call = do_fw_call_hvc;
-	} else if (!strcmp("smc", method)) {
-		do_fw_call = do_fw_call_smc;
-	} else {
-		pr_warn("%s Invalid \"method\" property: %s\n",
-			__func__, method);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-/**
- * zynqmp_pm_query_data() - Get query data from firmware
- * @qdata:	Variable to the zynqmp_pm_query_data structure
- * @out:	Returned output value
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_query_data(struct zynqmp_pm_query_data qdata, u32 *out)
-{
-	int ret;
-
-	ret = zynqmp_pm_invoke_fn(PM_QUERY_DATA, out, 4, qdata.qid, qdata.arg1, qdata.arg2,
-				  qdata.arg3);
-
-	/*
-	 * For clock name query, all bytes in SMC response are clock name
-	 * characters and return code is always success. For invalid clocks,
-	 * clock name bytes would be zeros.
-	 */
-	return qdata.qid == PM_QID_CLOCK_GET_NAME ? 0 : ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_query_data);
-
-/**
- * zynqmp_pm_clock_enable() - Enable the clock for given id
- * @clock_id:	ID of the clock to be enabled
- *
- * This function is used by master to enable the clock
- * including peripherals and PLL clocks.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_clock_enable(u32 clock_id)
-{
-	return zynqmp_pm_invoke_fn(PM_CLOCK_ENABLE, NULL, 1, clock_id);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_clock_enable);
-
-/**
- * zynqmp_pm_clock_disable() - Disable the clock for given id
- * @clock_id:	ID of the clock to be disable
- *
- * This function is used by master to disable the clock
- * including peripherals and PLL clocks.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_clock_disable(u32 clock_id)
-{
-	return zynqmp_pm_invoke_fn(PM_CLOCK_DISABLE, NULL, 1, clock_id);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_clock_disable);
-
-/**
- * zynqmp_pm_clock_getstate() - Get the clock state for given id
- * @clock_id:	ID of the clock to be queried
- * @state:	1/0 (Enabled/Disabled)
- *
- * This function is used by master to get the state of clock
- * including peripherals and PLL clocks.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_clock_getstate(u32 clock_id, u32 *state)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	int ret;
-
-	ret = zynqmp_pm_invoke_fn(PM_CLOCK_GETSTATE, ret_payload, 1, clock_id);
-	*state = ret_payload[1];
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_clock_getstate);
-
-/**
- * zynqmp_pm_clock_setdivider() - Set the clock divider for given id
- * @clock_id:	ID of the clock
- * @divider:	divider value
- *
- * This function is used by master to set divider for any clock
- * to achieve desired rate.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_clock_setdivider(u32 clock_id, u32 divider)
-{
-	return zynqmp_pm_invoke_fn(PM_CLOCK_SETDIVIDER, NULL, 2, clock_id, divider);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_clock_setdivider);
-
-/**
- * zynqmp_pm_clock_getdivider() - Get the clock divider for given id
- * @clock_id:	ID of the clock
- * @divider:	divider value
- *
- * This function is used by master to get divider values
- * for any clock.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_clock_getdivider(u32 clock_id, u32 *divider)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	int ret;
-
-	ret = zynqmp_pm_invoke_fn(PM_CLOCK_GETDIVIDER, ret_payload, 1, clock_id);
-	*divider = ret_payload[1];
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_clock_getdivider);
-
-/**
- * zynqmp_pm_clock_setparent() - Set the clock parent for given id
- * @clock_id:	ID of the clock
- * @parent_id:	parent id
- *
- * This function is used by master to set parent for any clock.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_clock_setparent(u32 clock_id, u32 parent_id)
-{
-	return zynqmp_pm_invoke_fn(PM_CLOCK_SETPARENT, NULL, 2, clock_id, parent_id);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_clock_setparent);
-
-/**
- * zynqmp_pm_clock_getparent() - Get the clock parent for given id
- * @clock_id:	ID of the clock
- * @parent_id:	parent id
- *
- * This function is used by master to get parent index
- * for any clock.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_clock_getparent(u32 clock_id, u32 *parent_id)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	int ret;
-
-	ret = zynqmp_pm_invoke_fn(PM_CLOCK_GETPARENT, ret_payload, 1, clock_id);
-	*parent_id = ret_payload[1];
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_clock_getparent);
-
-/**
- * zynqmp_pm_set_pll_frac_mode() - PM API for set PLL mode
- *
- * @clk_id:	PLL clock ID
- * @mode:	PLL mode (PLL_MODE_FRAC/PLL_MODE_INT)
- *
- * This function sets PLL mode
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_set_pll_frac_mode(u32 clk_id, u32 mode)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, 0, IOCTL_SET_PLL_FRAC_MODE, clk_id, mode);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_set_pll_frac_mode);
-
-/**
- * zynqmp_pm_get_pll_frac_mode() - PM API for get PLL mode
- *
- * @clk_id:	PLL clock ID
- * @mode:	PLL mode
- *
- * This function return current PLL mode
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_get_pll_frac_mode(u32 clk_id, u32 *mode)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, mode, 3, 0, IOCTL_GET_PLL_FRAC_MODE, clk_id);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_get_pll_frac_mode);
-
-/**
- * zynqmp_pm_set_pll_frac_data() - PM API for setting pll fraction data
- *
- * @clk_id:	PLL clock ID
- * @data:	fraction data
- *
- * This function sets fraction data.
- * It is valid for fraction mode only.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_set_pll_frac_data(u32 clk_id, u32 data)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, 0, IOCTL_SET_PLL_FRAC_DATA, clk_id, data);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_set_pll_frac_data);
-
-/**
- * zynqmp_pm_get_pll_frac_data() - PM API for getting pll fraction data
- *
- * @clk_id:	PLL clock ID
- * @data:	fraction data
- *
- * This function returns fraction data value.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_get_pll_frac_data(u32 clk_id, u32 *data)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, data, 3, 0, IOCTL_GET_PLL_FRAC_DATA, clk_id);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_get_pll_frac_data);
-
-/**
- * zynqmp_pm_set_sd_tapdelay() -  Set tap delay for the SD device
- *
- * @node_id:	Node ID of the device
- * @type:	Type of tap delay to set (input/output)
- * @value:	Value to set fot the tap delay
- *
- * This function sets input/output tap delay for the SD device.
- *
- * Return:	Returns status, either success or error+reason
- */
-int zynqmp_pm_set_sd_tapdelay(u32 node_id, u32 type, u32 value)
-{
-	u32 reg = (type == PM_TAPDELAY_INPUT) ? SD_ITAPDLY : SD_OTAPDLYSEL;
-	u32 mask = (node_id == NODE_SD_0) ? GENMASK(15, 0) : GENMASK(31, 16);
-
-	if (value) {
-		return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, node_id, IOCTL_SET_SD_TAPDELAY, type,
-					   value);
-	}
-
-	/*
-	 * Work around completely misdesigned firmware API on Xilinx ZynqMP.
-	 * The IOCTL_SET_SD_TAPDELAY firmware call allows the caller to only
-	 * ever set IOU_SLCR SD_ITAPDLY Register SD0_ITAPDLYENA/SD1_ITAPDLYENA
-	 * bits, but there is no matching call to clear those bits. If those
-	 * bits are not cleared, SDMMC tuning may fail.
-	 *
-	 * Luckily, there are PM_MMIO_READ/PM_MMIO_WRITE calls which seem to
-	 * allow complete unrestricted access to all address space, including
-	 * IOU_SLCR SD_ITAPDLY Register and all the other registers, access
-	 * to which was supposed to be protected by the current firmware API.
-	 *
-	 * Use PM_MMIO_READ/PM_MMIO_WRITE to re-implement the missing counter
-	 * part of IOCTL_SET_SD_TAPDELAY which clears SDx_ITAPDLYENA bits.
-	 */
-	return zynqmp_pm_invoke_fn(PM_MMIO_WRITE, NULL, 2, reg, mask);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_set_sd_tapdelay);
-
-/**
- * zynqmp_pm_sd_dll_reset() - Reset DLL logic
- *
- * @node_id:	Node ID of the device
- * @type:	Reset type
- *
- * This function resets DLL logic for the SD device.
- *
- * Return:	Returns status, either success or error+reason
- */
-int zynqmp_pm_sd_dll_reset(u32 node_id, u32 type)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 3, node_id, IOCTL_SD_DLL_RESET, type);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_sd_dll_reset);
-
-/**
- * zynqmp_pm_ospi_mux_select() - OSPI Mux selection
- *
- * @dev_id:	Device Id of the OSPI device.
- * @select:	OSPI Mux select value.
- *
- * This function select the OSPI Mux.
- *
- * Return:	Returns status, either success or error+reason
- */
-int zynqmp_pm_ospi_mux_select(u32 dev_id, u32 select)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 3, dev_id, IOCTL_OSPI_MUX_SELECT, select);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_ospi_mux_select);
-
-/**
- * zynqmp_pm_write_ggs() - PM API for writing global general storage (ggs)
- * @index:	GGS register index
- * @value:	Register value to be written
- *
- * This function writes value to GGS register.
- *
- * Return:      Returns status, either success or error+reason
- */
-int zynqmp_pm_write_ggs(u32 index, u32 value)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, 0, IOCTL_WRITE_GGS, index, value);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_write_ggs);
-
-/**
- * zynqmp_pm_read_ggs() - PM API for reading global general storage (ggs)
- * @index:	GGS register index
- * @value:	Register value to be written
- *
- * This function returns GGS register value.
- *
- * Return:	Returns status, either success or error+reason
- */
-int zynqmp_pm_read_ggs(u32 index, u32 *value)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, value, 3, 0, IOCTL_READ_GGS, index);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_read_ggs);
-
-/**
- * zynqmp_pm_write_pggs() - PM API for writing persistent global general
- *			     storage (pggs)
- * @index:	PGGS register index
- * @value:	Register value to be written
- *
- * This function writes value to PGGS register.
- *
- * Return:	Returns status, either success or error+reason
- */
-int zynqmp_pm_write_pggs(u32 index, u32 value)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, 0, IOCTL_WRITE_PGGS, index, value);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_write_pggs);
-
-/**
- * zynqmp_pm_read_pggs() - PM API for reading persistent global general
- *			     storage (pggs)
- * @index:	PGGS register index
- * @value:	Register value to be written
- *
- * This function returns PGGS register value.
- *
- * Return:	Returns status, either success or error+reason
- */
-int zynqmp_pm_read_pggs(u32 index, u32 *value)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, value, 3, 0, IOCTL_READ_PGGS, index);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_read_pggs);
-
-int zynqmp_pm_set_tapdelay_bypass(u32 index, u32 value)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, 0, IOCTL_SET_TAPDELAY_BYPASS, index, value);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_set_tapdelay_bypass);
-
-/**
- * zynqmp_pm_set_boot_health_status() - PM API for setting healthy boot status
- * @value:	Status value to be written
- *
- * This function sets healthy bit value to indicate boot health status
- * to firmware.
- *
- * Return:	Returns status, either success or error+reason
- */
-int zynqmp_pm_set_boot_health_status(u32 value)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 3, 0, IOCTL_SET_BOOT_HEALTH_STATUS, value);
-}
-
-/**
- * zynqmp_pm_reset_assert - Request setting of reset (1 - assert, 0 - release)
- * @reset:		Reset to be configured
- * @assert_flag:	Flag stating should reset be asserted (1) or
- *			released (0)
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_reset_assert(const enum zynqmp_pm_reset reset,
-			   const enum zynqmp_pm_reset_action assert_flag)
-{
-	return zynqmp_pm_invoke_fn(PM_RESET_ASSERT, NULL, 2, reset, assert_flag);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_reset_assert);
-
-/**
- * zynqmp_pm_reset_get_status - Get status of the reset
- * @reset:      Reset whose status should be returned
- * @status:     Returned status
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_reset_get_status(const enum zynqmp_pm_reset reset, u32 *status)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	int ret;
-
-	if (!status)
-		return -EINVAL;
-
-	ret = zynqmp_pm_invoke_fn(PM_RESET_GET_STATUS, ret_payload, 1, reset);
-	*status = ret_payload[1];
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_reset_get_status);
-
-/**
- * zynqmp_pm_fpga_load - Perform the fpga load
- * @address:	Address to write to
- * @size:	pl bitstream size
- * @flags:	Bitstream type
- *	-XILINX_ZYNQMP_PM_FPGA_FULL:  FPGA full reconfiguration
- *	-XILINX_ZYNQMP_PM_FPGA_PARTIAL: FPGA partial reconfiguration
- *
- * This function provides access to pmufw. To transfer
- * the required bitstream into PL.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_fpga_load(const u64 address, const u32 size, const u32 flags)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	int ret;
-
-	ret = zynqmp_pm_invoke_fn(PM_FPGA_LOAD, ret_payload, 4, lower_32_bits(address),
-				  upper_32_bits(address), size, flags);
-	if (ret_payload[0])
-		return -ret_payload[0];
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_fpga_load);
-
-/**
- * zynqmp_pm_fpga_get_status - Read value from PCAP status register
- * @value: Value to read
- *
- * This function provides access to the pmufw to get the PCAP
- * status
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_fpga_get_status(u32 *value)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	int ret;
-
-	if (!value)
-		return -EINVAL;
-
-	ret = zynqmp_pm_invoke_fn(PM_FPGA_GET_STATUS, ret_payload, 0);
-	*value = ret_payload[1];
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_fpga_get_status);
-
-/**
- * zynqmp_pm_fpga_get_config_status - Get the FPGA configuration status.
- * @value: Buffer to store FPGA configuration status.
- *
- * This function provides access to the pmufw to get the FPGA configuration
- * status
- *
- * Return: 0 on success, a negative value on error
- */
-int zynqmp_pm_fpga_get_config_status(u32 *value)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	u32 buf, lower_addr, upper_addr;
-	int ret;
-
-	if (!value)
-		return -EINVAL;
-
-	lower_addr = lower_32_bits((u64)&buf);
-	upper_addr = upper_32_bits((u64)&buf);
-
-	ret = zynqmp_pm_invoke_fn(PM_FPGA_READ, ret_payload, 4,
-				  XILINX_ZYNQMP_PM_FPGA_CONFIG_STAT_OFFSET, lower_addr, upper_addr,
-				  XILINX_ZYNQMP_PM_FPGA_READ_CONFIG_REG);
-
-	*value = ret_payload[1];
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_fpga_get_config_status);
-
-/**
- * zynqmp_pm_pinctrl_request - Request Pin from firmware
- * @pin: Pin number to request
- *
- * This function requests pin from firmware.
- *
- * Return: Returns status, either success or error+reason.
- */
-int zynqmp_pm_pinctrl_request(const u32 pin)
-{
-	return zynqmp_pm_invoke_fn(PM_PINCTRL_REQUEST, NULL, 1, pin);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_request);
-
-/**
- * zynqmp_pm_pinctrl_release - Inform firmware that Pin control is released
- * @pin: Pin number to release
- *
- * This function release pin from firmware.
- *
- * Return: Returns status, either success or error+reason.
- */
-int zynqmp_pm_pinctrl_release(const u32 pin)
-{
-	return zynqmp_pm_invoke_fn(PM_PINCTRL_RELEASE, NULL, 1, pin);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_release);
-
-/**
- * zynqmp_pm_pinctrl_set_function - Set requested function for the pin
- * @pin: Pin number
- * @id: Function ID to set
- *
- * This function sets requested function for the given pin.
- *
- * Return: Returns status, either success or error+reason.
- */
-int zynqmp_pm_pinctrl_set_function(const u32 pin, const u32 id)
-{
-	return zynqmp_pm_invoke_fn(PM_PINCTRL_SET_FUNCTION, NULL, 2, pin, id);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_set_function);
-
-/**
- * zynqmp_pm_pinctrl_get_config - Get configuration parameter for the pin
- * @pin: Pin number
- * @param: Parameter to get
- * @value: Buffer to store parameter value
- *
- * This function gets requested configuration parameter for the given pin.
- *
- * Return: Returns status, either success or error+reason.
- */
-int zynqmp_pm_pinctrl_get_config(const u32 pin, const u32 param,
-				 u32 *value)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	int ret;
-
-	if (!value)
-		return -EINVAL;
-
-	ret = zynqmp_pm_invoke_fn(PM_PINCTRL_CONFIG_PARAM_GET, ret_payload, 2, pin, param);
-	*value = ret_payload[1];
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_get_config);
-
-/**
- * zynqmp_pm_pinctrl_set_config - Set configuration parameter for the pin
- * @pin: Pin number
- * @param: Parameter to set
- * @value: Parameter value to set
- *
- * This function sets requested configuration parameter for the given pin.
- *
- * Return: Returns status, either success or error+reason.
- */
-int zynqmp_pm_pinctrl_set_config(const u32 pin, const u32 param,
-				 u32 value)
-{
-	int ret;
-
-	if (pm_family_code == ZYNQMP_FAMILY_CODE &&
-	    param == PM_PINCTRL_CONFIG_TRI_STATE) {
-		ret = zynqmp_pm_feature(PM_PINCTRL_CONFIG_PARAM_SET);
-		if (ret < PM_PINCTRL_PARAM_SET_VERSION)
-			return -EOPNOTSUPP;
-	}
-
-	return zynqmp_pm_invoke_fn(PM_PINCTRL_CONFIG_PARAM_SET, NULL, 3, pin, param, value);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_set_config);
-
-/**
- * zynqmp_pm_bootmode_read() - PM Config API for read bootpin status
- * @ps_mode: Returned output value of ps_mode
- *
- * This API function is to be used for notify the power management controller
- * to read bootpin status.
- *
- * Return: status, either success or error+reason
- */
-unsigned int zynqmp_pm_bootmode_read(u32 *ps_mode)
-{
-	unsigned int ret;
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-
-	ret = zynqmp_pm_invoke_fn(PM_MMIO_READ, ret_payload, 1, CRL_APB_BOOT_PIN_CTRL);
-
-	*ps_mode = ret_payload[1];
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_bootmode_read);
-
-/**
- * zynqmp_pm_bootmode_write() - PM Config API for Configure bootpin
- * @ps_mode: Value to be written to the bootpin ctrl register
- *
- * This API function is to be used for notify the power management controller
- * to configure bootpin.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_bootmode_write(u32 ps_mode)
-{
-	return zynqmp_pm_invoke_fn(PM_MMIO_WRITE, NULL, 3, CRL_APB_BOOT_PIN_CTRL,
-				   CRL_APB_BOOTPIN_CTRL_MASK, ps_mode);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_bootmode_write);
-
-/**
- * zynqmp_pm_init_finalize() - PM call to inform firmware that the caller
- *			       master has initialized its own power management
- *
- * Return: Returns status, either success or error+reason
- *
- * This API function is to be used for notify the power management controller
- * about the completed power management initialization.
- */
-int zynqmp_pm_init_finalize(void)
-{
-	return zynqmp_pm_invoke_fn(PM_PM_INIT_FINALIZE, NULL, 0);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_init_finalize);
-
-/**
- * zynqmp_pm_set_suspend_mode()	- Set system suspend mode
- * @mode:	Mode to set for system suspend
- *
- * This API function is used to set mode of system suspend.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_set_suspend_mode(u32 mode)
-{
-	return zynqmp_pm_invoke_fn(PM_SET_SUSPEND_MODE, NULL, 1, mode);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_set_suspend_mode);
-
-/**
- * zynqmp_pm_request_node() - Request a node with specific capabilities
- * @node:		Node ID of the slave
- * @capabilities:	Requested capabilities of the slave
- * @qos:		Quality of service (not supported)
- * @ack:		Flag to specify whether acknowledge is requested
- *
- * This function is used by master to request particular node from firmware.
- * Every master must request node before using it.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_request_node(const u32 node, const u32 capabilities,
-			   const u32 qos, const enum zynqmp_pm_request_ack ack)
-{
-	return zynqmp_pm_invoke_fn(PM_REQUEST_NODE, NULL, 4, node, capabilities, qos, ack);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_request_node);
-
-/**
- * zynqmp_pm_release_node() - Release a node
- * @node:	Node ID of the slave
- *
- * This function is used by master to inform firmware that master
- * has released node. Once released, master must not use that node
- * without re-request.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_release_node(const u32 node)
-{
-	return zynqmp_pm_invoke_fn(PM_RELEASE_NODE, NULL, 1, node);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_release_node);
-
-/**
- * zynqmp_pm_get_rpu_mode() - Get RPU mode
- * @node_id:	Node ID of the device
- * @rpu_mode:	return by reference value
- *		either split or lockstep
- *
- * Return:	return 0 on success or error+reason.
- *		if success, then  rpu_mode will be set
- *		to current rpu mode.
- */
-int zynqmp_pm_get_rpu_mode(u32 node_id, enum rpu_oper_mode *rpu_mode)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	int ret;
-
-	ret = zynqmp_pm_invoke_fn(PM_IOCTL, ret_payload, 2, node_id, IOCTL_GET_RPU_OPER_MODE);
-
-	/* only set rpu_mode if no error */
-	if (ret == XST_PM_SUCCESS)
-		*rpu_mode = ret_payload[0];
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_get_rpu_mode);
-
-/**
- * zynqmp_pm_set_rpu_mode() - Set RPU mode
- * @node_id:	Node ID of the device
- * @rpu_mode:	Argument 1 to requested IOCTL call. either split or lockstep
- *
- *		This function is used to set RPU mode to split or
- *		lockstep
- *
- * Return:	Returns status, either success or error+reason
- */
-int zynqmp_pm_set_rpu_mode(u32 node_id, enum rpu_oper_mode rpu_mode)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 3, node_id, IOCTL_SET_RPU_OPER_MODE,
-				   (u32)rpu_mode);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_set_rpu_mode);
-
-/**
- * zynqmp_pm_set_tcm_config - configure TCM
- * @node_id:	Firmware specific TCM subsystem ID
- * @tcm_mode:	Argument 1 to requested IOCTL call
- *              either PM_RPU_TCM_COMB or PM_RPU_TCM_SPLIT
- *
- * This function is used to set RPU mode to split or combined
- *
- * Return: status: 0 for success, else failure
- */
-int zynqmp_pm_set_tcm_config(u32 node_id, enum rpu_tcm_comb tcm_mode)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 3, node_id, IOCTL_TCM_COMB_CONFIG,
-				   (u32)tcm_mode);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_set_tcm_config);
-
-/**
- * zynqmp_pm_force_pwrdwn - PM call to request for another PU or subsystem to
- *             be powered down forcefully
- * @node:  Node ID of the targeted PU or subsystem
- * @ack:   Flag to specify whether acknowledge is requested
- *
- * Return: status, either success or error+reason
- */
-int zynqmp_pm_force_pwrdwn(const u32 node,
-			   const enum zynqmp_pm_request_ack ack)
-{
-	return zynqmp_pm_invoke_fn(PM_FORCE_POWERDOWN, NULL, 2, node, ack);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_force_pwrdwn);
-
-/**
- * zynqmp_pm_request_wake - PM call to wake up selected master or subsystem
- * @node:  Node ID of the master or subsystem
- * @set_addr:  Specifies whether the address argument is relevant
- * @address:   Address from which to resume when woken up
- * @ack:   Flag to specify whether acknowledge requested
- *
- * Return: status, either success or error+reason
- */
-int zynqmp_pm_request_wake(const u32 node,
-			   const bool set_addr,
-			   const u64 address,
-			   const enum zynqmp_pm_request_ack ack)
-{
-	/* set_addr flag is encoded into 1st bit of address */
-	return zynqmp_pm_invoke_fn(PM_REQUEST_WAKEUP, NULL, 4, node, address | set_addr,
-				   address >> 32, ack);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_request_wake);
-
-/**
- * zynqmp_pm_set_requirement() - PM call to set requirement for PM slaves
- * @node:		Node ID of the slave
- * @capabilities:	Requested capabilities of the slave
- * @qos:		Quality of service (not supported)
- * @ack:		Flag to specify whether acknowledge is requested
- *
- * This API function is to be used for slaves a PU already has requested
- * to change its capabilities.
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_set_requirement(const u32 node, const u32 capabilities,
-			      const u32 qos,
-			      const enum zynqmp_pm_request_ack ack)
-{
-	return zynqmp_pm_invoke_fn(PM_SET_REQUIREMENT, NULL, 4, node, capabilities, qos, ack);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_set_requirement);
-
-/**
- * zynqmp_pm_load_pdi - Load and process PDI
- * @src:	Source device where PDI is located
- * @address:	PDI src address
- *
- * This function provides support to load PDI from linux
- *
- * Return: Returns status, either success or error+reason
- */
-int zynqmp_pm_load_pdi(const u32 src, const u64 address)
-{
-	return zynqmp_pm_invoke_fn(PM_LOAD_PDI, NULL, 3, src, lower_32_bits(address),
-				   upper_32_bits(address));
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_load_pdi);
-
-/**
- * zynqmp_pm_aes_engine - Access AES hardware to encrypt/decrypt the data using
- * AES-GCM core.
- * @address:	Address of the AesParams structure.
- * @out:	Returned output value
- *
- * Return:	Returns status, either success or error code.
- */
-int zynqmp_pm_aes_engine(const u64 address, u32 *out)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	int ret;
-
-	if (!out)
-		return -EINVAL;
-
-	ret = zynqmp_pm_invoke_fn(PM_SECURE_AES, ret_payload, 2, upper_32_bits(address),
-				  lower_32_bits(address));
-	*out = ret_payload[1];
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_aes_engine);
-
-/**
- * zynqmp_pm_efuse_access - Provides access to efuse memory.
- * @address:	Address of the efuse params structure
- * @out:		Returned output value
- *
- * Return:	Returns status, either success or error code.
- */
-int zynqmp_pm_efuse_access(const u64 address, u32 *out)
-{
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	int ret;
-
-	if (!out)
-		return -EINVAL;
-
-	ret = zynqmp_pm_invoke_fn(PM_EFUSE_ACCESS, ret_payload, 2,
-				  upper_32_bits(address),
-				  lower_32_bits(address));
-	*out = ret_payload[1];
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_efuse_access);
-
-/**
- * zynqmp_pm_sha_hash - Access the SHA engine to calculate the hash
- * @address:	Address of the data/ Address of output buffer where
- *		hash should be stored.
- * @size:	Size of the data.
- * @flags:
- *	BIT(0) - for initializing csudma driver and SHA3(Here address
- *		 and size inputs can be NULL).
- *	BIT(1) - to call Sha3_Update API which can be called multiple
- *		 times when data is not contiguous.
- *	BIT(2) - to get final hash of the whole updated data.
- *		 Hash will be overwritten at provided address with
- *		 48 bytes.
- *
- * Return:	Returns status, either success or error code.
- */
-int zynqmp_pm_sha_hash(const u64 address, const u32 size, const u32 flags)
-{
-	u32 lower_addr = lower_32_bits(address);
-	u32 upper_addr = upper_32_bits(address);
-
-	return zynqmp_pm_invoke_fn(PM_SECURE_SHA, NULL, 4, upper_addr, lower_addr, size, flags);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_sha_hash);
-
-/**
- * zynqmp_pm_register_notifier() - PM API for register a subsystem
- *                                to be notified about specific
- *                                event/error.
- * @node:	Node ID to which the event is related.
- * @event:	Event Mask of Error events for which wants to get notified.
- * @wake:	Wake subsystem upon capturing the event if value 1
- * @enable:	Enable the registration for value 1, disable for value 0
- *
- * This function is used to register/un-register for particular node-event
- * combination in firmware.
- *
- * Return: Returns status, either success or error+reason
- */
-
-int zynqmp_pm_register_notifier(const u32 node, const u32 event,
-				const u32 wake, const u32 enable)
-{
-	return zynqmp_pm_invoke_fn(PM_REGISTER_NOTIFIER, NULL, 4, node, event, wake, enable);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_register_notifier);
-
-/**
- * zynqmp_pm_system_shutdown - PM call to request a system shutdown or restart
- * @type:	Shutdown or restart? 0 for shutdown, 1 for restart
- * @subtype:	Specifies which system should be restarted or shut down
- *
- * Return:	Returns status, either success or error+reason
- */
-int zynqmp_pm_system_shutdown(const u32 type, const u32 subtype)
-{
-	return zynqmp_pm_invoke_fn(PM_SYSTEM_SHUTDOWN, NULL, 2, type, subtype);
-}
-
-/**
- * zynqmp_pm_set_feature_config - PM call to request IOCTL for feature config
- * @id:         The config ID of the feature to be configured
- * @value:      The config value of the feature to be configured
- *
- * Return:      Returns 0 on success or error value on failure.
- */
-int zynqmp_pm_set_feature_config(enum pm_feature_config_id id, u32 value)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, 0, IOCTL_SET_FEATURE_CONFIG, id, value);
-}
-
-/**
- * zynqmp_pm_get_feature_config - PM call to get value of configured feature
- * @id:         The config id of the feature to be queried
- * @payload:    Returned value array
- *
- * Return:      Returns 0 on success or error value on failure.
- */
-int zynqmp_pm_get_feature_config(enum pm_feature_config_id id,
-				 u32 *payload)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, payload, 3, 0, IOCTL_GET_FEATURE_CONFIG, id);
-}
-
-/**
- * zynqmp_pm_set_sd_config - PM call to set value of SD config registers
- * @node:	SD node ID
- * @config:	The config type of SD registers
- * @value:	Value to be set
- *
- * Return:	Returns 0 on success or error value on failure.
- */
-int zynqmp_pm_set_sd_config(u32 node, enum pm_sd_config_type config, u32 value)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, node, IOCTL_SET_SD_CONFIG, config, value);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_set_sd_config);
-
-/**
- * zynqmp_pm_set_gem_config - PM call to set value of GEM config registers
- * @node:	GEM node ID
- * @config:	The config type of GEM registers
- * @value:	Value to be set
- *
- * Return:	Returns 0 on success or error value on failure.
- */
-int zynqmp_pm_set_gem_config(u32 node, enum pm_gem_config_type config,
-			     u32 value)
-{
-	return zynqmp_pm_invoke_fn(PM_IOCTL, NULL, 4, node, IOCTL_SET_GEM_CONFIG, config, value);
-}
-EXPORT_SYMBOL_GPL(zynqmp_pm_set_gem_config);
-
-/**
- * struct zynqmp_pm_shutdown_scope - Struct for shutdown scope
- * @subtype:	Shutdown subtype
- * @name:	Matching string for scope argument
- *
- * This struct encapsulates mapping between shutdown scope ID and string.
- */
-struct zynqmp_pm_shutdown_scope {
-	const enum zynqmp_pm_shutdown_subtype subtype;
-	const char *name;
-};
-
-static struct zynqmp_pm_shutdown_scope shutdown_scopes[] = {
-	[ZYNQMP_PM_SHUTDOWN_SUBTYPE_SUBSYSTEM] = {
-		.subtype = ZYNQMP_PM_SHUTDOWN_SUBTYPE_SUBSYSTEM,
-		.name = "subsystem",
-	},
-	[ZYNQMP_PM_SHUTDOWN_SUBTYPE_PS_ONLY] = {
-		.subtype = ZYNQMP_PM_SHUTDOWN_SUBTYPE_PS_ONLY,
-		.name = "ps_only",
-	},
-	[ZYNQMP_PM_SHUTDOWN_SUBTYPE_SYSTEM] = {
-		.subtype = ZYNQMP_PM_SHUTDOWN_SUBTYPE_SYSTEM,
-		.name = "system",
-	},
-};
-
-static struct zynqmp_pm_shutdown_scope *selected_scope =
-		&shutdown_scopes[ZYNQMP_PM_SHUTDOWN_SUBTYPE_SYSTEM];
-
-/**
- * zynqmp_pm_is_shutdown_scope_valid - Check if shutdown scope string is valid
- * @scope_string:	Shutdown scope string
- *
- * Return:		Return pointer to matching shutdown scope struct from
- *			array of available options in system if string is valid,
- *			otherwise returns NULL.
- */
-static struct zynqmp_pm_shutdown_scope*
-		zynqmp_pm_is_shutdown_scope_valid(const char *scope_string)
-{
-	int count;
-
-	for (count = 0; count < ARRAY_SIZE(shutdown_scopes); count++)
-		if (sysfs_streq(scope_string, shutdown_scopes[count].name))
-			return &shutdown_scopes[count];
-
-	return NULL;
-}
-
-static ssize_t shutdown_scope_show(struct device *device,
-				   struct device_attribute *attr,
-				   char *buf)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(shutdown_scopes); i++) {
-		if (&shutdown_scopes[i] == selected_scope) {
-			strcat(buf, "[");
-			strcat(buf, shutdown_scopes[i].name);
-			strcat(buf, "]");
-		} else {
-			strcat(buf, shutdown_scopes[i].name);
-		}
-		strcat(buf, " ");
-	}
-	strcat(buf, "\n");
-
-	return strlen(buf);
-}
-
-static ssize_t shutdown_scope_store(struct device *device,
-				    struct device_attribute *attr,
-				    const char *buf, size_t count)
-{
-	int ret;
-	struct zynqmp_pm_shutdown_scope *scope;
-
-	scope = zynqmp_pm_is_shutdown_scope_valid(buf);
-	if (!scope)
-		return -EINVAL;
-
-	ret = zynqmp_pm_system_shutdown(ZYNQMP_PM_SHUTDOWN_TYPE_SETSCOPE_ONLY,
-					scope->subtype);
-	if (ret) {
-		pr_err("unable to set shutdown scope %s\n", buf);
-		return ret;
-	}
-
-	selected_scope = scope;
-
-	return count;
-}
-
-static DEVICE_ATTR_RW(shutdown_scope);
-
-static ssize_t health_status_store(struct device *device,
-				   struct device_attribute *attr,
-				   const char *buf, size_t count)
-{
-	int ret;
-	unsigned int value;
-
-	ret = kstrtouint(buf, 10, &value);
-	if (ret)
-		return ret;
-
-	ret = zynqmp_pm_set_boot_health_status(value);
-	if (ret) {
-		dev_err(device, "unable to set healthy bit value to %u\n",
-			value);
-		return ret;
-	}
-
-	return count;
-}
-
-static DEVICE_ATTR_WO(health_status);
-
-static ssize_t ggs_show(struct device *device,
-			struct device_attribute *attr,
-			char *buf,
-			u32 reg)
-{
-	int ret;
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-
-	ret = zynqmp_pm_read_ggs(reg, ret_payload);
-	if (ret)
-		return ret;
-
-	return sprintf(buf, "0x%x\n", ret_payload[1]);
-}
-
-static ssize_t ggs_store(struct device *device,
-			 struct device_attribute *attr,
-			 const char *buf, size_t count,
-			 u32 reg)
-{
-	long value;
-	int ret;
-
-	if (reg >= GSS_NUM_REGS)
-		return -EINVAL;
-
-	ret = kstrtol(buf, 16, &value);
-	if (ret) {
-		count = -EFAULT;
-		goto err;
-	}
-
-	ret = zynqmp_pm_write_ggs(reg, value);
-	if (ret)
-		count = -EFAULT;
-err:
-	return count;
-}
-
-/* GGS register show functions */
-#define GGS0_SHOW(N)						\
-	ssize_t ggs##N##_show(struct device *device,		\
-			      struct device_attribute *attr,	\
-			      char *buf)			\
-	{							\
-		return ggs_show(device, attr, buf, N);		\
-	}
-
-static GGS0_SHOW(0);
-static GGS0_SHOW(1);
-static GGS0_SHOW(2);
-static GGS0_SHOW(3);
-
-/* GGS register store function */
-#define GGS0_STORE(N)						\
-	ssize_t ggs##N##_store(struct device *device,		\
-			       struct device_attribute *attr,	\
-			       const char *buf,			\
-			       size_t count)			\
-	{							\
-		return ggs_store(device, attr, buf, count, N);	\
-	}
-
-static GGS0_STORE(0);
-static GGS0_STORE(1);
-static GGS0_STORE(2);
-static GGS0_STORE(3);
-
-static ssize_t pggs_show(struct device *device,
-			 struct device_attribute *attr,
-			 char *buf,
-			 u32 reg)
-{
-	int ret;
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-
-	ret = zynqmp_pm_read_pggs(reg, ret_payload);
-	if (ret)
-		return ret;
-
-	return sprintf(buf, "0x%x\n", ret_payload[1]);
-}
-
-static ssize_t pggs_store(struct device *device,
-			  struct device_attribute *attr,
-			  const char *buf, size_t count,
-			  u32 reg)
-{
-	long value;
-	int ret;
-
-	if (reg >= GSS_NUM_REGS)
-		return -EINVAL;
-
-	ret = kstrtol(buf, 16, &value);
-	if (ret) {
-		count = -EFAULT;
-		goto err;
-	}
-
-	ret = zynqmp_pm_write_pggs(reg, value);
-	if (ret)
-		count = -EFAULT;
-
-err:
-	return count;
-}
-
-#define PGGS0_SHOW(N)						\
-	ssize_t pggs##N##_show(struct device *device,		\
-			       struct device_attribute *attr,	\
-			       char *buf)			\
-	{							\
-		return pggs_show(device, attr, buf, N);		\
-	}
-
-#define PGGS0_STORE(N)						\
-	ssize_t pggs##N##_store(struct device *device,		\
-				struct device_attribute *attr,	\
-				const char *buf,		\
-				size_t count)			\
-	{							\
-		return pggs_store(device, attr, buf, count, N);	\
-	}
-
-/* PGGS register show functions */
-static PGGS0_SHOW(0);
-static PGGS0_SHOW(1);
-static PGGS0_SHOW(2);
-static PGGS0_SHOW(3);
-
-/* PGGS register store functions */
-static PGGS0_STORE(0);
-static PGGS0_STORE(1);
-static PGGS0_STORE(2);
-static PGGS0_STORE(3);
-
-/* GGS register attributes */
-static DEVICE_ATTR_RW(ggs0);
-static DEVICE_ATTR_RW(ggs1);
-static DEVICE_ATTR_RW(ggs2);
-static DEVICE_ATTR_RW(ggs3);
-
-/* PGGS register attributes */
-static DEVICE_ATTR_RW(pggs0);
-static DEVICE_ATTR_RW(pggs1);
-static DEVICE_ATTR_RW(pggs2);
-static DEVICE_ATTR_RW(pggs3);
-
-static ssize_t feature_config_id_show(struct device *device,
-				      struct device_attribute *attr,
-				      char *buf)
-{
-	struct zynqmp_devinfo *devinfo = dev_get_drvdata(device);
-
-	return sysfs_emit(buf, "%d\n", devinfo->feature_conf_id);
-}
-
-static ssize_t feature_config_id_store(struct device *device,
-				       struct device_attribute *attr,
-				       const char *buf, size_t count)
-{
-	u32 config_id;
-	int ret;
-	struct zynqmp_devinfo *devinfo = dev_get_drvdata(device);
-
-	if (!buf)
-		return -EINVAL;
-
-	ret = kstrtou32(buf, 10, &config_id);
-	if (ret)
-		return ret;
-
-	devinfo->feature_conf_id = config_id;
-
-	return count;
-}
-
-static DEVICE_ATTR_RW(feature_config_id);
-
-static ssize_t feature_config_value_show(struct device *device,
-					 struct device_attribute *attr,
-					 char *buf)
-{
-	int ret;
-	u32 ret_payload[PAYLOAD_ARG_CNT];
-	struct zynqmp_devinfo *devinfo = dev_get_drvdata(device);
-
-	ret = zynqmp_pm_get_feature_config(devinfo->feature_conf_id,
-					   ret_payload);
-	if (ret)
-		return ret;
-
-	return sysfs_emit(buf, "%d\n", ret_payload[1]);
-}
-
-static ssize_t feature_config_value_store(struct device *device,
-					  struct device_attribute *attr,
-					  const char *buf, size_t count)
-{
-	u32 value;
-	int ret;
-	struct zynqmp_devinfo *devinfo = dev_get_drvdata(device);
-
-	if (!buf)
-		return -EINVAL;
-
-	ret = kstrtou32(buf, 10, &value);
-	if (ret)
-		return ret;
-
-	ret = zynqmp_pm_set_feature_config(devinfo->feature_conf_id,
-					   value);
-	if (ret)
-		return ret;
-
-	return count;
-}
-
-static DEVICE_ATTR_RW(feature_config_value);
-
-static struct attribute *zynqmp_firmware_attrs[] = {
-	&dev_attr_ggs0.attr,
-	&dev_attr_ggs1.attr,
-	&dev_attr_ggs2.attr,
-	&dev_attr_ggs3.attr,
-	&dev_attr_pggs0.attr,
-	&dev_attr_pggs1.attr,
-	&dev_attr_pggs2.attr,
-	&dev_attr_pggs3.attr,
-	&dev_attr_shutdown_scope.attr,
-	&dev_attr_health_status.attr,
-	&dev_attr_feature_config_id.attr,
-	&dev_attr_feature_config_value.attr,
-	NULL,
-};
-
-ATTRIBUTE_GROUPS(zynqmp_firmware);
-
-static int zynqmp_firmware_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct zynqmp_devinfo *devinfo;
-	int ret;
-
-	ret = get_set_conduit_method(dev->of_node);
-	if (ret)
-		return ret;
-
-	ret = do_feature_check_call(PM_FEATURE_CHECK);
-	if (ret >= 0 && ((ret & FIRMWARE_VERSION_MASK) >= PM_API_VERSION_1))
-		feature_check_enabled = true;
-
-	devinfo = devm_kzalloc(dev, sizeof(*devinfo), GFP_KERNEL);
-	if (!devinfo)
-		return -ENOMEM;
-
-	devinfo->dev = dev;
-
-	platform_set_drvdata(pdev, devinfo);
-
-	/* Check PM API version number */
-	ret = zynqmp_pm_get_api_version(&pm_api_version);
-	if (ret)
-		return ret;
-
-	if (pm_api_version < ZYNQMP_PM_VERSION) {
-		panic("%s Platform Management API version error. Expected: v%d.%d - Found: v%d.%d\n",
-		      __func__,
-		      ZYNQMP_PM_VERSION_MAJOR, ZYNQMP_PM_VERSION_MINOR,
-		      pm_api_version >> 16, pm_api_version & 0xFFFF);
-	}
-
-	pr_info("%s Platform Management API v%d.%d\n", __func__,
-		pm_api_version >> 16, pm_api_version & 0xFFFF);
-
-	/* Get the Family code and sub family code of platform */
-	ret = zynqmp_pm_get_family_info(&pm_family_code, &pm_sub_family_code);
-	if (ret < 0)
-		return ret;
-
-	/* Check trustzone version number */
-	ret = zynqmp_pm_get_trustzone_version(&pm_tz_version);
-	if (ret)
-		panic("Legacy trustzone found without version support\n");
-
-	if (pm_tz_version < ZYNQMP_TZ_VERSION)
-		panic("%s Trustzone version error. Expected: v%d.%d - Found: v%d.%d\n",
-		      __func__,
-		      ZYNQMP_TZ_VERSION_MAJOR, ZYNQMP_TZ_VERSION_MINOR,
-		      pm_tz_version >> 16, pm_tz_version & 0xFFFF);
-
-	pr_info("%s Trustzone version v%d.%d\n", __func__,
-		pm_tz_version >> 16, pm_tz_version & 0xFFFF);
-
-	ret = mfd_add_devices(&pdev->dev, PLATFORM_DEVID_NONE, firmware_devs,
-			      ARRAY_SIZE(firmware_devs), NULL, 0, NULL);
-	if (ret) {
-		dev_err(&pdev->dev, "failed to add MFD devices %d\n", ret);
-		return ret;
-	}
-
-	zynqmp_pm_api_debugfs_init();
-
-	if (pm_family_code == VERSAL_FAMILY_CODE) {
-		em_dev = platform_device_register_data(&pdev->dev, "xlnx_event_manager",
-						       -1, NULL, 0);
-		if (IS_ERR(em_dev))
-			dev_err_probe(&pdev->dev, PTR_ERR(em_dev), "EM register fail with error\n");
-	}
-
-	return of_platform_populate(dev->of_node, NULL, NULL, dev);
-}
-
-static void zynqmp_firmware_remove(struct platform_device *pdev)
-{
-	struct pm_api_feature_data *feature_data;
-	struct hlist_node *tmp;
-	int i;
-
-	mfd_remove_devices(&pdev->dev);
-	zynqmp_pm_api_debugfs_exit();
-
-	hash_for_each_safe(pm_api_features_map, i, tmp, feature_data, hentry) {
-		hash_del(&feature_data->hentry);
-		kfree(feature_data);
-	}
-
-	platform_device_unregister(em_dev);
-}
-
-static const struct of_device_id zynqmp_firmware_of_match[] = {
-	{.compatible = "xlnx,zynqmp-firmware"},
-	{.compatible = "xlnx,versal-firmware"},
-	{},
-};
-MODULE_DEVICE_TABLE(of, zynqmp_firmware_of_match);
-
-static struct platform_driver zynqmp_firmware_driver = {
-	.driver = {
-		.name = "zynqmp_firmware",
-		.of_match_table = zynqmp_firmware_of_match,
-		.dev_groups = zynqmp_firmware_groups,
-	},
-	.probe = zynqmp_firmware_probe,
-	.remove_new = zynqmp_firmware_remove,
-};
-module_platform_driver(zynqmp_firmware_driver);
--- /dev/null
+++ linux-xlnx-2025.1/include/linux/firmware/amd-versal2-error-events.h	2025-07-02 12:01:39.256121500 +0900
@@ -0,0 +1,1470 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * AMD Versal2 Error Event Node IDs and Error Event Mask.
+ * Use with AMD Event Management Driver
+ *
+ * Copyright (C) 2025, Advanced Micro Devices, Inc.
+ *
+ * Naman Trivedi <naman.trivedimanojbhai@amd.com>
+ */
+
+#ifndef _FIRMWARE_AMD_VERSAL2_ERROR_EVENTS_H_
+#define _FIRMWARE_AMD_VERSAL2_ERROR_EVENTS_H_
+
+/*
+ * Error Event Node Ids
+ */
+#define VERSAL2_EVENT_ERROR_PMC_ERR1		(0x28100000U)
+#define VERSAL2_EVENT_ERROR_PMC_ERR2		(0x28104000U)
+#define VERSAL2_EVENT_ERROR_PMC_ERR3		(0x28108000U)
+#define VERSAL2_EVENT_ERROR_LPDSLCR_ERR1	(0x2810C000U)
+#define VERSAL2_EVENT_ERROR_LPDSLCR_ERR2	(0x28110000U)
+#define VERSAL2_EVENT_ERROR_LPDSLCR_ERR3	(0x28114000U)
+#define VERSAL2_EVENT_ERROR_LPDSLCR_ERR4	(0x28118000U)
+#define VERSAL2_EVENT_ERROR_SW_ERR		(0x2811C000U)
+
+/*
+ * Error Event Mask for register: PMC_ERR1_STATUS
+ * For Node_Id: VERSAL2_EVENT_ERROR_PMC_ERR1
+ */
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_BOOT_CR: Error event mask for PMC Boot
+ * Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_BOOT_CR				BIT(0)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_BOOT_NCR: Error event mask for PMC Boot
+ * Non-Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_BOOT_NCR				BIT(1)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FW_CR: Error event mask for PMC Firmware
+ * Boot Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FW_CR				BIT(2)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FW_NCR: Error event mask for PMC Firmware
+ * Boot Non-Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FW_NCR				BIT(3)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_GSW_CR: Error event mask for General
+ * Software Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_GSW_CR				BIT(4)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_GSW_NCR: Error event mask for General
+ * Software Non-Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_GSW_NCR				BIT(5)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_CFU: Error event mask for CFU Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_CFU				BIT(6)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_CFRAME: Error event mask for CFRAME Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_CFRAME				BIT(7)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_0: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_0				BIT(8)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_1: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_1				BIT(9)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DDRMB_CR: Error event mask for DDRMC MB
+ * Correctable ECC Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DDRMB_CR				BIT(10)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DDRMB_NCR: Error event mask for DDRMC MB
+ * Non-Correctable ECC Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DDRMB_NCR				BIT(11)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_NOCTYPE1_CR: Error event mask for NoC Type1
+ * Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_NOCTYPE1_CR			BIT(12)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_NOCTYPE1_NCR: Error event mask for NoC
+ * Type1 Non-Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_NOCTYPE1_NCR			BIT(13)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_NOCUSER: Error event mask for NoC User Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_NOCUSER				BIT(14)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_MMCM: Error event mask for MMCM Lock Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_MMCM				BIT(15)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_AIE_CR: Error event mask for ME
+ * Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_AIE_CR				BIT(16)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_AIE_NCR: Error event mask for ME
+ * Non-Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_AIE_NCR				BIT(17)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DDRMC_CR: Error event mask for DDRMC MC
+ * Correctable ECC Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DDRMC_CR				BIT(18)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DDRMC_NCR: Error event mask for DDRMC MC
+ * Non-Correctable ECC Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DDRMC_NCR				BIT(19)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_GT_CR: Error event mask for GT
+ * Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_GT_CR				BIT(20)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_GT_NCR: Error event mask for GT
+ * Non-Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_GT_NCR				BIT(21)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PL_SMON_CR: Error event mask for PL
+ * Sysmon Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PL_SMON_CR				BIT(22)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PL_SMON_NCR: Error event mask for PL
+ * Sysmon Non-Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PL_SMON_NCR			BIT(23)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PL0: Error event mask for User defined PL
+ * generic Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PL0				BIT(24)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PL1: Error event mask for User defined PL
+ * generic Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PL1				BIT(25)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PL2: Error event mask for User defined PL
+ * generic Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PL2				BIT(26)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PL3: Error event mask for User defined PL
+ * generic Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PL3				BIT(27)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_NPI_ROOT: Error event mask for NPI Root Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_NPI_ROOT				BIT(28)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SSIT3: Error event mask for SSIT Error from
+ * Slave SLR1.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SSIT3				BIT(29)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SSIT4: Error event mask for SSIT Error
+ * from Slave SLR2.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SSIT4				BIT(30)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SSIT5: Error event mask for SSIT Error from
+ * Slave SLR3.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SSIT5				BIT(31)
+
+/*
+ * Error Event Mask for register: PMC_ERR2_STATUS
+ * For Node_Id: VERSAL2_EVENT_ERROR_PMC_ERR2
+ */
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMC_APB: Error event mask for General purpose
+ * PMC Error, can be triggered by any of the following peripherals:
+ * - PMC Global Regsiters,- PMC Clock & Reset (CRP),- PMC IOU Secure SLCR,
+ * - PMC IOU SLCR,- BBRAM Controller,- PMC Analog Control Registers,
+ * - RTC Control Registers.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMC_APB				BIT(0)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMC_ROM: Error event mask for PMC ROM
+ * Validation Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMC_ROM				BIT(1)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_MB_FATAL0: Error event mask for PMC PPU0 MB
+ * TMR Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_MB_FATAL0				BIT(2)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_MB_FATAL1: Error event mask for PMC PPU1 MB
+ * TMR Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_MB_FATAL1				BIT(3)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_2: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_2				BIT(4)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMC_CR: Error event mask for PMC
+ * Correctable Errors,
+ * - PPU0 RAM correctable Error.
+ * - PPU1 instruction RAM correctable Error.
+ * - PPU1 data RAM correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMC_CR				BIT(5)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMC_NCR: Error event mask for PMC
+ * Non-Correctable Errors,
+ * - PPU0 RAM non-correctable Error.,PPU1 instruction RAM non-correctable Error.
+ * - PPU1 data RAM non-correctable Error.,PRAM non-correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMC_NCR				BIT(6)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON0: Error event mask for PMC
+ * Temperature Shutdown Alert and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[0].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON0				BIT(7)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON1: Error event mask for PMC
+ * Temperature Shutdown Alert and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[1].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON1				BIT(8)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON2: Error event mask for PMC
+ * Temperature Shutdown Alert and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[2].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON2				BIT(9)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON3: Error event mask for PMC
+ * Temperature Shutdown Alert and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[3].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON3				BIT(10)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON4: Error event mask for PMC
+ * Temperature Shutdown Alert and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[4].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON4				BIT(11)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON5: Error event mask for PMC
+ * Temperature Shutdown Alert and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[5].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON5				BIT(12)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON6: Error event mask for PMC
+ * Temperature Shutdown Alert and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[6].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON6				BIT(13)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON7: Error event mask for PMC
+ * Temperature Shutdown Alert and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[7].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON7				BIT(14)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON8: Error event mask for PMC
+ * Temperature Shutdown Alert and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[8].
+ * Indicates an over-temperature alarm.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON8				BIT(15)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON9: Error event mask for PMC
+ * Temperature Shutdown Alert and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[9].
+ * Indicates a device temperature alarm.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMC_SMON9				BIT(16)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_CFI: Error event mask for CFI Non-Correctable
+ * Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_CFI				BIT(17)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SEUCRC: Error event mask for CFRAME SEU CRC
+ * Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SEUCRC				BIT(18)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SEUECC: Error event mask for CFRAME SEU ECC
+ * Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SEUECC				BIT(19)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PMX_WWDT: Error event mask for PMC WWDT Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PMX_WWDT				BIT(20)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_3: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_3				BIT(21)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RTC_ALARM: Error event mask for RTC Alarm Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RTC_ALARM				BIT(22)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_NPLL: Error event mask for PMC NPLL Lock Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_NPLL				BIT(23)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PPLL: Error event mask for PMC PPLL Lock Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PPLL				BIT(24)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_CLK_MON: Error event mask for Clock Monitor
+ * Errors, collected from CRP's CLKMON_STATUS register.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_CLK_MON				BIT(25)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_4: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_4				BIT(26)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_INT_PMX_CORR_ERR: rror event mask for PMC
+ * interconnect correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_INT_PMX_CORR_ERR			BIT(27)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_INT_PMX_UNCORR_ERR: Error event mask for PMC
+ * interconnect uncorrectable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_INT_PMX_UNCORR_ERR			BIT(28)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SSIT0: Error event mask for Master SLR:
+ * - SSIT Error from Slave SLR1.
+ * - For Slave SLRs: SSIT Error0 from Master SLR.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SSIT0				BIT(29)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SSIT1: Error event mask for Master SLR:
+ * - SSIT Error from Slave SLR2.
+ * - For Slave SLRs: SSIT Error1 from Master SLR.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SSIT1				BIT(30)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SSIT2: Error event mask for Master SLR:
+ * - SSIT Error from Slave SLR3.
+ * - For Slave SLRs: SSIT Error2 from Master SLR.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SSIT2				BIT(31)
+
+/*
+ * Error Event Mask for register: PMC_ERR3_STATUS
+ * For Node_Id: VERSAL2_EVENT_ERROR_PMC_ERR3
+ */
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_IOU_CR: Error event mask for PMC IOU
+ * correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_IOU_CR				BIT(0)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_IOU_NCR: Error event mask for PMC IOU
+ * uncorrectable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_IOU_NCR				BIT(1)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DFX_UXPT_ACT: Error event mask for
+ * DFX unexpected activation.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DFX_UXPT_ACT			BIT(2)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DICE_CDI_PAR: Error event mask for DICE
+ * CDI SEED parity.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DICE_CDI_PAR			BIT(3)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DEVIK_PRIV: Error event mask for Device
+ * identity private key parity.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DEVIK_PRIV				BIT(4)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_NXTSW_CDI_PAR: Error event mask for
+ * Next SW CDI SEED parity.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_NXTSW_CDI_PAR			BIT(5)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DEVAK_PRIV: Error event mask for
+ * Device attestation private key parity.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DEVAK_PRIV				BIT(6)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DME_PUB_X: Error event mask for DME
+ * public key X component's parity.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DME_PUB_X				BIT(7)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DME_PUB_Y: Error event mask for DME
+ * public key Y component's parity.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DME_PUB_Y				BIT(8)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DEVAK_PUB_X: Error event mask for
+ * DEVAK public key X component's parity.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DEVAK_PUB_X			BIT(9)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DEVAK_PUB_Y: Error event mask for
+ * DEVAK public key Y component's parity.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DEVAK_PUB_Y			BIT(10)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DEVIK_PUB_X: Error event mask for
+ * DEVIK public key X component's parity.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DEVIK_PUB_X			BIT(11)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DEVIK_PUB_Y: Error event mask for
+ * DEVIK public key Y component's parity.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DEVIK_PUB_Y			BIT(12)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PCR_PAR: Error event mask for PCR parity.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PCR_PAR				BIT(13)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_PSX_EAM_E0: Error event mask for
+ * LPX detected EAM Err group 0. Sent to PL via signal
+ * pmc_error_to_pl[55], readable from jtag register JTAG_ERROR_STATUS[55].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_PSX_EAM_E0				BIT(14)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_PSX_EAM_E1: Error event mask for LPX
+ * detected EAM Err group 1. ent to PL via signal pmc_error_to_pl[54],
+ * readable from jtag register JTAG_ERROR_STATUS[54].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_PSX_EAM_E1				BIT(15)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_PSX_EAM_E2: Error event mask for LPX
+ * detected EAM Err group 2. Sent to PL via signal pmc_error_to_pl[20],
+ * readable from jtag register JTAG_ERROR_STATUS[20].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_PSX_EAM_E2				BIT(16)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_PSX_EAM_E3: Error event mask for LPX
+ * detected EAM Err group 3. Sent to PL via signal pmc_error_to_pl[19],
+ * readable from jtag register JTAG_ERROR_STATUS[19].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_PSX_EAM_E3				BIT(17)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_ASU_EAM_GD: Error event mask ASU Glitch
+ * Detect Valid. Sent to PL via signal pmc_error_to_pl[18],
+ * readable from jtag register JTAG_ERROR_STATUS[18].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_ASU_EAM_GD				BIT(18)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_PMC_EAM_GD: Error event mask PMC Glitch
+ * Detect Valid. Sent to PL via signal pmc_error_to_pl[64],
+ * readable from jtag register JTAG_ERROR_STATUS[155].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_PMC_EAM_GD				BIT(19)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_PMC_EAM_SMIRQ0: Error event mask SYSMON
+ * IRQ[0]. Sent to PL via signal pmc_error_to_pl[65], readable from
+ * jtag register JTAG_ERROR_STATUS[156].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_PMC_EAM_SMIRQ0				BIT(20)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_PMC_EAM_SMIRQ1: Error event mask SYSMON
+ * IRQ[1]. Sent to PL via signal pmc_error_to_pl[66], readable from
+ * jtag register JTAG_ERROR_STATUS[157].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_PMC_EAM_SMIRQ1				BIT(21)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_PMC_EAM_PRAM: Error event mask PRAM IRQ.
+ * Sent to PL via signal pmc_error_to_pl[67],
+ * readable from jtag register JTAG_ERROR_STATUS[158].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_PMC_EAM_PRAM				BIT(22)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_PMC_EAM_AGERR: Error event mask AES GO SW
+ * Programming Error. Sent to PL via signal pmc_error_to_pl[68],
+ * readable from jtag register JTAG_ERROR_STATUS[159].
+ */
+#define XPM_VERSAL2_EVENT_ERROR_PMC_EAM_AGERR				BIT(23)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_PMC_EAM_UFSFE: Error event mask UFSHC Fatal
+ * Error. Sent to PL via signal pmc_error_to_pl[69], readable from
+ * jtag register JTAG_ERROR_STATUS.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_PMC_EAM_UFSFE				BIT(24)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_5: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_5				BIT(25)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_6: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_6				BIT(26)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_7: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_7				BIT(27)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_8: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_8				BIT(28)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_9: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_9				BIT(29)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_10: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_10				BIT(30)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_11: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_11				BIT(31)
+
+/*
+ * Error Event Mask for register: EAM_ERR0_STATUS
+ * For Node_Id: VERSAL2_EVENT_ERROR_LPDSLCR_ERR1
+ */
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PS_SW_CR: Error event mask for PS
+ * Software Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PS_SW_CR				BIT(0)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PS_SW_NCR: Error event mask for PS
+ * Software Non-Correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PS_SW_NCR				BIT(1)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_USB_ERR: Error event mask for
+ * aggregated LPX USB Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_USB_ERR				BIT(2)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_LPX_DFX: Error event mask for
+ * aggregated LPX DFX controllers * unexpected activation Error
+ * (from slcr reg LPX_DFX_ERR_ISR).
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_LPX_DFX				BIT(3)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_UFSHC_FE_IRQ: Error event mask for
+ * UFSHC FE IRQ Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_UFSHC_FE_IRQ			BIT(4)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_APLL1_LOCK: Error event mask
+ * for APLL1 lock Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_APLL1_LOCK				BIT(5)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_APLL2_LOCK: Error event mask for
+ * APLL2 lock Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_APLL2_LOCK				BIT(6)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPLL_LOCK: Error event mask for RPLL
+ * Lock Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPLL_LOCK				BIT(7)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FLXPLL_LOCK: Error event mask for
+ * FLXPLL Lock Errors. The Error can be unmasked after the PLL is
+ * locked to alert when the PLL loses lock.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FLXPLL_LOCK			BIT(8)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_INT_LPXASILB_CR: Error event mask for
+ * aggregated LPX ASIL B correctable errors from OCMASILB, LPXASILB, IOU.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_INT_LPXASILB_CR			BIT(9)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_INT_LPXASILB_NCR: Error event mask for
+ * aggregated LPX ASIL B uncorrectable errors from OCMASILB, LPXASILB, IOU.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_INT_LPXASILB_NCR			BIT(10)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_INT_LPXASILD_CR: Error event mask for
+ * aggregated LPX ASIL D correctable errors from OCMASILD, LPXASILD.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_INT_LPXASILD_CR			BIT(11)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_INT_LPXASILD_NCR: Error event mask for
+ * aggregated LPX ASIL D uncorrectable errors from OCMASILD, LPXASILD.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_INT_LPXASILD_NCR			BIT(12)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_INT_FPXASILD_CR: Error event mask for
+ * aggregated FPX ASIL D correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_INT_FPXASILD_CR			BIT(13)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_INT_FPXASILD_NCR: Error event mask for
+ * aggregated FPX ASIL D uncorrectable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_INT_FPXASILD_NCR			BIT(14)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_INT_FPXASILB_CR: Error event mask for
+ * aggregated FPX ASIL B correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_INT_FPXASILB_CR			BIT(15)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_INT_FPXASILB_NCR: Error event mask for
+ * aggregated FPX ASIL B uncorrectable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_INT_FPXASILB_NCR			BIT(16)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_INT_SPLIT_CR: Error event mask for
+ * splitter interconnect correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_INT_SPLIT_CR			BIT(17)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_INT_SPLIT_NCR: Error event mask for
+ * splitter interconnect uncorrectable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_INT_SPLIT_NCR			BIT(18)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_12: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_12				BIT(19)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_13: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_13				BIT(20)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_14: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_14				BIT(21)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_15: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_15				BIT(22)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_NOC_NMU_FIREWALL_WR_ERR: Error event mask
+ * for Firewall write Errors from NOC NMUs.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_NOC_NMU_FIREWALL_WR_ERR		BIT(23)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_NOC_NMU_FIREWALL_RD_ERR: Error event
+ * mask for Firewall read Error from NOC NMU.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_NOC_NMU_FIREWALL_RD_ERR		BIT(24)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_NOC_NSU_FIREWALL_ERR: Error event mask
+ * for Firewall Error from NOC NSU.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_NOC_NSU_FIREWALL_ERR		BIT(25)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_GIC_FMU_ERR: Error event mask for GIC_FMU_ERR.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_GIC_FMU_ERR			BIT(26)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_GIC_FMU_FAULT: Error event mask for
+ * GIC_FMU_FAULT.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_GIC_FMU_FAULT			BIT(27)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_16: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_16				BIT(28)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_17: Error event mask for reserved Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RSVD_17				BIT(29)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_IPI_ERR: Error event mask for
+ * aggregated IPI Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_IPI_ERR				BIT(30)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_CPI: Error event mask for
+ * aggregated CPI Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_CPI				BIT(31)
+
+/*
+ * Event Mask for register: EAM_ERR1_STATUS
+ * For Node_Id: VERSAL2_EVENT_ERROR_LPDSLCR_ERR2
+ */
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_WDT0: Error event mask for FPD WDT0 Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_WDT0				BIT(0)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_WDT1: Error event mask for FPD WDT1 Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_WDT1				BIT(1)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_WDT2: Error event mask for FPD WDT2 Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_WDT2				BIT(2)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_WDT3: Error event mask for FPD WDT3 Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_WDT3				BIT(3)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PSXC_SPLITTER0_NON_FATAL_ERR: Error
+ * event mask for Non Fatal Error for Splitter 0.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PSXC_SPLITTER0_NON_FATAL_ERR	BIT(4)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PSXC_SPLITTER1_NON_FATAL_ERR: Error
+ * event mask for Non Fatal Error for Splitter 1.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PSXC_SPLITTER1_NON_FATAL_ERR	BIT(5)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PSXC_SPLITTER2_NON_FATAL_ERR: Error
+ * event mask for Non Fatal Error for Splitter 2.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PSXC_SPLITTER2_NON_FATAL_ERR	BIT(6)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PSXC_SPLITTER3_NON_FATAL_ERR: Error
+ * event mask for Non Fatal Error for Splitter 3.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PSXC_SPLITTER3_NON_FATAL_ERR	BIT(7)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PSXC_SPLITTER_FATAL_ERR: Error event
+ * mask for aggregated Fatal Error For Splitter0-3.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PSXC_SPLITTER_FATAL_ERR		BIT(8)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_GIC_ERR: Error event mask for
+ * aggregated GIC Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_GIC_ERR				BIT(9)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_GIC_FAULT: Error event mask for
+ * aggregated GIC fault.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_GIC_FAULT				BIT(10)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_CMN_FAULT: Error event mask for
+ * aggregated CMN faults from all PD domains and FMU
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_CMN_FAULT				BIT(11)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_CMN_ERR: Error event mask for
+ * aggregated CMN Errors from all PD domains and FMU.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_CMN_ERR				BIT(12)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_ACP_ERR: Error event mask for
+ * aggregated Errors from ACP0 + ACP1.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_ACP_ERR				BIT(13)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU0_ERI: Error event mask for
+ * APU Cluster 0 fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU0_ERI			BIT(14)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU0_FHI: Error event mask for
+ * APU Cluster 0 non-fatal/fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU0_FHI			BIT(15)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU1_ERI: Error event mask for
+ * APU Cluster 1 Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU1_ERI			BIT(16)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU1_FHI: Error event mask for
+ * APU Cluster 1 non-fatal/fatal.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU1_FHI			BIT(17)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU2_ERI: Error event mask for
+ * APU Cluster 2 Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU2_ERI			BIT(18)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU2_FHI: Error event mask for APU
+ * Cluster 2 non-fatal/fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU2_FHI			BIT(19)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU3_ERI: Error event mask for
+ * APU Cluster 3 Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU3_ERI			BIT(20)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU3_FHI: Error event mask for APU
+ * Cluster 3 non-fatal/fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_APU3_FHI			BIT(21)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_MMU_ERR: Error event mask for
+ * aggregated MMU Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_MMU_ERR			BIT(22)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_MMU_FAULT: Error event mask for
+ * aggregated MMU fault.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_MMU_FAULT			BIT(23)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_SLCR_ERR: Error event mask for
+ * SLCR Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_SLCR_ERR			BIT(24)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_SLCR_SECURE_ERR: Error event mask for
+ * SLCR SECURE Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_SLCR_SECURE_ERR		BIT(25)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPX_AFIFM0_NONFATAL_ERR: Error event mask for
+ * Non Fatal Error from AFI FM0 in FPX.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPX_AFIFM0_NONFATAL_ERR		BIT(26)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPX_AFIFM1_NONFATAL_ERR: Error event mask for
+ * Non Fatal Error from AFI FM1 in FPX.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPX_AFIFM1_NONFATAL_ERR		BIT(27)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPX_AFIFM2_NONFATAL_ERR: Error event mask for
+ * Non Fatal Error from AFI FM2 in FPx.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPX_AFIFM2_NONFATAL_ERR		BIT(28)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPX_AFIFM3_NONFATAL_ERR: Error event mask for
+ * Non Fatal Error from AFI FM3 in FPX.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPX_AFIFM3_NONFATAL_ERR		BIT(29)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_BFPX_AFIFS_CORR_ERR: Error event mask for
+ * FPXAFIFS Corr Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_BFPX_AFIFS_CORR_ERR		BIT(30)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPX_AFIFS_UNCORR_ERR: Error event mask for
+ * FPXAFIFS UnCorr Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPX_AFIFS_UNCORR_ERR		BIT(31)
+
+/*
+ * Error Event Mask for register: EAM_ERR2_STATUS
+ * For Node_Id: VERSAL2_EVENT_ERROR_LPDSLCR_ERR3
+ */
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUA_CORE_CLUSTER_FATAL: Error event mask for
+ * aggregated RPU Cluster A cluster + core Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUA_CORE_CLUSTER_FATAL		BIT(0)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUA_CORE0_NON_FATAL: Error event mask for
+ * RPUA Core0 NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUA_CORE0_NON_FATAL		BIT(1)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUA_CORE1_NON_FATAL: Error event mask for
+ * RPUA Core1 NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUA_CORE1_NON_FATAL		BIT(2)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUB_CORE_CLUSTER_FATAL: Error event mask for
+ * aggregated RPU Cluster B cluster + core Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUB_CORE_CLUSTER_FATAL		BIT(3)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUB_CORE0_NON_FATAL: Error event mask for
+ * RPUB Core0 NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUB_CORE0_NON_FATAL		BIT(4)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUB_CORE1_NON_FATAL: Error event mask for
+ * RPUB Core1 NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUB_CORE1_NON_FATAL		BIT(5)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUC_CORE_CLUSTER_FATAL: Error event mask for
+ * aggregated RPU Cluster C cluster + core Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUC_CORE_CLUSTER_FATAL		BIT(6)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUC_CORE0_NON_FATAL: Error event mask for
+ * RPUC Core0 NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUC_CORE0_NON_FATAL		BIT(7)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUC_CORE1_NON_FATAL: Error event mask for
+ * RPUC Core1 NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUC_CORE1_NON_FATAL		BIT(8)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUD_CORE_CLUSTER_FATAL: Error event mask for
+ * aggregated RPU Cluster D cluster + core Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUD_CORE_CLUSTER_FATAL		BIT(9)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUD_CORE0_NON_FATAL: Error event mask for
+ * RPUD Core0 NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUD_CORE0_NON_FATAL		BIT(10)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUD_CORE1_NON_FATAL: Error event mask for
+ * RPUD Core1 NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUD_CORE1_NON_FATAL		BIT(11)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUE_CORE_CLUSTER_FATAL: Error event mask for
+ * aggregated RPU Cluster E cluster + core Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUE_CORE_CLUSTER_FATAL		BIT(12)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUE_CORE0_NON_FATAL: Error event mask
+ * for RPUE Core0 NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUE_CORE0_NON_FATAL		BIT(13)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPUE_CORE1_NON_FATAL: Error event mask
+ * for RPUE Core1 NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPUE_CORE1_NON_FATAL		BIT(14)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_RPU_PCIL_ERR: Error event mask for PCIL ERR
+ * FOR RPU Clusters.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_RPU_PCIL_ERR			BIT(15)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_OCM0_NONFATAL_ERR: Error event mask for OCM
+ * Bank0 NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_OCM0_NONFATAL_ERR			BIT(16)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_OCM0_FATAL_ERR: Error event mask for
+ * OCM Bank0 Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_OCM0_FATAL_ERR			BIT(17)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_OCM1_NONFATAL_ERR: Error event mask
+ * for OCM Bank1 NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_OCM1_NONFATAL_ERR			BIT(18)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_OCM1_FATAL_ERR: Error event mask for
+ * OCM Bank1 Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_OCM1_FATAL_ERR			BIT(19)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_OCM2_NONFATAL_ERR: Error event mask
+ * for OCM Bank2 NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_OCM2_NONFATAL_ERR			BIT(20)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_OCM2_FATAL_ERR: Error event mask for OCM
+ * Bank2 Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_OCM2_FATAL_ERR			BIT(21)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_OCM3_NONFATAL_ERR: Error event mask for OCM
+ * Bank3 NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_OCM3_NONFATAL_ERR			BIT(22)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_OCM3_FATAL_ERR: Error event mask for OCM Bank3
+ * Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_OCM3_FATAL_ERR			BIT(23)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_LPX_WWDT0: Error event mask for LPX WDT0 Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_LPX_WWDT0				BIT(24)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_LPX_WWDT1: Error event mask for LPX WDT1 Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_LPX_WWDT1				BIT(25)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_LPX_WWDT2: Error event mask for LPX WDT2
+ * Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_LPX_WWDT2				BIT(26)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_LPX_WWDT3: Error event mask for LPX WDT3
+ * Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_LPX_WWDT3				BIT(27)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_LPX_WWDT4: Error event mask for LPX WDT4
+ * Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_LPX_WWDT4				BIT(28)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_LS_ERR: Error event mask for ADMA LS
+ * Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_LS_ERR			BIT(29)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_LPX_GLITCH_DET0: Error event mask for
+ * LPX Glitch Detector0 glitch detected.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_LPX_GLITCH_DET0			BIT(30)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_LPX_GLITCH_DET1: Error event mask for
+ * LPX Glitch Detector1 glitch detected.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_LPX_GLITCH_DET1			BIT(31)
+
+/*
+ * Event Mask for register: EAM_ERR3_STATUS
+ * For Node_Id: VERSAL2_EVENT_ERROR_LPDSLCR_ERR4
+ */
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_FPD_CRF: Error event mask for FPD
+ * Reset Monitor ERROR.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_FPD_CRF				BIT(0)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_LPD_MON_ERR: Error event mask for LPD
+ * reset and Clock Monitor Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_LPD_MON_ERR			BIT(1)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_AFIFM_FATAL_ERR: Error event mask for
+ * Fatal Error from all AFI FM.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_AFIFM_FATAL_ERR			BIT(2)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_LPX_AFIFM_NONFATAL_ERR: Error event
+ * mask for LPX AFI FM Non Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_LPX_AFIFM_NONFATAL_ERR		BIT(3)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_LPD_ASU_FATAL: Error event mask for
+ * aggregated ASU + ASU_PL Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_LPD_ASU_FATAL			BIT(4)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_LPD_ASU_NON_FATAL: Error event mask for
+ * aggregated ASU + ASU_PL NonFatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_LPD_ASU_NON_FATAL			BIT(5)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_LPX_AFIFS_CORR_ERR: Error event mask for
+ * LPX AFI FS Non Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_LPX_AFIFS_CORR_ERR			BIT(6)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_LPX_AFIFS_UNCORR_ERR: Error event mask for
+ * LPX AFI FS Fatal Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_LPX_AFIFS_UNCORR_ERR		BIT(7)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_MMI_CORR_EVENT: Error event mask for MMI
+ * top level correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_MMI_CORR_EVENT			BIT(8)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_MMI_UNCORR_EVENT: Error event mask for
+ * MMI top level uncorrectable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_MMI_UNCORR_EVENT			BIT(9)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_MMI_GPU_COR_EVENT: Error event mask for
+ * MMI gpu correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_MMI_GPU_COR_EVENT			BIT(10)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_MMI_PCIE0_COR_EVENT: Error event mask for
+ * MMI pcie0 correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_MMI_PCIE0_COR_EVENT		BIT(11)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_MMI_PCIE1_COR_EVENT: Error event mask
+ * for MMI pcie1 correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_MMI_PCIE1_COR_EVENT		BIT(12)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_MMI_GEM_COR_EVENT: Error event mask
+ * for MMI gem correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_MMI_GEM_COR_EVENT			BIT(13)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_MMI_DC_COR_EVENT: Error event mask for MMI
+ * dc correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_MMI_DC_COR_EVENT			BIT(14)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_MMI_UDH_COR_EVENT: Error event mask for MMI
+ * udh correctable Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_MMI_UDH_COR_EVENT			BIT(15)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR1: Error event mask for ADMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR1				BIT(16)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR2: Error event mask for ADMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR2				BIT(17)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR3: Error event mask for ADMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR3				BIT(18)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR4: Error event mask for ADMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR4				BIT(19)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR5: Error event mask for ADMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR5				BIT(20)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR6: Error event mask for ADMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR6				BIT(21)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR7: Error event mask for ADMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR7				BIT(22)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR8:Error event mask for ADMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_ADMA_ERR8				BIT(23)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR1: Error event mask for SDMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR1				BIT(24)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR2: Error event mask for SDMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR2				BIT(25)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR3: Error event mask for SDMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR3				BIT(26)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR4: Error event mask for SDMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR4				BIT(27)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR5: Error event mask for SDMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR5				BIT(28)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR6: Error event mask for SDMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR6				BIT(29)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR7: Error event mask for SDMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR7				BIT(30)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR8: Error event mask for SDMA per
+ * channel Error.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_SDMA_ERR8				BIT(31)
+
+/*
+ * Error Event Mask belongs to SW ERR node,
+ * For Node_Id: VERSAL2_EVENT_ERROR_SW_ERR
+ */
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_HB_MON_0: Health Boot Monitoring Errors.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_HB_MON_0				BIT(0)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_HB_MON_1: Health Boot Monitoring Errors.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_HB_MON_1				BIT(1)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_HB_MON_2: Health Boot Monitoring Errors.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_HB_MON_2				BIT(2)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_HB_MON_3: Health Boot Monitoring Errors.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_HB_MON_3				BIT(3)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PLM_EXCEPTION: Error event mask for PLM
+ * Exception.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PLM_EXCEPTION			BIT(4)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_DEV_STATE_CHANGE: Error event mask for
+ * Dev state change.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_DEV_STATE_CHANGE			BIT(5)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_PCR_LOG_UPDATE: Error event mask for PCR
+ * Log update.
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_PCR_LOG_UPDATE			BIT(6)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_XSEM_CRAM_CE: Error event mask for handling
+ * correctable Error in Versal Configuration RAM which is reported by
+ * Soft Error Mitigation (XilSEM).
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_XSEM_CRAM_CE			BIT(7)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_XSEM_CRAM_UE: Error event mask for handling
+ * uncorrectable Error in Versal Configuration RAM which is reported by
+ * Soft Error Mitigation (XilSEM).
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_XSEM_CRAM_UE			BIT(8)
+
+/**
+ * XPM_VERSAL2_EVENT_ERROR_MASK_XSEM_NPI_UE: Error event mask for handling
+ * uncorrectable Error in Versal NoC programming interface (NPI).
+ * register which is reported by Soft Error Mitigation (XilSEM).
+ */
+#define XPM_VERSAL2_EVENT_ERROR_MASK_XSEM_NPI_UE			BIT(9)
+
+#endif /* _FIRMWARE_AMD_VERSAL2_ERROR_EVENTS_H_ */
--- /dev/null
+++ linux-xlnx-2025.1/include/linux/firmware/xlnx-versal-error-events.h	2025-07-02 12:01:39.266144700 +0900
@@ -0,0 +1,662 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Xilinx Versal Error Event Node IDs and Error Event Mask.
+ * Use with Xilinx Event Management Driver
+ *
+ * Copyright (C) 2021-2022 Xilinx
+ * Copyright (C) 2023 Advanced Micro Devices, Inc.
+ *
+ * Abhyuday Godhasara <abhyuday.godhasara@xilinx.com>
+ */
+
+#ifndef _FIRMWARE_XLNX_VERSAL_ERROR_EVENTS_H_
+#define _FIRMWARE_XLNX_VERSAL_ERROR_EVENTS_H_
+
+/*
+ * Error Event Node Ids
+ */
+#define VERSAL_EVENT_ERROR_PMC_ERR1	(0x28100000U)
+#define VERSAL_EVENT_ERROR_PMC_ERR2	(0x28104000U)
+#define VERSAL_EVENT_ERROR_PSM_ERR1	(0x28108000U)
+#define VERSAL_EVENT_ERROR_PSM_ERR2	(0x2810C000U)
+#define VERSAL_EVENT_ERROR_SW_ERR	(0x28110000U)
+
+/*
+ * Error Event Mask belongs to PMC ERR2 node.
+ * For which Node_Id = VERSAL_EVENT_ERROR_PMC_ERR2
+ */
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_BOOT_CR: Error event mask for PMC Boot Correctable Error.
+ * Set by ROM code during ROM execution during Boot.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_BOOT_CR		BIT(0)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_BOOT_NCR: Error event mask for PMC Boot Non-Correctable Error.
+ * Set by ROM code during ROM execution during Boot.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_BOOT_NCR		BIT(1)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_FW_CR: Error event mask for PMC Firmware Boot Correctable Error.
+ * Set by PLM during firmware execution during Boot.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_FW_CR		BIT(2)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_FW_NCR: Error event mask for PMC Firmware Boot Non-Correctable Error.
+ * Set by PLM during firmware execution during Boot.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_FW_NCR		BIT(3)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_GSW_CR: Error event mask for General Software Correctable Error.
+ * Set by any processors after Boot.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_GSW_CR		BIT(4)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_GSW_NCR: Error event mask for General Software Non-Correctable Error.
+ * Set by any processors after Boot.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_GSW_NCR		BIT(5)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_CFU: Error event mask for CFU Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_CFU		BIT(6)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_CFRAME: Error event mask for CFRAME Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_CFRAME		BIT(7)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMC_PSM_CR: Error event mask for PSM Correctable Error,
+ * Summary from PSM Error Management.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMC_PSM_CR		BIT(8)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMC_PSM_NCR: Error event mask for PSM Non-Correctable Error,
+ * Summary from PSM Error Management.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMC_PSM_NCR	BIT(9)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_DDRMB_CR: Error event mask for DDRMC MB Correctable ECC Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_DDRMB_CR		BIT(10)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_DDRMB_NCR: Error event mask for DDRMC MB Non-Correctable ECC Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_DDRMB_NCR		BIT(11)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_NOCTYPE1_CR: Error event mask for NoC Type1 Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_NOCTYPE1_CR	BIT(12)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_NOCTYPE1_NCR: Error event mask for NoC Type1 Non-Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_NOCTYPE1_NCR	BIT(13)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_NOCUSER: Error event mask for NoC User Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_NOCUSER		BIT(14)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_MMCM: Error event mask for MMCM Lock Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_MMCM		BIT(15)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_AIE_CR: Error event mask for ME Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_AIE_CR		BIT(16)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_AIE_NCR: Error event mask for ME Non-Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_AIE_NCR		BIT(17)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_DDRMC_CR: Error event mask for DDRMC MC Correctable ECC Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_DDRMC_CR		BIT(18)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_DDRMC_NCR: Error event mask for DDRMC MC Non-Correctable ECC Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_DDRMC_NCR		BIT(19)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_GT_CR: Error event mask for GT Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_GT_CR		BIT(20)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_GT_NCR: Error event mask for GT Non-Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_GT_NCR		BIT(21)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PLSMON_CR: Error event mask for PL Sysmon Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PLSMON_CR		BIT(22)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PLSMON_NCR: Error event mask for PL Sysmon Non-Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PLSMON_NCR		BIT(23)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PL0: Error event mask for User defined PL generic error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PL0		BIT(24)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PL1: Error event mask for User defined PL generic error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PL1		BIT(25)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PL2: Error event mask for User defined PL generic error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PL2		BIT(26)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PL3: Error event mask for User defined PL generic error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PL3		BIT(27)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_NPIROOT: Error event mask for NPI Root Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_NPIROOT		BIT(28)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_SSIT3: Error event mask for SSIT Error from Slave SLR1,
+ * Only used in Master SLR.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_SSIT3		BIT(29)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_SSIT4: Error event mask for SSIT Error from Slave SLR2,
+ * Only used in Master SLR.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_SSIT4		BIT(30)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_SSIT5: Error event mask for SSIT Error from Slave SLR3,
+ * Only used in Master SLR.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_SSIT5		BIT(31)
+
+/*
+ * Error Event Mask belongs to PMC ERR2 node,
+ * For which Node_Id = VERSAL_EVENT_ERROR_PMC_ERR2
+ */
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMCAPB: Error event mask for General purpose PMC error,
+ * can be triggered by any of the following peripherals:,
+ * - PMC Global Regsiters,- PMC Clock & Reset (CRP),- PMC IOU Secure SLCR,
+ * - PMC IOU SLCR,- BBRAM Controller,- PMC Analog Control Registers,
+ * - RTC Control Registers.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMCAPB		BIT(0)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMCROM: Error event mask for PMC ROM Validation Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMCROM		BIT(1)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_MB_FATAL0: Error event mask for PMC PPU0 MB TMR Fatal Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_MB_FATAL0		BIT(2)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_MB_FATAL1: Error event mask for PMC PPU1 MB TMR Fatal Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_MB_FATAL1		BIT(3)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMCPAR: Error event mask for PMC Switch and PMC IOU Parity Errors.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMCPAR		BIT(4)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMC_CR: Error event mask for PMC Correctable Errors,
+ * PPU0 RAM correctable error.,PPU1 instruction RAM correctable error.,
+ * PPU1 data RAM correctable error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMC_CR		BIT(5)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMC_NCR: Error event mask for PMC Non-Correctable Errors,
+ * PPU0 RAM non-correctable error.,PPU1 instruction RAM non-correctable error.,
+ * PPU1 data RAM non-correctable error.,PRAM non-correctable error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMC_NCR		BIT(6)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMCSMON0: Error event mask for PMC Temperature Shutdown Alert
+ * and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[0].
+ * Indicates an alarm condition on any of SUPPLY0 to SUPPLY31.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMCSMON0		BIT(7)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMCSMON1: Error event mask for PMC Temperature Shutdown Alert
+ * and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[1].
+ * Indicates an alarm condition on any of SUPPLY32 to SUPPLY63.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMCSMON1		BIT(8)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMCSMON2: Error event mask for PMC Temperature Shutdown Alert
+ * and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[2].
+ * Indicates an alarm condition on any of SUPPLY64 to SUPPLY95.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMCSMON2		BIT(9)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMCSMON3: Error event mask for PMC Temperature Shutdown Alert
+ * and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[3].
+ * Indicates an alarm condition on any of SUPPLY96 to SUPPLY127.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMCSMON3		BIT(10)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMCSMON4: Error event mask for PMC Temperature Shutdown Alert
+ * and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[4].
+ * Indicates an alarm condition on any of SUPPLY128 to SUPPLY159.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMCSMON4		BIT(11)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMCSMON8: Error event mask for PMC Temperature Shutdown Alert
+ * and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[8].
+ * Indicates an over-temperature alarm.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMCSMON8		BIT(15)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMCSMON9: Error event mask for PMC Temperature Shutdown Alert
+ * and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[9].
+ * Indicates a device temperature alarm.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMCSMON9		BIT(16)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_CFI: Error event mask for CFI Non-Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_CFI		BIT(17)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_SEUCRC: Error event mask for CFRAME SEU CRC Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_SEUCRC		BIT(18)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_SEUECC: Error event mask for CFRAME SEU ECC Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_SEUECC		BIT(19)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_RTCALARM: Error event mask for RTC Alarm Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_RTCALARM		BIT(22)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_NPLL: Error event mask for PMC NPLL Lock Error,
+ * This error can be unmasked after the NPLL is locked to alert when the
+ * NPLL loses lock.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_NPLL		BIT(23)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PPLL: Error event mask for PMC PPLL Lock Error,
+ * This error can be unmasked after the PPLL is locked to alert when the
+ * PPLL loses lock.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PPLL		BIT(24)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_CLKMON: Error event mask for Clock Monitor Errors.,
+ * Collected from CRP's CLKMON_STATUS register.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_CLKMON		BIT(25)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMCTO: Error event mask for PMC Interconnect Timeout Errors.,
+ * Collected from:,Interconnect mission interrupt status register.,
+ * Interconnect latent status register.,Timeout interrupt status register
+ * for SERBs.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMCTO		BIT(26)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMCXMPU: Error event mask for PMC XMPU Errors:,
+ * Register access error on APB., Read permission violation.,
+ * Write permission violation.,Security violation.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMCXMPU		BIT(27)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PMCXPPU: Error event mask for PMC XPPU Errors:,
+ * Register access error on APB., Master ID not found.,Read permission violation.,
+ * Master ID parity error., Master ID access violation.,
+ * TrustZone violation.,Aperture parity error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PMCXPPU		BIT(28)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_SSIT0: Error event mask for Master SLR:
+ * SSIT Error from Slave SLR1.,
+ * For Slave SLRs: SSIT Error0 from Master SLR.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_SSIT0		BIT(29)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_SSIT1: Error event mask for Master SLR:
+ * SSIT Error from Slave SLR2.,
+ * For Slave SLRs: SSIT Error1 from Master SLR.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_SSIT1		BIT(30)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_SSIT2: Error event mask for Master SLR:
+ * SSIT Error from Slave SLR3.,
+ * For Slave SLRs: SSIT Error2 from Master SLR.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_SSIT2		BIT(31)
+
+/*
+ * Error Event Mask belongs to PSM ERR1 node,
+ * For which Node_Id = VERSAL_EVENT_ERROR_PSM_ERR1
+ */
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PS_SW_CR: Error event mask for PS Software can write to
+ * trigger register to generate this Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PS_SW_CR		BIT(0)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PS_SW_NCR: Error event mask for PS Software can write to
+ * trigger register to generate this Non-Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PS_SW_NCR		BIT(1)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PSM_B_CR: Error event mask for PSM Firmware can write to
+ * trigger register to generate this Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PSM_B_CR		BIT(2)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PSM_B_NCR: Error event mask for PSM Firmware can write to
+ * trigger register to generate this Non-Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PSM_B_NCR		BIT(3)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_MB_FATAL: Error event mask for Or of MB Fatal1, Fatal2, Fatal3 Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_MB_FATAL		BIT(4)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PSM_CR: Error event mask for PSM Correctable.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PSM_CR		BIT(5)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PSM_NCR: Error event mask for PSM Non-Correctable.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PSM_NCR		BIT(6)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_OCM_ECC: Error event mask for Non-Correctable ECC Error
+ * during an OCM access.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_OCM_ECC		BIT(7)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_L2_ECC: Error event mask for Non-Correctable ECC Error
+ * during APU L2 Cache access.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_L2_ECC		BIT(8)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_RPU_ECC: Error event mask for ECC Errors during a RPU memory access.
+ * Floating-point operation exceptions. RPU REG APB error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_RPU_ECC		BIT(9)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_RPU_LS: Error event mask for RPU Lockstep Errors from R5_0.
+ * The Lockstep error is not initialized until RPU clock is enabled;
+ * therefore, error outcomes are masked by default and are expected to be
+ * unmasked after processor clock is enabled and before its reset is released.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_RPU_LS		BIT(10)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_RPU_CCF: Error event mask for RPU Common Cause Failures ORed together.
+ * The CCF Error register with the masking capability has to reside in the RPU.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_RPU_CCF		BIT(11)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_GIC_AXI: Error event mask for APU GIC AXI Error by the AXI4 master port,
+ * such as SLVERR or DECERR.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_GIC_AXI		BIT(12)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_GIC_ECC: Error event mask for APU GIC ECC Error,
+ * a Non-Correctable ECC error occurred in any ECC-protected RAM.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_GIC_ECC		BIT(13)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_APLL_LOCK: Error event mask for APLL Lock Errors.
+ * The error can be unmasked after the PLL is locked to alert when the
+ * PLL loses lock.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_APLL_LOCK		BIT(14)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_RPLL_LOCK: Error event mask for RPLL Lock Errors.
+ * The error can be unmasked after the PLL is locked to alert when the
+ * PLL loses lock.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_RPLL_LOCK		BIT(15)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_CPM_CR: Error event mask for CPM Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_CPM_CR		BIT(16)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_CPM_NCR: Error event mask for CPM Non-Correctable Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_CPM_NCR		BIT(17)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_LPD_APB: Error event mask for LPD APB Errors
+ * from:,IPI REG,USB2 REG,CRL REG,LPD AFIFM4 REG,LPD IOU REG,
+ * LPD IOU SECURE SLCR REG,LPD SLCR REG,LPD SLCR SECURE REG.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_LPD_APB		BIT(18)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_FPD_APB: Error event mask for FPD APB Errors
+ * from:,FPD AFIFM0 REG,FPD AFIFM2 REG,FPD SLCR REG,FPD SLCR SECURE REG,
+ * CRF REG.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_FPD_APB		BIT(19)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_LPD_PAR: Error event mask for Data parity errors
+ * from the interfaces connected
+ * to the LPD interconnect.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_LPD_PAR		BIT(20)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_FPD_PAR: Error event mask for Data parity errors
+ * from the interfaces connected
+ * to the FPD interconnect.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_FPD_PAR		BIT(21)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_IOU_PAR: Error event mask for LPD IO Peripheral Unit Parity Error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_IOU_PAR		BIT(22)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PSM_PAR: Error event mask for Data parity errors
+ * from the interfaces connected to the PSM interconnect.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PSM_PAR		BIT(23)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_LPD_TO: Error event mask for LPD Interconnect Timeout errors.
+ * Collected from:,Timeout errors at the slaves connected to the LPD
+ * interconnect.,Address decode error.,Interconnect mission errors for
+ * the slaves connected to the LPD interconnect.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_LPD_TO		BIT(24)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_FPD_TO: Error event mask for FPD Interconnect Timeout errors.
+ * Collected from:,Coresight debug trace alarms.,Timeout errors at the
+ * slaves connected to the FPD interconnect.,Address decode error.,
+ * Data parity errors on the interfaces connected to the FPD interconnect.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_FPD_TO		BIT(25)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_PSM_TO: Error event mask for PSM Interconnect Timeout Errors.
+ * Collected from:,Interconnect mission errors for PSM_LOCAL slave or
+ * PSM_GLOBAL slave or MDM slave or LPD interconnect or PSM master.,
+ * Interconnect latent errors for PSM_LOCAL slave or PSM_GLOBAL slave or
+ * MDM slave or LPD interconnect or PSM master.,
+ * Timeout errors at the slaves connected to the PSM interconnect.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_PSM_TO		BIT(26)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_XRAM_CR: Error event mask for XRAM Correctable error.
+ * Only applicable in devices that have XRAM.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_XRAM_CR		BIT(27)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_XRAM_NCR: Error event mask for XRAM Non-Correctable error.
+ * Only applicable in devices that have XRAM.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_XRAM_NCR		BIT(28)
+
+/*
+ * Error Event Mask belongs to PSM ERR2 node,
+ * For which Node_Id = VERSAL_EVENT_ERROR_PSM_ERR2
+ */
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_LPD_SWDT: Error event mask for Error from Watchdog Timer
+ * in the LPD Subsystem.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_LPD_SWDT		BIT(0)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_FPD_SWDT: Error event mask for Error from Watchdog Timer
+ * in the FPD Subsystem.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_FPD_SWDT		BIT(1)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_LPD_XMPU: Error event mask for LPD XMPU Errors:,
+ * Register access error on APB., Read permission violation.,
+ * Write permission violation.,Security violation.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_LPD_XMPU		BIT(18)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_LPD_XPPU: Error event mask for LPD XPPU Errors:,
+ * Register access error on APB., Master ID not found.,Read permission violation.,
+ * Master ID parity error., Master ID access violation.,
+ * TrustZone violation.,Aperture parity error.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_LPD_XPPU		BIT(19)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_FPD_XMPU: Error event mask for FPD XMPU Errors:,
+ * Register access error on APB., Read permission violation.,
+ * Write permission violation.,Security violation.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_FPD_XMPU		BIT(20)
+
+/*
+ * Error Event Mask belongs to SW ERR node,
+ * For which Node_Id = VERSAL_EVENT_ERROR_SW_ERR
+ */
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_HB_MON_0: Health Boot Monitoring errors.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_HB_MON_0		BIT(0)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_HB_MON_1: Health Boot Monitoring errors.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_HB_MON_1		BIT(1)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_HB_MON_2: Health Boot Monitoring errors.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_HB_MON_2		BIT(2)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_HB_MON_3: Health Boot Monitoring errors.
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_HB_MON_3		BIT(3)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_XSEM_CRAM_CE_5: Error event mask for handling
+ * correctable error in Versal Configuration RAM which is reported by
+ * Soft Error Mitigation (XilSEM).
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_XSEM_CRAM_CE_5		BIT(5)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_XSEM_CRAM_UE_6: Error event mask for handling
+ * uncorrectable error in Versal Configuration RAM which is reported by
+ * Soft Error Mitigation (XilSEM).
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_XSEM_CRAM_UE_6		BIT(6)
+
+/**
+ * XPM_VERSAL_EVENT_ERROR_MASK_XSEM_NPI_UE_7: Error event mask for handling
+ * uncorrectable error in Versal NoC programming interface (NPI)
+ * register which is reported by Soft Error Mitigation (XilSEM).
+ */
+#define XPM_VERSAL_EVENT_ERROR_MASK_XSEM_NPI_UE_7		BIT(7)
+
+#endif /* _FIRMWARE_XLNX_VERSAL_ERROR_EVENTS_H_ */
--- /dev/null
+++ linux-xlnx-2025.1/include/linux/firmware/xlnx-versal-net-error-events.h	2025-07-02 12:01:39.266144700 +0900
@@ -0,0 +1,1121 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Xilinx Versal NET Error Event Node IDs and Error Event Mask.
+ * Use with Xilinx Event Management Driver
+ *
+ * Copyright (C) 2023, Advanced Micro Devices, Inc.
+ *
+ * Jay Buddhabhatti <jay.buddhabhatti@amd.com>
+ */
+
+#ifndef _FIRMWARE_XLNX_VERSAL_NET_ERROR_EVENTS_H_
+#define _FIRMWARE_XLNX_VERSAL_NET_ERROR_EVENTS_H_
+
+/*
+ * Error Event Node Ids
+ */
+#define VERSAL_NET_EVENT_ERROR_PMC_ERR1	(0x28100000U)
+#define VERSAL_NET_EVENT_ERROR_PMC_ERR2	(0x28104000U)
+#define VERSAL_NET_EVENT_ERROR_PMC_ERR3	(0x28108000U)
+#define VERSAL_NET_EVENT_ERROR_PSM_ERR1	(0x2810C000U)
+#define VERSAL_NET_EVENT_ERROR_PSM_ERR2	(0x28110000U)
+#define VERSAL_NET_EVENT_ERROR_PSM_ERR3	(0x28114000U)
+#define VERSAL_NET_EVENT_ERROR_PSM_ERR4	(0x28118000U)
+#define VERSAL_NET_EVENT_ERROR_SW_ERR	(0x2811C000U)
+
+/*
+ * Error Event Mask belongs to PMC ERR1 node.
+ * For which Node_Id = VERSAL_NET_EVENT_ERROR_PMC_ERR1
+ */
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_BOOT_CR: Error event mask for PMC Boot Correctable Error.
+ * Set by ROM code during ROM execution during Boot.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_BOOT_CR		BIT(0)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_BOOT_NCR: Error event mask for PMC Boot Non-Correctable Error.
+ * Set by ROM code during ROM execution during Boot.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_BOOT_NCR		BIT(1)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FW_CR: Error event mask for PMC Firmware Boot Correctable Error.
+ * Set by PLM during firmware execution during Boot.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FW_CR		BIT(2)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FW_NCR: Error event mask for PMC Firmware Boot Non-Correctable Error.
+ * Set by PLM during firmware execution during Boot.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FW_NCR		BIT(3)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_GSW_CR: Error event mask for General Software Correctable Error.
+ * Set by any processors after Boot.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_GSW_CR		BIT(4)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_GSW_NCR: Error event mask for General Software Non-Correctable Error.
+ * Set by any processors after Boot.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_GSW_NCR		BIT(5)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_CFU: Error event mask for CFU Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_CFU		BIT(6)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_CFRAME: Error event mask for CFRAME Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_CFRAME		BIT(7)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PMC_PSM_CR: Error event mask for PSM Correctable Error,
+ * Summary from PSM Error Management.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PMC_PSM_CR		BIT(8)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PMC_PSM_NCR: Error event mask for PSM Non-Correctable Error,
+ * Summary from PSM Error Management.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PMC_PSM_NCR	BIT(9)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_DDRMB_CR: Error event mask for DDRMC MB Correctable ECC Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_DDRMB_CR		BIT(10)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_DDRMB_NCR: Error event mask for DDRMC MB Non-Correctable ECC Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_DDRMB_NCR		BIT(11)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_NOCTYPE1_CR: Error event mask for NoC Type1 Correctable Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_NOCTYPE1_CR	BIT(12)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_NOCTYPE1_NCR: Error event mask for NoC Type1 Non-Correctable Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_NOCTYPE1_NCR	BIT(13)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_NOCUSER: Error event mask for NoC User Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_NOCUSER		BIT(14)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_MMCM: Error event mask for MMCM Lock Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_MMCM		BIT(15)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_AIE_CR: Error event mask for ME Correctable Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_AIE_CR		BIT(16)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_AIE_NCR: Error event mask for ME Non-Correctable Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_AIE_NCR		BIT(17)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_DDRMC_CR: Error event mask for DDRMC MC Correctable ECC Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_DDRMC_CR		BIT(18)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_DDRMC_NCR: Error event mask for DDRMC MC Non-Correctable ECC Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_DDRMC_NCR		BIT(19)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_GT_CR: Error event mask for GT Correctable Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_GT_CR		BIT(20)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_GT_NCR: Error event mask for GT Non-Correctable Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_GT_NCR		BIT(21)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PLSMON_CR: Error event mask for PL Sysmon Correctable Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PLSMON_CR		BIT(22)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PLSMON_NCR: Error event mask for PL Sysmon Non-Correctable Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PLSMON_NCR		BIT(23)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PL0: Error event mask for User defined PL generic error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PL0		BIT(24)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PL1: Error event mask for User defined PL generic error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PL1		BIT(25)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PL2: Error event mask for User defined PL generic error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PL2		BIT(26)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PL3: Error event mask for User defined PL generic error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PL3		BIT(27)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_NPIROOT: Error event mask for NPI Root Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_NPIROOT		BIT(28)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_SSIT3: Error event mask for SSIT Error from Slave SLR1,
+ * Only used in Master SLR.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_SSIT3		BIT(29)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_SSIT4: Error event mask for SSIT Error from Slave SLR2,
+ * Only used in Master SLR.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_SSIT4		BIT(30)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_SSIT5: Error event mask for SSIT Error from Slave SLR3,
+ * Only used in Master SLR.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_SSIT5		BIT(31)
+
+/*
+ * Error Event Mask belongs to PMC ERR2 node,
+ * For which Node_Id = VERSAL_NET_EVENT_ERROR_PMC_ERR2
+ */
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCAPB: Error event mask for General purpose PMC error,
+ * can be triggered by any of the following peripherals:,
+ * - PMC Global Regsiters,- PMC Clock & Reset (CRP),- PMC IOU Secure SLCR,
+ * - PMC IOU SLCR,- BBRAM Controller,- PMC Analog Control Registers,
+ * - RTC Control Registers.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCAPB		BIT(0)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCROM: Error event mask for PMC ROM Validation Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCROM		BIT(1)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_MB_FATAL0: Error event mask for PMC PPU0 MB TMR Fatal Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_MB_FATAL0		BIT(2)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_MB_FATAL1: Error event mask for PMC PPU1 MB TMR Fatal Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_MB_FATAL1		BIT(3)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PMC_CR: Error event mask for PMC Correctable Errors,
+ * PPU0 RAM correctable error.,PPU1 instruction RAM correctable error.,
+ * PPU1 data RAM correctable error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PMC_CR		BIT(5)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PMC_NCR: Error event mask for PMC Non-Correctable Errors,
+ * PPU0 RAM non-correctable error.,PPU1 instruction RAM non-correctable error.,
+ * PPU1 data RAM non-correctable error.,PRAM non-correctable error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PMC_NCR		BIT(6)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCSMON0: Error event mask for PMC Temperature Shutdown Alert
+ * and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[0].
+ * Indicates an alarm condition on any of SUPPLY0 to SUPPLY31.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCSMON0		BIT(7)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCSMON1: Error event mask for PMC Temperature Shutdown Alert
+ * and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[1].
+ * Indicates an alarm condition on any of SUPPLY32 to SUPPLY63.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCSMON1		BIT(8)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCSMON2: Error event mask for PMC Temperature Shutdown Alert
+ * and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[2].
+ * Indicates an alarm condition on any of SUPPLY64 to SUPPLY95.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCSMON2		BIT(9)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCSMON3: Error event mask for PMC Temperature Shutdown Alert
+ * and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[3].
+ * Indicates an alarm condition on any of SUPPLY96 to SUPPLY127.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCSMON3		BIT(10)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCSMON4: Error event mask for PMC Temperature Shutdown Alert
+ * and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[4].
+ * Indicates an alarm condition on any of SUPPLY128 to SUPPLY159.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCSMON4		BIT(11)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCSMON8: Error event mask for PMC Temperature Shutdown Alert
+ * and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[8].
+ * Indicates an over-temperature alarm.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCSMON8		BIT(15)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCSMON9: Error event mask for PMC Temperature Shutdown Alert
+ * and Power Supply.
+ * Failure Detection Errors from PMC Sysmon alarm[9].
+ * Indicates a device temperature alarm.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PMCSMON9		BIT(16)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_CFI: Error event mask for CFI Non-Correctable Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_CFI		BIT(17)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_SEUCRC: Error event mask for CFRAME SEU CRC Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_SEUCRC		BIT(18)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_SEUECC: Error event mask for CFRAME SEU ECC Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_SEUECC		BIT(19)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PMX_WWDT: Error event mask for PMC WWDT Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PMX_WWDT		BIT(20)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_RTCALARM: Error event mask for RTC Alarm Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_RTCALARM		BIT(22)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_NPLL: Error event mask for PMC NPLL Lock Error,
+ * This error can be unmasked after the NPLL is locked to alert when the
+ * NPLL loses lock.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_NPLL		BIT(23)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PPLL: Error event mask for PMC PPLL Lock Error,
+ * This error can be unmasked after the PPLL is locked to alert when the
+ * PPLL loses lock.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PPLL		BIT(24)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_CLKMON: Error event mask for Clock Monitor Errors.,
+ * Collected from CRP's CLKMON_STATUS register.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_CLKMON		BIT(25)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_PMX_CORR_ERR: Error event mask for PMC interconnect
+ * correctable error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_PMX_CORR_ERR	BIT(27)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_PMX_UNCORR_ERR: Error event mask for PMC interconnect
+ * uncorrectable error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_PMX_UNCORR_ERR	BIT(28)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_SSIT0: Error event mask for Master SLR:
+ * SSIT Error from Slave SLR1.,
+ * For Slave SLRs: SSIT Error0 from Master SLR.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_SSIT0		BIT(29)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_SSIT1: Error event mask for Master SLR:
+ * SSIT Error from Slave SLR2.,
+ * For Slave SLRs: SSIT Error1 from Master SLR.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_SSIT1		BIT(30)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_SSIT2: Error event mask for Master SLR:
+ * SSIT Error from Slave SLR3.,
+ * For Slave SLRs: SSIT Error2 from Master SLR.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_SSIT2		BIT(31)
+
+/*
+ * Error Event Mask belongs to PMC ERR3 node,
+ * For which Node_Id = VERSAL_NET_EVENT_ERROR_PMC_ERR3
+ */
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_IOU_CR: Error event mask for PMC IOU correctable error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_IOU_CR		BIT(0)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_IOU_NCR: Error event mask for PMC IOU uncorrectable
+ * error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_IOU_NCR		BIT(1)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_DFX_UXPT_ACT: Error event mask for DFX unexpected
+ * activation
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_DFX_UXPT_ACT	BIT(2)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_DICE_CDI_PAR: Error event mask for DICE CDI SEED parity
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_DICE_CDI_PAR	BIT(3)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_DEVIK_PRIV: Error event mask for Device identity private
+ * key parity
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_DEVIK_PRIV		BIT(4)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_NXTSW_CDI_PAR: Error event mask for Next SW CDI SEED
+ * parity
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_NXTSW_CDI_PAR	BIT(5)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_DEVAK_PRIV: Error event mask for Device attestation
+ * private key parity
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_DEVAK_PRIV		BIT(6)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_DME_PUB_X: Error event mask for DME public key X
+ * component's parity
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_DME_PUB_X		BIT(7)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_DME_PUB_Y: Error event mask for DME public key Y
+ * component's parity
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_DME_PUB_Y		BIT(8)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_DEVAK_PUB_X: Error event mask for DEVAK public key X
+ * component's parity
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_DEVAK_PUB_X	BIT(9)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_DEVAK_PUB_Y: Error event mask for DEVAK public key Y
+ * component's parity
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_DEVAK_PUB_Y	BIT(10)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_DEVIK_PUB_X: Error event mask for DEVIK public key X
+ * component's parity
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_DEVIK_PUB_X	BIT(11)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_DEVIK_PUB_Y: Error event mask for DEVIK public key Y
+ * component's parity
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_DEVIK_PUB_Y	BIT(12)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PCR_PAR: Error event mask for PCR parity
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PCR_PAR		BIT(13)
+
+/*
+ * Error Event Mask belongs to PSM ERR1 node,
+ * For which Node_Id = VERSAL_NET_EVENT_ERROR_PSM_ERR1
+ */
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PS_SW_CR: Error event mask for PS Software can write to
+ * trigger register to generate this Correctable Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PS_SW_CR		BIT(0)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PS_SW_NCR: Error event mask for PS Software can write to
+ * trigger register to generate this Non-Correctable Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PS_SW_NCR		BIT(1)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PSM_B_CR: Error event mask for PSM Firmware can write to
+ * trigger register to generate this Correctable Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PSM_B_CR		BIT(2)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PSM_B_NCR: Error event mask for PSM Firmware can write to
+ * trigger register to generate this Non-Correctable Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PSM_B_NCR		BIT(3)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_MB_FATAL: Error event mask for Or of MB Fatal1, Fatal2, Fatal3 Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_MB_FATAL		BIT(4)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PSM_CR: Error event mask for PSM Correctable.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PSM_CR		BIT(5)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PSM_NCR: Error event mask for PSM Non-Correctable.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PSM_NCR		BIT(6)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PSMX_CHK: Error event mask for PSMX CHK error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PSMX_CHK		BIT(7)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_APLL1_LOCK: Error event mask for APLL1 lock error. The error
+ * can be unmasked after the PLL is locked to alert when the PLL loses lock.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_APLL1_LOCK		BIT(8)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_APLL2_LOCK: Error event mask for APLL2 lock error. The error
+ * can be unmasked after the PLL is locked to alert when the PLL loses lock.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_APLL2_LOCK		BIT(9)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_RPLL_LOCK: Error event mask for RPLL Lock Errors. The error
+ * can be unmasked after the PLL is locked to alert when the PLL loses lock.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_RPLL_LOCK		BIT(10)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FLXPLL_LOCK: Error event mask for FLXPLL Lock Errors. The
+ * error can be unmasked after the PLL is locked to alert when the PLL loses lock.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FLXPLL_LOCK	BIT(11)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_PSM_CR: Error event mask for INT_PSM correctable error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_PSM_CR		BIT(12)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_PSM_NCR: Error event mask for INT_PSM non-correctable
+ * error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_PSM_NCR	BIT(13)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_USB2: Error event mask for Consolidated Error from the two
+ * USB2 blocks.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_USB2		BIT(14)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_LPX_UXPT_ACT: Error event mask for LPX unexpected dfx
+ * activation error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_LPX_UXPT_ACT	BIT(15)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_LPD_CR: Error event mask for INT_LPD correctable error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_LPD_CR		BIT(17)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_LPD_NCR: Error event mask for INT_LPD non-correctable
+ * error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_LPD_NCR	BIT(18)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_OCM_CR: Error event mask for INT_OCM correctable error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_OCM_CR		BIT(19)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_OCM_NCR: Error event mask for INT_OCM non-correctable
+ * error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_OCM_NCR	BIT(20)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_FPD_CR: Error event mask for INT_FPD correctable error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_FPD_CR		BIT(21)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_FPD_NCR: Error event mask for INT_FPD non-correctable
+ * error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_FPD_NCR	BIT(22)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_IOU_CR: Error event mask for INT_IOU correctable Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_IOU_CR		BIT(23)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_IOU_NCR: Error event mask for INT_IOU non-correctable
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_INT_IOU_NCR	BIT(24)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_RPUA_LOCKSTEP: Error event mask for RPU lockstep error for
+ * ClusterA
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_RPUA_LOCKSTEP	BIT(25)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_RPUB_LOCKSTEP: Error event mask for RPU lockstep error for
+ * ClusterB
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_RPUB_LOCKSTEP	BIT(26)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_APU_GIC_AXI: Error event mask for err_int_irq from APU
+ * GIC Distributer
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_APU_GIC_AXI	BIT(27)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_APU_GIC_ECC: Error event mask for fault_int_irq from APU
+ * GIC Distributer
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_APU_GIC_ECC	BIT(28)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_CPM_CR: Error event mask for CPM correctable error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_CPM_CR		BIT(29)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_CPM_NCR: Error event mask for CPM non-correctable error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_CPM_NCR		BIT(30)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_CPI: Error event mask for CPI error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_CPI		BIT(31)
+
+/*
+ * Error Event Mask belongs to PSM ERR2 node,
+ * For which Node_Id = VERSAL_NET_EVENT_ERROR_PSM_ERR2
+ */
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FPD_WDT0: Error event mask for FPD WDT0 error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FPD_WDT0		BIT(0)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FPD_WDT1: Error event mask for FPD WDT1 error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FPD_WDT1		BIT(1)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FPD_WDT2: Error event mask for FPD WDT2 error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FPD_WDT2		BIT(2)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FPD_WDT3: Error event mask for FPD WDT3 error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FPD_WDT3		BIT(3)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_MEM_SPLITTER0: Error event mask for Memory Errors for
+ * Splitter0
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_MEM_SPLITTER0	BIT(4)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_AXI_PAR_SPLITTER0: Error event mask for Consolidated
+ * Error indicating AXI parity Error for Splitter0
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_AXI_PAR_SPLITTER0	BIT(5)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_MEM_SPLITTER1: Error event mask for Memory Errors for
+ * Splitter1
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_MEM_SPLITTER1	BIT(6)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_AXI_PAR_SPLITTER1: Error event mask for Consolidated
+ * Error indicating AXI parity Error for Splitter1
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_AXI_PAR_SPLITTER1	BIT(7)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_MEM_SPLITTER2: Error event mask for Memory Errors for
+ * Splitter2
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_MEM_SPLITTER2	BIT(8)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_AXI_PAR_SPLITTER2: Error event mask for Consolidated
+ * Error indicating AXI parity Error for Splitter2
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_AXI_PAR_SPLITTER2	BIT(9)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_MEM_SPLITTER3: Error event mask for Memory Errors for
+ * Splitter3
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_MEM_SPLITTER3	BIT(10)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_AXI_PAR_SPLITTER3: Error event mask for Consolidated
+ * Error indicating AXI parity Error for Splitter3
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_AXI_PAR_SPLITTER3	BIT(11)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_APU_CLUSTER0: Error event mask for APU Cluster 0 error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_APU_CLUSTER0	BIT(12)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_APU_CLUSTER1: Error event mask for APU Cluster 1 error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_APU_CLUSTER1	BIT(13)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_APU_CLUSTER2: Error event mask for APU Cluster 2 error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_APU_CLUSTER2	BIT(14)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_APU_CLUSTER3: Error event mask for APU Cluster 3 error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_APU_CLUSTER3	BIT(15)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_LPD_WWDT0: Error event mask for WWDT0 LPX Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_LPD_WWDT0		BIT(16)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_LPD_WWDT1: Error event mask for WWDT0 LPX Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_LPD_WWDT1		BIT(17)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_ADMA_LOCKSTEP: Error event mask for ADMA Lockstep Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_ADMA_LOCKSTEP	BIT(18)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_IPI: Error event mask for IPI Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_IPI		BIT(19)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_OCM_BANK0_CR: Error event mask for OCM Bank0 Corr Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_OCM_BANK0_CR	BIT(20)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_OCM_BANK1_CR: Error event mask for OCM Bank1 Corr Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_OCM_BANK1_CR	BIT(21)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_OCM_BANK0_NCR: Error event mask for OCM Bank0 UnCorr
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_OCM_BANK0_NCR	BIT(22)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_OCM_BANK1_NCR: Error event mask for OCM Bank1 UnCorr
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_OCM_BANK1_NCR	BIT(23)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_LPXAFIFS_CR: Error event mask for LPXAFIFS Corr Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_LPXAFIFS_CR	BIT(24)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_LPXAFIFS_NCR: Error event mask for LPXAFIFS UnCorr
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_LPXAFIFS_NCR	BIT(25)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_LPX_GLITCH_DETECT0: Error event mask for LPX Glitch
+ * Detector0 glitch detected.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_LPX_GLITCH_DETECT0	BIT(26)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_LPX_GLITCH_DETECT1: Error event mask for LPX Glitch
+ * Detector1 glitch detected.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_LPX_GLITCH_DETECT1	BIT(27)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FWALL_WR_NOC_NMU: Error event mask for Firewall write
+ * errors from NOC NMUs
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FWALL_WR_NOC_NMU	BIT(28)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FWALL_RD_NOC_NMU: Error event mask for Firewall read
+ * error from NOC NMU
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FWALL_RD_NOC_NMU	BIT(29)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FWALL_NOC_NSU: Error event mask for Firewall error from
+ * NOC NSU
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FWALL_NOC_NSU	BIT(30)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_B18_R52_A0: Error event mask for Bit[18] from R52 Core
+ * A0, Err event
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_B18_R52_A0		BIT(31)
+
+/*
+ * Error Event Mask belongs to PSM ERR3 node,
+ * For which Node_Id = VERSAL_NET_EVENT_ERROR_PSM_ERR3
+ */
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_B18_R52_A1: Error event mask for Bit[18] from R52 Core
+ * A1, Err event
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_B18_R52_A1		BIT(0)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_B18_R52_B0: Error event mask for Bit[18] from R52 Core
+ * B0, Err event
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_B18_R52_B0		BIT(1)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_B18_R52_B1: Error event mask for Bit[18] from R52 Core
+ * B1, Err event
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_B18_R52_B1		BIT(2)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_A0_CR: Error event mask for R52 A0 Core Correctable
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_A0_CR		BIT(3)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_A0_TFATAL: Error event mask for R52 A0 Core TFatal
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_A0_TFATAL	BIT(4)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_A0_TIMEOUT: Error event mask for R52 A0 Core Timeout
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_A0_TIMEOUT	BIT(5)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_B24_B20_RPUA0: Error event mask for Bit[24:20] pf
+ * ERREVNT for RPUA0
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_B24_B20_RPUA0	BIT(6)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_B25_RPUA0: Error event mask for Bit[25] of ERREVNT for
+ * RPUA0
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_B25_RPUA0		BIT(7)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_A1_CR: Error event mask for R52 A1 Core Correctable
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_A1_CR		BIT(8)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_A1_TFATAL: Error event mask for R52 A1 Core TFatal
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_A1_TFATAL	BIT(9)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_A1_TIMEOUT: Error event mask for R52 A1 Core Timeout
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_A1_TIMEOUT	BIT(10)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_B24_B20_RPUA1: Error event mask for Bit[24:20] pf
+ * ERREVNT for RPUA1
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_B24_B20_RPUA1	BIT(11)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_B25_RPUA1: Error event mask for Bit[25] of ERREVNT for
+ * RPUA1
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_B25_RPUA1		BIT(12)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_B0_CR: Error event mask for R52 A1 Core Correctable
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_B0_CR		BIT(13)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_B0_TFATAL: Error event mask for R52 A1 Core TFatal
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_B0_TFATAL	BIT(14)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_B0_TIMEOUT: Error event mask for R52 A1 Core Timeout
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_B0_TIMEOUT	BIT(15)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_B24_B20_RPUB0: Error event mask for Bit[24:20] pf
+ * ERREVNT for RPUB0
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_B24_B20_RPUB0	BIT(16)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_B25_RPUB0: Error event mask for Bit[25] of ERREVNT for
+ * RPUB0
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_B25_RPUB0		BIT(17)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_B1_CR: Error event mask for R52 A1 Core Correctable
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_B1_CR		BIT(18)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_B1_TFATAL: Error event mask for R52 A1 Core TFatal
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_B1_TFATAL	BIT(19)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_B1_TIMEOUT: Error event mask for R52 A1 Core Timeout
+ * Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_R52_B1_TIMEOUT	BIT(20)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_B24_B20_RPUB1: Error event mask for Bit[24:20] pf
+ * ERREVNT for RPUB1
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_B24_B20_RPUB1	BIT(21)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_B25_RPUB1: Error event mask for Bit[25] of ERREVNT for
+ * RPUB1
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_B25_RPUB1		BIT(22)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PCIL_RPU: Error event mask for PCIL ERR FOR RPU Clusters
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PCIL_RPU		BIT(24)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FPXAFIFS_CR: Error event mask for FPXAFIFS Corr Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FPXAFIFS_CR	BIT(25)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FPXAFIFS_NCR: Error event mask for FPXAFIFS UnCorr Error
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FPXAFIFS_NCR	BIT(26)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PSX_CMN_1: Reserved
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PSX_CMN_1		BIT(27)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PSX_CMN_2: Reserved
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PSX_CMN_2		BIT(28)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PSX_CMN_3: Error event mask for PSX_CMN_3 PD block
+ * consolidated ERROR
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PSX_CMN_3		BIT(29)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_PSX_CML: Reserved
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_PSX_CML		BIT(30)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FPD_INT_WRAP: Error event mask FPD_INT_WRAP PD block
+ * consolidated ERROR
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FPD_INT_WRAP	BIT(31)
+
+/*
+ * Error Event Mask belongs to PSM ERR4 node,
+ * For which Node_Id = VERSAL_NET_EVENT_ERROR_PSM_ERR4
+ */
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FPD_RST_MON: Error event mask for FPD Reset Monitor ERROR
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FPD_RST_MON	BIT(0)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_LPD_RST_CLK_MON: Error event mask for LPD reset and Clock
+ * Monitor Error.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_LPD_RST_CLK_MON	BIT(1)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_FATAL_AFI_FM: Error event mask for Fatal Error from all
+ * AFI FM
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_FATAL_AFI_FM	BIT(2)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_NFATAL_AFI_FM_LPX: Error event mask for Non Fatal Error
+ * from AFI FM in LPX
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_NFATAL_AFI_FM_LPX	BIT(3)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_NFATAL_AFI_FM0_FPX: Error event mask for Non Fatal Error
+ * from AFI FM0 in FPX
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_NFATAL_AFI_FM0_FPX	BIT(4)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_NFATAL_AFI_FM1_FPX: Error event mask for Non Fatal Error
+ * from AFI FM1 in FPX
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_NFATAL_AFI_FM1_FPX	BIT(5)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_NFATAL_AFI_FM2_FPX: Error event mask for Non Fatal Error
+ * from AFI FM2 in FPX
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_NFATAL_AFI_FM2_FPX	BIT(6)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_NFATAL_AFI_FM3_FPX: Error event mask for Non Fatal Error
+ * from AFI FM3 in FPX
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_NFATAL_AFI_FM3_FPX	BIT(7)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_RPU_CLUSTERA: Error event mask for Errors from RPU
+ * cluster A
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_RPU_CLUSTERA	BIT(8)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_RPU_CLUSTERB: Error event mask for Errors from RPU
+ * cluster B
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_RPU_CLUSTERB	BIT(9)
+
+/*
+ * Error Event Mask belongs to SW ERR node,
+ * For which Node_Id = VERSAL_NET_EVENT_ERROR_SW_ERR
+ */
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_HB_MON_0: Health Boot Monitoring errors.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_HB_MON_0		BIT(0)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_HB_MON_1: Health Boot Monitoring errors.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_HB_MON_1		BIT(1)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_HB_MON_2: Health Boot Monitoring errors.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_HB_MON_2		BIT(2)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_HB_MON_3: Health Boot Monitoring errors.
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_HB_MON_3		BIT(3)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_XSEM_CRAM_CE: Error event mask for handling
+ * correctable error in Versal Configuration RAM which is reported by
+ * Soft Error Mitigation (XilSEM).
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_XSEM_CRAM_CE		BIT(7)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_XSEM_CRAM_UE: Error event mask for handling
+ * uncorrectable error in Versal Configuration RAM which is reported by
+ * Soft Error Mitigation (XilSEM).
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_XSEM_CRAM_UE		BIT(8)
+
+/**
+ * XPM_VERSAL_NET_EVENT_ERROR_MASK_XSEM_NPI_UE: Error event mask for handling
+ * uncorrectable error in Versal NoC programming interface (NPI)
+ * register which is reported by Soft Error Mitigation (XilSEM).
+ */
+#define XPM_VERSAL_NET_EVENT_ERROR_MASK_XSEM_NPI_UE		BIT(9)
+
+#endif /* _FIRMWARE_XLNX_VERSAL_NET_ERROR_EVENTS_H_ */
--- /dev/null
+++ linux-xlnx-2025.1/include/linux/firmware/xlnx-zynqmp-fpga.h	2025-07-02 12:01:39.266144700 +0900
@@ -0,0 +1,70 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Firmware layer for XilFPGA APIs.
+ *
+ * Copyright (C), 2025 Advanced Micro Devices, Inc.
+ */
+
+#ifndef __FIRMWARE_ZYNQMP_FPGA_H__
+#define __FIRMWARE_ZYNQMP_FPGA_H__
+
+/*
+ * Firmware FPGA Manager flags
+ * XILINX_ZYNQMP_PM_FPGA_FULL:	FPGA full reconfiguration
+ * XILINX_ZYNQMP_PM_FPGA_PARTIAL: FPGA partial reconfiguration
+ */
+#define XILINX_ZYNQMP_PM_FPGA_FULL	0x0U
+#define XILINX_ZYNQMP_PM_FPGA_PARTIAL	BIT(0)
+#define XILINX_ZYNQMP_PM_FPGA_AUTHENTICATION_DDR	BIT(1)
+#define XILINX_ZYNQMP_PM_FPGA_AUTHENTICATION_OCM	BIT(2)
+#define XILINX_ZYNQMP_PM_FPGA_ENCRYPTION_USERKEY	BIT(3)
+#define XILINX_ZYNQMP_PM_FPGA_ENCRYPTION_DEVKEY		BIT(4)
+
+/* FPGA Status Reg */
+#define XILINX_ZYNQMP_PM_FPGA_CONFIG_STAT_OFFSET	7U
+#define XILINX_ZYNQMP_PM_FPGA_READ_CONFIG_REG		0U
+
+#if IS_REACHABLE(CONFIG_ZYNQMP_FIRMWARE)
+int zynqmp_pm_fpga_read(const u32 reg_numframes, const u64 phys_address,
+			u32 readback_type, u32 *value);
+int zynqmp_pm_fpga_load(const u64 address, const u32 size, const u32 flags);
+int zynqmp_pm_fpga_get_status(u32 *value);
+int zynqmp_pm_fpga_get_config_status(u32 *value);
+int zynqmp_pm_fpga_get_version(u32 *value);
+int zynqmp_pm_fpga_get_feature_list(u32 *value);
+#else
+static inline int zynqmp_pm_fpga_read(const u32 reg_numframes,
+				      const u64 phys_address, u32 readback_type,
+				      u32 *value)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_fpga_load(const u64 address, const u32 size,
+				      const u32 flags)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_fpga_get_status(u32 *value)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_fpga_get_config_status(u32 *value)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_fpga_get_version(u32 *value)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_fpga_get_feature_list(u32 *value)
+{
+	return -ENODEV;
+}
+#endif
+
+#endif /* __FIRMWARE_ZYNQMP_FPGA_H__ */
--- /dev/null
+++ linux-xlnx-2025.1/include/linux/firmware/xlnx-zynqmp-nvm.h	2025-07-02 12:01:39.266144700 +0900
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Firmware layer for XilNVM APIs.
+ *
+ * Copyright (C), 2025 Advanced Micro Devices, Inc.
+ */
+
+#ifndef __FIRMWARE_ZYNQMP_NVM_H__
+#define __FIRMWARE_ZYNQMP_NVM_H__
+
+/* NVM Commands */
+#define PM_BBRAM_WRITE_KEY		0xB01
+#define PM_BBRAM_ZEROIZE		0xB02
+#define PM_BBRAM_WRITE_USERDATA		0xB03
+#define PM_BBRAM_READ_USERDATA		0xB04
+#define PM_BBRAM_LOCK_USERDATA		0xB05
+#define PM_EFUSE_READ_VERSAL		0xB17
+
+#if IS_REACHABLE(CONFIG_ZYNQMP_FIRMWARE)
+int zynqmp_pm_bbram_write_usrdata(u32 data);
+int zynqmp_pm_bbram_read_usrdata(const u64 outaddr);
+int zynqmp_pm_bbram_write_aeskey(u32 keylen, const u64 keyaddr);
+int zynqmp_pm_bbram_zeroize(void);
+int zynqmp_pm_bbram_lock_userdata(void);
+#else
+static inline int zynqmp_pm_bbram_write_usrdata(u32 data)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_bbram_read_usrdata(const u64 outaddr)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_bbram_write_aeskey(const u64 keyaddr, u16 keylen)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_bbram_zeroize(void)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_bbram_lock_userdata(void)
+{
+	return -ENODEV;
+}
+#endif
+
+#endif /* __FIRMWARE_ZYNQMP_NVM_H__ */
--- /dev/null
+++ linux-xlnx-2025.1/include/linux/firmware/xlnx-zynqmp-pdi.h	2025-07-02 12:01:39.267142000 +0900
@@ -0,0 +1,53 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Firmware layer for XilPDI APIs.
+ *
+ * Copyright (C), 2025 Advanced Micro Devices, Inc.
+ */
+
+#ifndef __FIRMWARE_ZYNQMP_PDI_H__
+#define __FIRMWARE_ZYNQMP_PDI_H__
+
+#include <linux/platform_device.h>
+
+/* Loader commands */
+#define PM_LOAD_PDI			0x701
+#define PM_GET_UID_INFO_LIST		0x705
+#define PM_GET_META_HEADER_INFO_LIST	0x706
+
+#define PDI_SRC_DDR	0xF
+
+int zynqmp_firmware_pdi_sysfs_entry(struct platform_device *pdev);
+
+#if IS_REACHABLE(CONFIG_ZYNQMP_FIRMWARE)
+int zynqmp_pm_get_uid_info(const u64 address, const u32 size, u32 *count);
+int zynqmp_pm_get_meta_header(const u64 src, const u64 dst,
+			      const u32 size, u32 *count);
+int zynqmp_pm_load_pdi(const u32 src, const u64 address);
+int zynqmp_pm_rsa(const u64 address, const u32 size, const u32 flags);
+#else
+static inline int zynqmp_pm_load_pdi(const u32 src, const u64 address)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_get_uid_info(const u64 address, const u32 size,
+					 u32 *count)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_rsa(const u64 address, const u32 size,
+				const u32 flags)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_get_meta_header(const u64 src, const u64 dst,
+					    const u32 size, u32 *count)
+{
+	return -ENODEV;
+}
+#endif
+
+#endif /* __FIRMWARE_ZYNQMP_PDI_H__ */
--- /dev/null
+++ linux-xlnx-2025.1/include/linux/firmware/xlnx-zynqmp-secure.h	2025-07-02 12:01:39.267142000 +0900
@@ -0,0 +1,208 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Firmware layer for XilSECURE APIs.
+ *
+ * Copyright (C), 2025 Advanced Micro Devices, Inc.
+ */
+
+#ifndef __FIRMWARE_ZYNQMP_SECURE_H__
+#define __FIRMWARE_ZYNQMP_SECURE_H__
+
+/* xilSecure API commands  module id + api id */
+#define XSECURE_API_RSA_SIGN_VERIFY	0x501
+#define XSECURE_API_RSA_PUBLIC_ENCRYPT	0x502
+#define XSECURE_API_RSA_PRIVATE_DECRYPT	0x503
+#define XSECURE_API_SHA3_UPDATE		0x504
+#define XSECURE_API_ELLIPTIC_VALIDATE_KEY	0x507
+#define XSECURE_API_ELLIPTIC_VERIFY_SIGN	0x508
+#define XSECURE_API_AES_INIT		0x509
+#define XSECURE_API_AES_OP_INIT		0x50a
+#define XSECURE_API_AES_UPDATE_AAD	0x50b
+#define XSECURE_API_AES_ENCRYPT_UPDATE	0x50c
+#define XSECURE_API_AES_ENCRYPT_FINAL	0x50d
+#define XSECURE_API_AES_DECRYPT_UPDATE	0x50e
+#define XSECURE_API_AES_DECRYPT_FINAL	0x50f
+#define XSECURE_API_AES_KEY_ZERO	0x510
+#define XSECURE_API_AES_WRITE_KEY	0x511
+
+/* XilPuf API commands module id + api id */
+#define XPUF_API_PUF_REGISTRATION	0xc01
+#define XPUF_API_PUF_REGENERATION	0xc02
+#define XPUF_API_PUF_CLEAR_PUF_ID	0xc03
+
+/**
+ * struct xlnx_feature - Feature data
+ * @family:	Family code of platform
+ * @subfamily:	Subfamily code of platform
+ * @feature_id:	Feature id of module
+ * @data:	Collection of all supported platform data
+ */
+struct xlnx_feature {
+	u32 family;
+	u32 subfamily;
+	u32 feature_id;
+	void *data;
+};
+
+enum xsecure_aeskeysize {
+	XSECURE_AES_KEY_SIZE_128 = 16,
+	XSECURE_AES_KEY_SIZE_256 = 32,
+};
+
+#if IS_REACHABLE(CONFIG_ZYNQMP_FIRMWARE)
+void *xlnx_get_crypto_dev_data(struct xlnx_feature *feature_map);
+int zynqmp_pm_secure_load(const u64 src_addr, u64 key_addr, u64 *dst);
+int zynqmp_pm_sha_hash(const u64 address, const u32 size, const u32 flags);
+int versal_pm_puf_registration(const u64 in_addr);
+int versal_pm_puf_regeneration(const u64 in_addr);
+int versal_pm_puf_clear_id(void);
+int zynqmp_pm_efuse_access(const u64 address, u32 *out);
+int versal_pm_efuse_read(const u64 address, u32 offset, u32 size);
+int versal_pm_efuse_write(const u64 address, const u32 operationid, const u8 envdis);
+int versal_pm_sha_hash(const u64 src, const u64 dst, const u32 size);
+int versal_pm_rsa_encrypt(const u64 in_params, const u64 in_addr);
+int versal_pm_rsa_decrypt(const u64 in_params, const u64 in_addr);
+int versal_pm_ecdsa_validate_key(const u64 key_addr, const u32 curveid);
+int versal_pm_ecdsa_verify_sign(const u64 sign_param_addr);
+int zynqmp_pm_aes_engine(const u64 address, u32 *out);
+int versal_pm_aes_key_write(const u32 keylen,
+			    const u32 keysrc, const u64 keyaddr);
+int versal_pm_aes_key_zero(const u32 keysrc);
+int versal_pm_aes_op_init(const u64 hw_req);
+int versal_pm_aes_update_aad(const u64 aad_addr, const u32 aad_len);
+int versal_pm_aes_enc_update(const u64 in_params, const u64 in_addr);
+int versal_pm_aes_dec_update(const u64 in_params, const u64 in_addr);
+int versal_pm_aes_dec_final(const u64 gcm_addr);
+int versal_pm_aes_enc_final(const u64 gcm_addr);
+int versal_pm_aes_init(void);
+#else
+static inline void *xlnx_get_crypto_dev_data(struct xlnx_feature *feature_map)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline int zynqmp_pm_secure_load(const u64 src_addr, u64 key_addr, u64 *dst)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_sha_hash(const u64 address, const u32 size,
+				     const u32 flags)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_puf_registration(const u64 in_addr)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_puf_regeneration(const u64 in_addr)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_puf_clear_id(void)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_efuse_read(const u64 address, u32 offset, u32 size)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_efuse_write(const u64 address, const u32 operationid, const u8 envdis)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_efuse_access(const u64 address, u32 *out)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_sha_hash(const u64 src, const u64 dst, const u32 size)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_rsa_encrypt(const u64 in_params,
+					const u64 in_addr)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_rsa_decrypt(const u64 in_params,
+					const u64 in_addr)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_ecdsa_validate_key(const u64 key_addr,
+					       const u32 curveid)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_ecdsa_verify_sign(const u64 sign_param_addr)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_aes_engine(const u64 address, u32 *out)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_aes_key_write(const u32 keylen,
+					  const u32 keysrc, const u64 keyaddr)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_aes_key_zero(const u32 keysrc)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_aes_op_init(const u64 hw_req)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_aes_update_aad(const u64 aad_addr,
+					   const u32 aad_len)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_aes_enc_update(const u64 in_params,
+					   const u64 in_addr)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_aes_dec_update(const u64 in_params,
+					   const u64 in_addr)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_aes_enc_final(const u64 gcm_addr)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_aes_dec_final(const u64 gcm_addr)
+{
+	return -ENODEV;
+}
+
+static inline int versal_pm_aes_init(void)
+{
+	return -ENODEV;
+}
+#endif
+
+#endif /* __FIRMWARE_ZYNQMP_SECURE_H__ */
--- /dev/null
+++ linux-xlnx-2025.1/include/linux/firmware/xlnx-zynqmp-sem.h	2025-07-02 12:01:39.267142000 +0900
@@ -0,0 +1,69 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Firmware layer for XilSEM APIs.
+ *
+ * Copyright (C), 2025 Advanced Micro Devices, Inc.
+ */
+
+#ifndef __FIRMWARE_ZYNQMP_SEM_H__
+#define __FIRMWARE_ZYNQMP_SEM_H__
+
+/* XilSEM commands */
+#define PM_XSEM_HEADER			0x300
+#define PM_XSEM_CRAM_ERRINJ		0x304
+#define PM_XSEM_RD_CONFIG		0x309
+#define PM_XSEM_CRAM_RD_ECC		0x30B
+#define PM_XSEM_SSIT_GET_CRC		0x30C
+#define PM_XSEM_SSIT_RD_STS		0x30D
+#define PM_XSEM_SSIT_GET_FRAMES		0x30E
+
+#if IS_REACHABLE(CONFIG_ZYNQMP_FIRMWARE)
+int zynqmp_pm_xilsem_cntrl_ops(u32 cmd, u32 slrid, u32 *const response);
+int zynqmp_pm_xilsem_cram_errinj(u32 slrid, u32 frame, u32 qword, u32 bit, u32 row,
+				 u32 *const response);
+int zynqmp_pm_xilsem_cram_readecc(u32 slrid, u32 frame, u32 row, u32 *const response);
+int zynqmp_pm_xilsem_read_cfg(u32 slrid, u32 *const response);
+int zynqmp_pm_xilsem_read_ssit_status(u32 slrid, u32 bufaddr, u32 *const response);
+int zynqmp_pm_xilsem_cram_getcrc(u32 slrid, u32 rowindex, u32 *const response);
+int zynqmp_pm_xilsem_cram_ssit_totframes(u32 slrid, u32 row, u32 framecnt,
+					 u32 *const response);
+#else
+static inline int zynqmp_pm_xilsem_cntrl_ops(u32 cmd, u32 slrid, u32 *const response)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_xilsem_cram_errinj(u32 slrid, u32 frame, u32 qword, u32 bit, u32 row,
+					       u32 *const response)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_xilsem_cram_readecc(u32 slrid, u32 frame, u32 row, u32 *const response)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_xilsem_read_cfg(u32 slrid, u32 *const response)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_xilsem_read_ssit_status(u32 slrid, u32 bufaddr, u32 *const response)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_xilsem_cram_getcrc(u32 slrid, u32 rowindex, u32 *const response)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_xilsem_cram_ssit_totframes(u32 slrid, u32 row, u32 framecnt,
+						       u32 *const response)
+{
+	return -ENODEV;
+}
+#endif
+
+#endif /* __FIRMWARE_ZYNQMP_SEM_H__ */
--- linux-6.12.10/include/linux/firmware/xlnx-zynqmp.h	2025-07-02 11:58:55.429338900 +0900
+++ linux-xlnx-2025.1/include/linux/firmware/xlnx-zynqmp.h	2025-07-02 12:01:39.268139200 +0900
@@ -3,7 +3,7 @@
  * Xilinx Zynq MPSoC Firmware layer
  *
  *  Copyright (C) 2014-2021 Xilinx
- *  Copyright (C) 2022 - 2023, Advanced Micro Devices, Inc.
+ *  Copyright (C) 2022 - 2025, Advanced Micro Devices, Inc.
  *
  *  Michal Simek <michal.simek@amd.com>
  *  Davorin Mista <davorin.mista@aggios.com>
@@ -16,6 +16,11 @@
 #include <linux/types.h>
 
 #include <linux/err.h>
+#include <linux/firmware/xlnx-zynqmp-fpga.h>
+#include <linux/firmware/xlnx-zynqmp-nvm.h>
+#include <linux/firmware/xlnx-zynqmp-pdi.h>
+#include <linux/firmware/xlnx-zynqmp-secure.h>
+#include <linux/firmware/xlnx-zynqmp-sem.h>
 
 #define ZYNQMP_PM_VERSION_MAJOR	1
 #define ZYNQMP_PM_VERSION_MINOR	0
@@ -32,9 +37,23 @@
 /* SMC SIP service Call Function Identifier Prefix */
 #define PM_SIP_SVC			0xC2000000
 
+/* SMC function ID to get SiP SVC version */
+#define GET_SIP_SVC_VERSION	(0x8200ff03U)
+
+/* SiP Service Calls version numbers */
+#define SIP_SVC_VERSION_MAJOR		(0U)
+#define SIP_SVC_VERSION_MINOR		(2U)
+
+#define SIP_SVC_PASSTHROUGH_VERSION	((SIP_SVC_VERSION_MAJOR << 16) | \
+					 SIP_SVC_VERSION_MINOR)
+
+/* Fixed ID for FW specific APIs */
+#define PASS_THROUGH_FW_CMD_ID	GENMASK(11, 0)
+
 /* PM API versions */
 #define PM_API_VERSION_1	1
 #define PM_API_VERSION_2	2
+#define PM_API_VERSION_3	3
 
 #define PM_PINCTRL_PARAM_SET_VERSION	2
 
@@ -44,13 +63,15 @@
 /* When all subfamily of platform need to support */
 #define ALL_SUB_FAMILY_CODE		0x00
 #define VERSAL_SUB_FAMILY_CODE		0x01
-#define VERSALNET_SUB_FAMILY_CODE	0x03
+#define VERSAL_SUB_FAMILY_CODE_MAX	0x04
+#define VERSALNET_OR_VERSAL2_SUB_FAMILY_CODE	0x06
 
 #define FAMILY_CODE_MASK	GENMASK(27, 21)
-#define SUB_FAMILY_CODE_MASK	GENMASK(20, 19)
+#define SUB_FAMILY_CODE_MASK	GENMASK(20, 18)
 
 #define API_ID_MASK		GENMASK(7, 0)
 #define MODULE_ID_MASK		GENMASK(11, 8)
+#define PLM_MODULE_ID_MASK	GENMASK(15, 8)
 
 /* Firmware feature check version mask */
 #define FIRMWARE_VERSION_MASK		0xFFFFU
@@ -62,7 +83,16 @@
 #define GET_CALLBACK_DATA		0xa01
 
 /* Number of 32bits values in payload */
-#define PAYLOAD_ARG_CNT	4U
+#define PAYLOAD_ARG_CNT	7U
+
+/* Number of 64bits arguments for SMC call */
+#define SMC_ARG_CNT_64	8U
+
+/* Number of 32bits arguments for SMC call */
+#define SMC_ARG_CNT_32	13U
+
+/* Number of 32bits arguments for Basic SMC call */
+#define SMC_ARG_CNT_BASIC_32	14U
 
 /* Number of arguments for a callback */
 #define CB_ARG_CNT     4
@@ -80,60 +110,47 @@
 #define	ZYNQMP_PM_CAPABILITY_WAKEUP	0x4U
 #define	ZYNQMP_PM_CAPABILITY_UNUSABLE	0x8U
 
-/* Loader commands */
-#define PM_LOAD_PDI	0x701
-#define PDI_SRC_DDR	0xF
-
-/*
- * Firmware FPGA Manager flags
- * XILINX_ZYNQMP_PM_FPGA_FULL:	FPGA full reconfiguration
- * XILINX_ZYNQMP_PM_FPGA_PARTIAL: FPGA partial reconfiguration
- */
-#define XILINX_ZYNQMP_PM_FPGA_FULL	0x0U
-#define XILINX_ZYNQMP_PM_FPGA_PARTIAL	BIT(0)
-
-/* FPGA Status Reg */
-#define XILINX_ZYNQMP_PM_FPGA_CONFIG_STAT_OFFSET	7U
-#define XILINX_ZYNQMP_PM_FPGA_READ_CONFIG_REG		0U
-
-/*
- * Node IDs for the Error Events.
- */
-#define VERSAL_EVENT_ERROR_PMC_ERR1	(0x28100000U)
-#define VERSAL_EVENT_ERROR_PMC_ERR2	(0x28104000U)
-#define VERSAL_EVENT_ERROR_PSM_ERR1	(0x28108000U)
-#define VERSAL_EVENT_ERROR_PSM_ERR2	(0x2810C000U)
-
-#define VERSAL_NET_EVENT_ERROR_PMC_ERR1	(0x28100000U)
-#define VERSAL_NET_EVENT_ERROR_PMC_ERR2	(0x28104000U)
-#define VERSAL_NET_EVENT_ERROR_PMC_ERR3	(0x28108000U)
-#define VERSAL_NET_EVENT_ERROR_PSM_ERR1	(0x2810C000U)
-#define VERSAL_NET_EVENT_ERROR_PSM_ERR2	(0x28110000U)
-#define VERSAL_NET_EVENT_ERROR_PSM_ERR3	(0x28114000U)
-#define VERSAL_NET_EVENT_ERROR_PSM_ERR4	(0x28118000U)
-
 /* ZynqMP SD tap delay tuning */
 #define SD_ITAPDLY	0xFF180314
 #define SD_OTAPDLYSEL	0xFF180318
 
-/**
- * XPM_EVENT_ERROR_MASK_DDRMC_CR: Error event mask for DDRMC MC Correctable ECC Error.
- */
-#define XPM_EVENT_ERROR_MASK_DDRMC_CR		BIT(18)
-
-/**
- * XPM_EVENT_ERROR_MASK_DDRMC_NCR: Error event mask for DDRMC MC Non-Correctable ECC Error.
- */
-#define XPM_EVENT_ERROR_MASK_DDRMC_NCR		BIT(19)
-#define XPM_EVENT_ERROR_MASK_NOC_NCR		BIT(13)
-#define XPM_EVENT_ERROR_MASK_NOC_CR		BIT(12)
-
 enum pm_module_id {
 	PM_MODULE_ID = 0x0,
+	XPM_MODULE_ID = 0x2,
 	XSEM_MODULE_ID = 0x3,
 	TF_A_MODULE_ID = 0xa,
 };
 
+/* AIE Operation */
+enum pm_aie_operations {
+	XILINX_AIE_OPS_MIN = 0U,
+	XILINX_AIE_OPS_COL_RST = 1U,
+	XILINX_AIE_OPS_SHIM_RST = 2U,
+	XILINX_AIE_OPS_UC_ZEROIZATION = 3U,
+	XILINX_AIE_OPS_ENB_COL_CLK_BUFF = 4U,
+	XILINX_AIE_OPS_HANDSHAKE = 5U,
+	XILINX_AIE_OPS_CLR_HW_ERR_STS = 6U,
+	XILINX_AIE_OPS_START_NUM_COL = 7U,
+	XILINX_AIE_OPS_ZEROISATION = 8U,
+	XILINX_AIE_OPS_AXIMM_ISOLATION = 9U,
+	XILINX_AIE_OPS_NMU_CONFIG = 10U,
+	XILINX_AIE_OPS_DIS_MEM_PRIV = 11U,
+	XILINX_AIE_OPS_DIS_MEM_INTERLEAVE = 12U,
+	XILINX_AIE_OPS_ENB_UC_DMA_PAUSE = 13U,
+	XILINX_AIE_OPS_ENB_NOC_DMA_PAUSE = 14U,
+	XILINX_AIE_OPS_SET_ECC_SCRUB_PERIOD = 15U,
+	XILINX_AIE_OPS_DIS_COL_CLK_BUFF = 16U,
+	XILINX_AIE_OPS_HW_ERR_INT = 17U,
+	XILINX_AIE_OPS_HW_ERR_MASK = 18U,
+	XILINX_AIE_OPS_ENB_MEM_PRIV = 19U,
+	XILINX_AIE_OPS_ENB_AXI_MM_ERR_EVENT = 32U,     /* Backward compatibility for AIE1/AIE2 */
+	XILINX_AIE_OPS_SET_L2_CTRL_NPI_INTR = 64U,     /* Backward compatibility for AIE1/AIE2 */
+	XILINX_AIE_OPS_PROG_MEM_ZEROIZATION = 128U,    /* Backward compatibility for AIE1/AIE2 */
+	XILINX_AIE_OPS_DATA_MEM_ZEROIZATION = 256U,    /* Backward compatibility for AIE1/AIE2 */
+	XILINX_AIE_OPS_MEM_TILE_ZEROIZATION = 512U,    /* Backward compatibility for AIE1/AIE2 */
+	XILINX_AIE_OPS_MAX = 1023U,                    /* Backward compatibility for AIE1/AIE2 */
+};
+
 enum pm_api_cb_id {
 	PM_INIT_SUSPEND_CB = 30,
 	PM_ACKNOWLEDGE_CB = 31,
@@ -143,6 +160,7 @@
 enum pm_api_id {
 	PM_API_FEATURES = 0,
 	PM_GET_API_VERSION = 1,
+	PM_GET_NODE_STATUS = 3,
 	PM_REGISTER_NOTIFIER = 5,
 	PM_FORCE_POWERDOWN = 8,
 	PM_REQUEST_WAKEUP = 10,
@@ -158,7 +176,10 @@
 	PM_FPGA_LOAD = 22,
 	PM_FPGA_GET_STATUS = 23,
 	PM_GET_CHIPID = 24,
+	/* ID 25 is been used by U-boot to process secure boot images */
+	/* Secure library generic API functions */
 	PM_SECURE_SHA = 26,
+	PM_SECURE_RSA = 27,
 	PM_PINCTRL_REQUEST = 28,
 	PM_PINCTRL_RELEASE = 29,
 	PM_PINCTRL_SET_FUNCTION = 31,
@@ -173,10 +194,15 @@
 	PM_CLOCK_GETDIVIDER = 40,
 	PM_CLOCK_SETPARENT = 43,
 	PM_CLOCK_GETPARENT = 44,
+	PM_SECURE_IMAGE = 45,
 	PM_FPGA_READ = 46,
 	PM_SECURE_AES = 47,
+	/* PM_REGISTER_ACCESS API */
+	PM_REGISTER_ACCESS = 52,
 	PM_EFUSE_ACCESS = 53,
 	PM_FEATURE_CHECK = 63,
+	PM_FPGA_GET_VERSION = 72,
+	PM_FPGA_GET_FEATURE_LIST = 73,
 };
 
 /* PMU-FW return status codes */
@@ -212,15 +238,29 @@
 	IOCTL_READ_PGGS = 15,
 	/* Set healthy bit value */
 	IOCTL_SET_BOOT_HEALTH_STATUS = 17,
+	IOCTL_AFI = 18,
 	IOCTL_OSPI_MUX_SELECT = 21,
+	/* IOCTL for USB power request */
+	IOCTL_USB_SET_STATE = 22,
+	/* IOCTL to get last reset reason */
+	IOCTL_GET_LAST_RESET_REASON = 23,
 	/* Register SGI to ATF */
 	IOCTL_REGISTER_SGI = 25,
 	/* Runtime feature configuration */
 	IOCTL_SET_FEATURE_CONFIG = 26,
 	IOCTL_GET_FEATURE_CONFIG = 27,
+	/* IOCTL for Secure Read/Write Interface */
+	IOCTL_READ_REG = 28,
+	IOCTL_MASK_WRITE_REG = 29,
 	/* Dynamic SD/GEM configuration */
 	IOCTL_SET_SD_CONFIG = 30,
 	IOCTL_SET_GEM_CONFIG = 31,
+	/* AIE/AIEML Operations */
+	IOCTL_AIE_OPS = 33,
+	/* IOCTL to get default/current QoS */
+	IOCTL_GET_QOS = 34,
+	/* AIE2PS Operations */
+	IOCTL_AIE2PS_OPS = 39,
 };
 
 enum pm_query_id {
@@ -238,6 +278,7 @@
 	PM_QID_PINCTRL_GET_PIN_GROUPS = 11,
 	PM_QID_CLOCK_GET_NUM_CLOCKS = 12,
 	PM_QID_CLOCK_GET_MAX_DIVISOR = 13,
+	PM_QID_PINCTRL_GET_ATTRIBUTES = 15,
 };
 
 enum rpu_oper_mode {
@@ -486,6 +527,11 @@
 	PM_OSPI_MUX_SEL_LINEAR = 1,
 };
 
+enum pm_register_access_id {
+	CONFIG_REG_WRITE = 0,
+	CONFIG_REG_READ = 1,
+};
+
 enum pm_feature_config_id {
 	PM_FEATURE_INVALID = 0,
 	PM_FEATURE_OVERTEMP_STATUS = 1,
@@ -518,6 +564,17 @@
 	GEM_CONFIG_FIXED = 2,
 };
 
+enum pm_reset_reason {
+	PM_RESET_REASON_EXT_POR = 0,
+	PM_RESET_REASON_SW_POR = 1,
+	PM_RESET_REASON_SLR_POR = 2,
+	PM_RESET_REASON_ERR_POR = 3,
+	PM_RESET_REASON_DAP_SRST = 7,
+	PM_RESET_REASON_ERR_SRST = 8,
+	PM_RESET_REASON_SW_SRST = 9,
+	PM_RESET_REASON_SLR_SRST = 10,
+};
+
 /**
  * struct zynqmp_pm_query_data - PM query data
  * @qid:	query ID
@@ -532,12 +589,27 @@
 	u32 arg3;
 };
 
+/**
+ * struct zynqmp_devinfo - Structure for Zynqmp device instance
+ * @dev:		Device Pointer
+ * @feature_conf_id:	Feature conf id
+ */
+struct zynqmp_devinfo {
+	struct device *dev;
+	u32 feature_conf_id;
+};
+
 int zynqmp_pm_invoke_fn(u32 pm_api_id, u32 *ret_payload, u32 num_args, ...);
+int zynqmp_pm_fw_call_extended(u32 pm_api_id, u32 *ret_payload, u32 num_args, ...);
+int zynqmp_firmware_pm_sysfs_entry(struct platform_device *pdev);
 
 #if IS_REACHABLE(CONFIG_ZYNQMP_FIRMWARE)
 int zynqmp_pm_get_api_version(u32 *version);
 int zynqmp_pm_get_chipid(u32 *idcode, u32 *version);
 int zynqmp_pm_get_family_info(u32 *family, u32 *subfamily);
+int zynqmp_pm_get_trustzone_version(u32 *version);
+int zynqmp_pm_get_sip_svc_version(u32 *version);
+int zynqmp_pm_load_pdi_word_swap(const u64 address, u64 *swapped_address);
 int zynqmp_pm_query_data(struct zynqmp_pm_query_data qdata, u32 *out);
 int zynqmp_pm_clock_enable(u32 clock_id);
 int zynqmp_pm_clock_disable(u32 clock_id);
@@ -553,9 +625,9 @@
 int zynqmp_pm_set_sd_tapdelay(u32 node_id, u32 type, u32 value);
 int zynqmp_pm_sd_dll_reset(u32 node_id, u32 type);
 int zynqmp_pm_ospi_mux_select(u32 dev_id, u32 select);
-int zynqmp_pm_reset_assert(const enum zynqmp_pm_reset reset,
+int zynqmp_pm_reset_assert(const u32 reset,
 			   const enum zynqmp_pm_reset_action assert_flag);
-int zynqmp_pm_reset_get_status(const enum zynqmp_pm_reset reset, u32 *status);
+int zynqmp_pm_reset_get_status(const u32 reset, u32 *status);
 unsigned int zynqmp_pm_bootmode_read(u32 *ps_mode);
 int zynqmp_pm_bootmode_write(u32 ps_mode);
 int zynqmp_pm_init_finalize(void);
@@ -566,17 +638,15 @@
 int zynqmp_pm_set_requirement(const u32 node, const u32 capabilities,
 			      const u32 qos,
 			      const enum zynqmp_pm_request_ack ack);
-int zynqmp_pm_aes_engine(const u64 address, u32 *out);
-int zynqmp_pm_efuse_access(const u64 address, u32 *out);
-int zynqmp_pm_sha_hash(const u64 address, const u32 size, const u32 flags);
-int zynqmp_pm_fpga_load(const u64 address, const u32 size, const u32 flags);
-int zynqmp_pm_fpga_get_status(u32 *value);
-int zynqmp_pm_fpga_get_config_status(u32 *value);
+int zynqmp_pm_config_reg_access(u32 register_access_id, u32 address, u32 mask,
+				u32 value, u32 *out);
 int zynqmp_pm_write_ggs(u32 index, u32 value);
 int zynqmp_pm_read_ggs(u32 index, u32 *value);
 int zynqmp_pm_write_pggs(u32 index, u32 value);
 int zynqmp_pm_read_pggs(u32 index, u32 *value);
 int zynqmp_pm_set_tapdelay_bypass(u32 index, u32 value);
+int zynqmp_pm_afi(u32 index, u32 value);
+int zynqmp_pm_usb_set_state(u32 node, u32 state, u32 value);
 int zynqmp_pm_system_shutdown(const u32 type, const u32 subtype);
 int zynqmp_pm_set_boot_health_status(u32 value);
 int zynqmp_pm_pinctrl_request(const u32 pin);
@@ -586,13 +656,15 @@
 				 u32 *value);
 int zynqmp_pm_pinctrl_set_config(const u32 pin, const u32 param,
 				 u32 value);
-int zynqmp_pm_load_pdi(const u32 src, const u64 address);
 int zynqmp_pm_register_notifier(const u32 node, const u32 event,
 				const u32 wake, const u32 enable);
 int zynqmp_pm_feature(const u32 api_id);
 int zynqmp_pm_is_function_supported(const u32 api_id, const u32 id);
 int zynqmp_pm_set_feature_config(enum pm_feature_config_id id, u32 value);
 int zynqmp_pm_get_feature_config(enum pm_feature_config_id id, u32 *payload);
+int zynqmp_pm_sec_read_reg(u32 node_id, u32 offset, u32 *ret_value);
+int zynqmp_pm_sec_mask_write_reg(const u32 node_id, const u32 offset,
+				 u32 mask, u32 value);
 int zynqmp_pm_register_sgi(u32 sgi_num, u32 reset);
 int zynqmp_pm_force_pwrdwn(const u32 target,
 			   const enum zynqmp_pm_request_ack ack);
@@ -603,9 +675,15 @@
 int zynqmp_pm_get_rpu_mode(u32 node_id, enum rpu_oper_mode *rpu_mode);
 int zynqmp_pm_set_rpu_mode(u32 node_id, enum rpu_oper_mode rpu_mode);
 int zynqmp_pm_set_tcm_config(u32 node_id, enum rpu_tcm_comb tcm_mode);
+int zynqmp_pm_get_node_status(const u32 node, u32 *const status,
+			      u32 *const requirements, u32 *const usage);
 int zynqmp_pm_set_sd_config(u32 node, enum pm_sd_config_type config, u32 value);
 int zynqmp_pm_set_gem_config(u32 node, enum pm_gem_config_type config,
 			     u32 value);
+int zynqmp_pm_get_last_reset_reason(u32 *reset_reason);
+int zynqmp_pm_aie_operation(u32 node, u16 start_col, u16 num_col, u32 operation);
+int zynqmp_pm_get_qos(u32 node, u32 *const def_qos, u32 *const qos);
+int versal2_pm_aie2ps_operation(u32 node, u32 size, u32 addr_high, u32 addr_low);
 #else
 static inline int zynqmp_pm_get_api_version(u32 *version)
 {
@@ -622,6 +700,16 @@
 	return -ENODEV;
 }
 
+static inline int zynqmp_pm_get_trustzone_version(u32 *version)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_get_sip_svc_version(u32 *version)
+{
+	return -ENODEV;
+}
+
 static inline int zynqmp_pm_query_data(struct zynqmp_pm_query_data qdata,
 				       u32 *out)
 {
@@ -698,14 +786,13 @@
 	return -ENODEV;
 }
 
-static inline int zynqmp_pm_reset_assert(const enum zynqmp_pm_reset reset,
+static inline int zynqmp_pm_reset_assert(const u32 reset,
 					 const enum zynqmp_pm_reset_action assert_flag)
 {
 	return -ENODEV;
 }
 
-static inline int zynqmp_pm_reset_get_status(const enum zynqmp_pm_reset reset,
-					     u32 *status)
+static inline int zynqmp_pm_reset_get_status(const u32 reset, u32 *status)
 {
 	return -ENODEV;
 }
@@ -750,59 +837,37 @@
 	return -ENODEV;
 }
 
-static inline int zynqmp_pm_aes_engine(const u64 address, u32 *out)
-{
-	return -ENODEV;
-}
-
-static inline int zynqmp_pm_efuse_access(const u64 address, u32 *out)
-{
-	return -ENODEV;
-}
-
-static inline int zynqmp_pm_sha_hash(const u64 address, const u32 size,
-				     const u32 flags)
-{
-	return -ENODEV;
-}
-
-static inline int zynqmp_pm_fpga_load(const u64 address, const u32 size,
-				      const u32 flags)
-{
-	return -ENODEV;
-}
-
-static inline int zynqmp_pm_fpga_get_status(u32 *value)
+static inline int zynqmp_pm_write_ggs(u32 index, u32 value)
 {
 	return -ENODEV;
 }
 
-static inline int zynqmp_pm_fpga_get_config_status(u32 *value)
+static inline int zynqmp_pm_read_ggs(u32 index, u32 *value)
 {
 	return -ENODEV;
 }
 
-static inline int zynqmp_pm_write_ggs(u32 index, u32 value)
+static inline int zynqmp_pm_write_pggs(u32 index, u32 value)
 {
 	return -ENODEV;
 }
 
-static inline int zynqmp_pm_read_ggs(u32 index, u32 *value)
+static inline int zynqmp_pm_read_pggs(u32 index, u32 *value)
 {
 	return -ENODEV;
 }
 
-static inline int zynqmp_pm_write_pggs(u32 index, u32 value)
+static inline int zynqmp_pm_set_tapdelay_bypass(u32 index, u32 value)
 {
 	return -ENODEV;
 }
 
-static inline int zynqmp_pm_read_pggs(u32 index, u32 *value)
+static inline int zynqmp_pm_afi(u32 index, u32 value)
 {
 	return -ENODEV;
 }
 
-static inline int zynqmp_pm_set_tapdelay_bypass(u32 index, u32 value)
+static inline int zynqmp_pm_usb_set_state(u32 node, u32 state, u32 value)
 {
 	return -ENODEV;
 }
@@ -849,7 +914,9 @@
 	return -ENODEV;
 }
 
-static inline int zynqmp_pm_load_pdi(const u32 src, const u64 address)
+static inline int zynqmp_pm_config_reg_access(u32 register_access_id,
+					      u32 address, u32 mask, u32 value,
+					      u32 *out)
 {
 	return -ENODEV;
 }
@@ -896,6 +963,17 @@
 	return -ENODEV;
 }
 
+static inline int zynqmp_pm_sec_read_reg(u32 node_id, u32 offset, u32 *ret_value)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_sec_mask_write_reg(const u32 node_id, const u32 offset,
+					       u32 mask, u32 value)
+{
+	return -ENODEV;
+}
+
 static inline int zynqmp_pm_get_rpu_mode(u32 node_id, enum rpu_oper_mode *rpu_mode)
 {
 	return -ENODEV;
@@ -911,6 +989,13 @@
 	return -ENODEV;
 }
 
+static inline int zynqmp_pm_get_node_status(const u32 node, u32 *const status,
+					    u32 *const requirements,
+					    u32 *const usage)
+{
+	return -ENODEV;
+}
+
 static inline int zynqmp_pm_set_sd_config(u32 node,
 					  enum pm_sd_config_type config,
 					  u32 value)
@@ -918,6 +1003,11 @@
 	return -ENODEV;
 }
 
+static inline int zynqmp_pm_get_qos(u32 node, u32 *const def_qos, u32 *const qos)
+{
+	return -ENODEV;
+}
+
 static inline int zynqmp_pm_set_gem_config(u32 node,
 					   enum pm_gem_config_type config,
 					   u32 value)
@@ -925,6 +1015,22 @@
 	return -ENODEV;
 }
 
+static inline int zynqmp_pm_get_last_reset_reason(u32 *reset_reason)
+{
+	return -ENODEV;
+}
+
+static inline int zynqmp_pm_aie_operation(u32 node, u16 start_col,
+					  u16 num_col, u32 operation)
+{
+	return -ENODEV;
+}
+
+static inline int versal2_pm_aie2ps_operation(u32 node, u32 size, u32 addr_high,
+					      u32 addr_low)
+{
+	return -ENODEV;
+}
 #endif
 
 #endif /* __FIRMWARE_ZYNQMP_H__ */
