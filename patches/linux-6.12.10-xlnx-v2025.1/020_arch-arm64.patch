diff -urN '--label=/dev/null' /dev/null linux-xlnx-2025.1/Documentation/devicetree/bindings/arm/zynq/zynq-efuse.txt
--- /dev/null
+++ linux-xlnx-2025.1/Documentation/devicetree/bindings/arm/zynq/zynq-efuse.txt	2025-07-02 12:01:11.199708500 +0900
@@ -0,0 +1,15 @@
+Device tree bindings for Zynq's eFuse Controller
+
+The Zynq eFuse controller provides the access to the chip efuses which contain
+information about device DNA, security settings and also device status.
+
+Required properties:
+ compatible: Compatibility string. Must be "xlnx,zynq-efuse".
+ reg: Specify the base and size of the EFUSE controller registers
+      in the memory map. E.g.: reg = <0xf800d000 0x20>;
+
+Example:
+efuse: efuse@f800d000 {
+	compatible = "xlnx,zynq-efuse";
+	reg = <0xf800d000 0x20>;
+};
--- linux-6.12.10/arch/arm64/kernel/irq.c	2025-07-02 11:58:33.918995500 +0900
+++ linux-xlnx-2025.1/arch/arm64/kernel/irq.c	2025-07-02 12:01:17.491853100 +0900
@@ -100,7 +100,11 @@
 void (*handle_arch_irq)(struct pt_regs *) __ro_after_init = default_handle_irq;
 void (*handle_arch_fiq)(struct pt_regs *) __ro_after_init = default_handle_fiq;
 
+#ifndef CONFIG_IRQCHIP_XILINX_INTC_MODULE_SUPPORT_EXPERIMENTAL
 int __init set_handle_irq(void (*handle_irq)(struct pt_regs *))
+#else
+int set_handle_irq(void (*handle_irq)(struct pt_regs *))
+#endif
 {
 	if (handle_arch_irq != default_handle_irq)
 		return -EBUSY;
--- linux-6.12.10/arch/arm64/xen/hypercall.S	2025-07-02 11:58:34.014857400 +0900
+++ linux-xlnx-2025.1/arch/arm64/xen/hypercall.S	2025-07-02 12:01:17.589856300 +0900
@@ -83,7 +83,26 @@
 HYPERCALL1(platform_op_raw);
 HYPERCALL2(multicall);
 HYPERCALL2(vm_assist);
-HYPERCALL3(dm_op);
+
+SYM_FUNC_START(HYPERVISOR_dm_op)
+	mov x16, #__HYPERVISOR_dm_op;	\
+	/*
+	 * dm_op hypercalls are issued by the userspace. The kernel needs to
+	 * enable access to TTBR0_EL1 as the hypervisor would issue stage 1
+	 * translations to user memory via AT instructions. Since AT
+	 * instructions are not affected by the PAN bit (ARMv8.1), we only
+	 * need the explicit uaccess_enable/disable if the TTBR0 PAN emulation
+	 * is enabled (it implies that hardware UAO and PAN disabled).
+	 */
+	uaccess_ttbr0_enable x6, x7, x8
+	hvc XEN_IMM
+
+	/*
+	 * Disable userspace access from kernel once the hyp call completed.
+	 */
+	uaccess_ttbr0_disable x6, x7
+	ret
+SYM_FUNC_END(HYPERVISOR_dm_op);
 
 SYM_FUNC_START(privcmd_call)
 	mov x16, x0
