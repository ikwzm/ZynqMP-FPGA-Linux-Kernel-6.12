--- /dev/null
+++ linux-xlnx-2025.1/Documentation/devicetree/bindings/thermal/xlnx,versal-thermal.yaml	2025-07-02 12:01:13.225764200 +0900
@@ -0,0 +1,50 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+# Copyright 2024 Advanced Micro Devices Inc.
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/thermal/xlnx,versal-thermal.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx Versal Thermal
+
+maintainers:
+  - Salih Erim <salih.erim@amd.com>
+
+description:
+  Versal Thermal uses Versal Sysmon hardware for temperature reading
+  It works as sensor interface to be defined in thermal zones.
+  IIO binding channel through Sysmon required to use as temperature
+  sensor. It uses sysmon-temp-channel mapped in the Sysmon driver.
+  name to expose temperature information.
+  Exposed temperature value is converted to millicelcius scale.
+
+properties:
+  compatible:
+    const: xlnx,versal-thermal
+
+  '#thermal-sensor-cells':
+    const: 0
+
+  io-channels:
+    maxItems: 1
+
+  io-channel-names:
+    const: sysmon-temp-channel
+
+required:
+  - compatible
+  - '#thermal-sensor-cells'
+  - io-channels
+  - io-channel-names
+
+additionalProperties: false
+
+examples:
+  - |
+    versal-thermal-sensor {
+        compatible = "xlnx,versal-thermal";
+        #thermal-sensor-cells = <0>;
+        io-channels = <&sysmon0>;
+        io-channel-names = "sysmon-temp-channel";
+    };
+...
--- linux-6.12.10/drivers/thermal/Kconfig	2025-07-02 11:58:52.637620600 +0900
+++ linux-xlnx-2025.1/drivers/thermal/Kconfig	2025-07-02 12:01:36.504271200 +0900
@@ -499,4 +499,16 @@
 	  is higher than the high temperature threshold or lower than the low
 	  temperature threshold, the interrupt will occur.
 
+config VERSAL_THERMAL
+	tristate "Versal thermal sensor driver"
+	depends on OF
+	depends on VERSAL_SYSMON
+	help
+	  This adds support for Versal thermal driver as thermal zone sensor
+	  The thermal driver is connected to Versal Sysmon for the temperature
+	  channel via iio binding. The Sysmon channel is read via IIO framework
+	  and the channel information is provided to driver.
+	  The driver can also be build as a module. If so, the module will be called
+	  versal_thermal
+
 endif
--- linux-6.12.10/drivers/thermal/Makefile	2025-07-02 11:58:52.637620600 +0900
+++ linux-xlnx-2025.1/drivers/thermal/Makefile	2025-07-02 12:01:36.504271200 +0900
@@ -64,3 +64,4 @@
 obj-$(CONFIG_KHADAS_MCU_FAN_THERMAL)	+= khadas_mcu_fan.o
 obj-$(CONFIG_LOONGSON2_THERMAL)	+= loongson2_thermal.o
 obj-$(CONFIG_THERMAL_CORE_TESTING)	+= testing/
+obj-$(CONFIG_VERSAL_THERMAL)	+= versal_thermal.o
--- /dev/null
+++ linux-xlnx-2025.1/drivers/thermal/versal_thermal.c	2025-07-02 12:01:36.564089000 +0900
@@ -0,0 +1,90 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx Versal Thermal Driver
+ * for Versal Devices
+ *
+ * Copyright (C) 2024 Advanced Micro Devices, Inc.
+ *
+ * Author: Salih Erim <salih.erim@amd.com>
+ */
+
+#include <linux/iio/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/thermal.h>
+
+#include "thermal_hwmon.h"
+
+#define SYSMON_TEMP_CH_NAME "sysmon-temp-channel"
+#define SYSMON_FRACTIONAL_DENOM	128
+
+struct versal_thermal_info {
+	struct device *dev;
+	struct thermal_zone_device *tzd;
+	struct iio_channel *channel;
+};
+
+static int temperature_sensor_get_temp(struct thermal_zone_device *tz, int *temp)
+{
+	struct versal_thermal_info *vti = thermal_zone_device_priv(tz);
+	int ret, val;
+
+	ret = iio_read_channel_processed(vti->channel, &val);
+	if (ret == IIO_VAL_FRACTIONAL) {
+		/* Convert raw value to temperature in millidegrees Celsius */
+		*temp = val * 1000;
+		*temp /= SYSMON_FRACTIONAL_DENOM;
+	} else if (ret == IIO_VAL_INT) {
+		*temp = val;
+	} else {
+		dev_err(vti->dev, "iio_read_channel_processed failed, ret code = %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static const struct thermal_zone_device_ops thermal_zone_ops = {
+	.get_temp = temperature_sensor_get_temp,
+};
+
+static int versal_thermal_probe(struct platform_device *pdev)
+{
+	struct versal_thermal_info *vti;
+
+	vti = devm_kzalloc(&pdev->dev, sizeof(struct versal_thermal_info), GFP_KERNEL);
+	if (!vti)
+		return -ENOMEM;
+
+	vti->channel = devm_iio_channel_get(&pdev->dev, SYSMON_TEMP_CH_NAME);
+	if (IS_ERR(vti->channel))
+		return dev_err_probe(&pdev->dev, PTR_ERR(vti->channel),
+				     "IIO channel not found\n");
+
+	vti->dev = &pdev->dev;
+
+	vti->tzd = devm_thermal_of_zone_register(&pdev->dev, 0, vti, &thermal_zone_ops);
+	if (IS_ERR(vti->tzd))
+		return dev_err_probe(&pdev->dev, PTR_ERR(vti->tzd),
+				     "Thermal zone sensor register failed\n");
+
+	return devm_thermal_add_hwmon_sysfs(&pdev->dev, vti->tzd);
+}
+
+static const struct of_device_id versal_thermal_of_match[] = {
+	{ .compatible = "xlnx,versal-thermal", },
+	{ /* end of list */ },
+};
+MODULE_DEVICE_TABLE(of, versal_thermal_of_match);
+
+static struct platform_driver versal_thermal_driver = {
+	.driver = {
+		.name = "versal-thermal",
+		.of_match_table	= versal_thermal_of_match,
+	},
+	.probe = versal_thermal_probe,
+};
+
+module_platform_driver(versal_thermal_driver);
+
+MODULE_AUTHOR("Salih Erim <salih.erim@amd.com>");
+MODULE_DESCRIPTION("XILINX Versal Thermal Driver");
+MODULE_LICENSE("GPL");
