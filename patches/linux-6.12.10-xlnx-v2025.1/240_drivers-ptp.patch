--- /dev/null
+++ linux-xlnx-2025.1/Documentation/devicetree/bindings/ptp/ptp-xilinx.yaml	2025-07-02 12:01:12.760175700 +0900
@@ -0,0 +1,50 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/ptp/ptp-xilinx.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx 1588 PTP timer-syncer
+
+maintainers:
+  - Harini Katakam <harini.katakam@xilinx.com>
+
+description: |
+  Xilinx 1588 PTP timer-syncer IP provides  precision timing functionality
+  along with capability for time and fine adjustment. This IP is provided
+  for use with Xilinx Ethernet MAC with HW timestamping capability.
+
+properties:
+  compatible:
+    enum:
+      - xlnx,timer-syncer-1588-1.0 # Deprecated
+      - xlnx,timer-syncer-1588-2.0
+      - xlnx,timer-syncer-1588-3.0
+
+  reg:
+    description: |
+      Offset and length of the register set for the device.
+
+  xlnx,has-timer-syncer:
+    type: boolean
+    description: |
+      Describes the timerIP modes. Supported modes are system timer,
+      system and port timer mode. If property is present then its
+      a system timer mode else system and port timer mode.
+
+  interrupts:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+
+additionalProperties: false
+
+examples:
+  - |
+    ptp_timer@80000000 {
+        compatible = "xlnx,timer-syncer-1588-2.0";
+        reg = <0x80000000 0x10000>;
+        xlnx,has-timer-syncer;
+    };
--- linux-6.12.10/drivers/ptp/Kconfig	2025-07-02 11:58:50.861427500 +0900
+++ linux-xlnx-2025.1/drivers/ptp/Kconfig	2025-07-02 12:01:34.721497000 +0900
@@ -190,6 +190,16 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called ptp_vmw.
 
+config PTP_1588_CLOCK_XILINX
+	tristate "XILINX PTP clock"
+	depends on PTP_1588_CLOCK
+	help
+	  This driver adds support for Xilinx PTP clock. It provides
+	  timer-syncer support with time and fine adjustment capabilities.
+
+	  It is usually used with Xilinx AXI Ethernet driver with HW
+	  timestamping support.
+
 config PTP_1588_CLOCK_OCP
 	tristate "OpenCompute TimeCard as PTP clock"
 	depends on PTP_1588_CLOCK
--- linux-6.12.10/drivers/ptp/Makefile	2025-07-02 11:58:50.861427500 +0900
+++ linux-xlnx-2025.1/drivers/ptp/Makefile	2025-07-02 12:01:34.722494700 +0900
@@ -11,6 +11,7 @@
 obj-$(CONFIG_PTP_1588_CLOCK_INES)	+= ptp_ines.o
 obj-$(CONFIG_PTP_1588_CLOCK_PCH)	+= ptp_pch.o
 obj-$(CONFIG_PTP_1588_CLOCK_KVM)	+= ptp_kvm.o
+obj-$(CONFIG_PTP_1588_CLOCK_XILINX)	+= ptp_xilinx.o
 obj-$(CONFIG_PTP_1588_CLOCK_QORIQ)	+= ptp-qoriq.o
 ptp-qoriq-y				+= ptp_qoriq.o
 ptp-qoriq-$(CONFIG_DEBUG_FS)		+= ptp_qoriq_debugfs.o
--- linux-6.12.10/drivers/ptp/ptp_clockmatrix.c	2025-07-02 11:58:50.863422500 +0900
+++ linux-xlnx-2025.1/drivers/ptp/ptp_clockmatrix.c	2025-07-02 12:01:34.723491900 +0900
@@ -41,8 +41,8 @@
 static int _idtcm_adjfine(struct idtcm_channel *channel, long scaled_ppm);
 
 static inline int idtcm_read(struct idtcm *idtcm,
-			     u16 module,
-			     u16 regaddr,
+			     u32 module,
+			     u32 regaddr,
 			     u8 *buf,
 			     u16 count)
 {
@@ -50,8 +50,8 @@
 }
 
 static inline int idtcm_write(struct idtcm *idtcm,
-			      u16 module,
-			      u16 regaddr,
+			      u32 module,
+			      u32 regaddr,
 			      u8 *buf,
 			      u16 count)
 {
@@ -62,7 +62,8 @@
 				       const struct firmware *fw)
 {
 	struct idtcm_fwrc *rec = (struct idtcm_fwrc *)fw->data;
-	u16 scratch = IDTCM_FW_REG(idtcm->fw_ver, V520, SCRATCH);
+	u16 scratch = SCSR_ADDR(IDTCM_FW_REG(idtcm->fw_ver, V520, SCRATCH));
+	u16 gpio_control = SCSR_ADDR(GPIO_USER_CONTROL);
 	s32 full_count;
 	s32 count = 0;
 	u16 regaddr;
@@ -70,8 +71,8 @@
 	s32 len;
 
 	/* 4 bytes skipped every 0x80 */
-	full_count = (scratch - GPIO_USER_CONTROL) -
-		     ((scratch >> 7) - (GPIO_USER_CONTROL >> 7)) * 4;
+	full_count = (scratch - gpio_control) -
+		     ((scratch >> 7) - (gpio_control >> 7)) * 4;
 
 	/* If the firmware contains 'full configuration' SM_RESET can be used
 	 * to ensure proper configuration.
@@ -88,7 +89,7 @@
 		rec++;
 
 		/* Top (status registers) and bottom are read-only */
-		if (regaddr < GPIO_USER_CONTROL || regaddr >= scratch)
+		if (regaddr < gpio_control || regaddr >= scratch)
 			continue;
 
 		/* Page size 128, last 4 bytes of page skipped */
@@ -506,8 +507,8 @@
 {
 	int err;
 	u8 val;
-	u16 sync_ctrl0;
-	u16 sync_ctrl1;
+	u32 sync_ctrl0;
+	u32 sync_ctrl1;
 	u8 temp;
 
 	if (qn == 0 && qn_plus_1 == 0)
@@ -553,11 +554,11 @@
 	val = SYNCTRL1_MASTER_SYNC_RST;
 
 	/* Place master sync in reset */
-	err = idtcm_write(idtcm, 0, sync_ctrl1, &val, sizeof(val));
+	err = idtcm_write(idtcm, sync_ctrl1, 0, &val, sizeof(val));
 	if (err)
 		return err;
 
-	err = idtcm_write(idtcm, 0, sync_ctrl0, &sync_src, sizeof(sync_src));
+	err = idtcm_write(idtcm, sync_ctrl0, 0, &sync_src, sizeof(sync_src));
 	if (err)
 		return err;
 
@@ -570,27 +571,27 @@
 	if (qn_plus_1)
 		val |= SYNCTRL1_Q1_DIV_SYNC_TRIG;
 
-	err = idtcm_write(idtcm, 0, sync_ctrl1, &val, sizeof(val));
+	err = idtcm_write(idtcm, sync_ctrl1, 0, &val, sizeof(val));
 	if (err)
 		return err;
 
 	/* PLL5 can have OUT8 as second additional output. */
 	if (pll == 5 && qn_plus_1 != 0) {
-		err = idtcm_read(idtcm, 0, HW_Q8_CTRL_SPARE,
+		err = idtcm_read(idtcm, HW_Q8_CTRL_SPARE, 0,
 				 &temp, sizeof(temp));
 		if (err)
 			return err;
 
 		temp &= ~(Q9_TO_Q8_SYNC_TRIG);
 
-		err = idtcm_write(idtcm, 0, HW_Q8_CTRL_SPARE,
+		err = idtcm_write(idtcm, HW_Q8_CTRL_SPARE, 0,
 				  &temp, sizeof(temp));
 		if (err)
 			return err;
 
 		temp |= Q9_TO_Q8_SYNC_TRIG;
 
-		err = idtcm_write(idtcm, 0, HW_Q8_CTRL_SPARE,
+		err = idtcm_write(idtcm, HW_Q8_CTRL_SPARE, 0,
 				  &temp, sizeof(temp));
 		if (err)
 			return err;
@@ -598,21 +599,21 @@
 
 	/* PLL6 can have OUT11 as second additional output. */
 	if (pll == 6 && qn_plus_1 != 0) {
-		err = idtcm_read(idtcm, 0, HW_Q11_CTRL_SPARE,
+		err = idtcm_read(idtcm, HW_Q11_CTRL_SPARE, 0,
 				 &temp, sizeof(temp));
 		if (err)
 			return err;
 
 		temp &= ~(Q10_TO_Q11_SYNC_TRIG);
 
-		err = idtcm_write(idtcm, 0, HW_Q11_CTRL_SPARE,
+		err = idtcm_write(idtcm, HW_Q11_CTRL_SPARE, 0,
 				  &temp, sizeof(temp));
 		if (err)
 			return err;
 
 		temp |= Q10_TO_Q11_SYNC_TRIG;
 
-		err = idtcm_write(idtcm, 0, HW_Q11_CTRL_SPARE,
+		err = idtcm_write(idtcm, HW_Q11_CTRL_SPARE, 0,
 				  &temp, sizeof(temp));
 		if (err)
 			return err;
@@ -620,7 +621,7 @@
 
 	/* Place master sync out of reset */
 	val &= ~(SYNCTRL1_MASTER_SYNC_RST);
-	err = idtcm_write(idtcm, 0, sync_ctrl1, &val, sizeof(val));
+	err = idtcm_write(idtcm, sync_ctrl1, 0, &val, sizeof(val));
 
 	return err;
 }
@@ -637,7 +638,7 @@
 	u8 temp;
 	u16 output_mask = channel->output_mask;
 
-	err = idtcm_read(idtcm, 0, HW_Q8_CTRL_SPARE,
+	err = idtcm_read(idtcm, HW_Q8_CTRL_SPARE, 0,
 			 &temp, sizeof(temp));
 	if (err)
 		return err;
@@ -646,7 +647,7 @@
 	    Q9_TO_Q8_FANOUT_AND_CLOCK_SYNC_ENABLE_MASK)
 		out8_mux = 1;
 
-	err = idtcm_read(idtcm, 0, HW_Q11_CTRL_SPARE,
+	err = idtcm_read(idtcm, HW_Q11_CTRL_SPARE, 0,
 			 &temp, sizeof(temp));
 	if (err)
 		return err;
@@ -1037,7 +1038,7 @@
 	s64 now;
 
 	if (abs(delta) < PHASE_PULL_IN_THRESHOLD_NS_DEPRECATED) {
-		err = channel->do_phase_pull_in(channel, delta, 0);
+		err = channel->do_phase_pull_in(channel, delta, channel->caps.max_adj);
 	} else {
 		idtcm->calculate_overhead_flag = 1;
 
@@ -1253,7 +1254,7 @@
 static int idtcm_load_firmware(struct idtcm *idtcm,
 			       struct device *dev)
 {
-	u16 scratch = IDTCM_FW_REG(idtcm->fw_ver, V520, SCRATCH);
+	u16 scratch = SCSR_ADDR(IDTCM_FW_REG(idtcm->fw_ver, V520, SCRATCH));
 	char fname[128] = FW_FILENAME;
 	const struct firmware *fw;
 	struct idtcm_fwrc *rec;
@@ -1303,14 +1304,14 @@
 			err = 0;
 
 			/* Top (status registers) and bottom are read-only */
-			if (regaddr < GPIO_USER_CONTROL || regaddr >= scratch)
+			if (regaddr < SCSR_ADDR(GPIO_USER_CONTROL) || regaddr >= scratch)
 				continue;
 
 			/* Page size 128, last 4 bytes of page skipped */
 			if ((loaddr > 0x7b && loaddr <= 0x7f) || loaddr > 0xfb)
 				continue;
 
-			err = idtcm_write(idtcm, regaddr, 0, &val, sizeof(val));
+			err = idtcm_write(idtcm, SCSR_BASE, regaddr, &val, sizeof(val));
 		}
 
 		if (err)
@@ -1340,7 +1341,7 @@
 		return base;
 	}
 
-	err = idtcm_read(idtcm, (u16)base, OUT_CTRL_1, &val, sizeof(val));
+	err = idtcm_read(idtcm, (u32)base, OUT_CTRL_1, &val, sizeof(val));
 	if (err)
 		return err;
 
@@ -1349,7 +1350,7 @@
 	else
 		val &= ~SQUELCH_DISABLE;
 
-	return idtcm_write(idtcm, (u16)base, OUT_CTRL_1, &val, sizeof(val));
+	return idtcm_write(idtcm, (u32)base, OUT_CTRL_1, &val, sizeof(val));
 }
 
 static int idtcm_perout_enable(struct idtcm_channel *channel,
@@ -1395,6 +1396,20 @@
 	struct idtcm *idtcm = channel->idtcm;
 	int err;
 	u8 dpll_mode;
+	u8 buf[2] = {0};
+
+	/* Setup WF/WP timer for phase pull-in to work correctly */
+	err = idtcm_write(idtcm, channel->dpll_n, DPLL_WF_TIMER,
+			  buf, sizeof(buf));
+	if (err)
+		return err;
+
+	if (mode == PLL_MODE_WRITE_PHASE)
+		buf[0] = 160;
+	err = idtcm_write(idtcm, channel->dpll_n, DPLL_WP_TIMER,
+			  buf, sizeof(buf));
+	if (err)
+		return err;
 
 	err = idtcm_read(idtcm, channel->dpll_n,
 			 IDTCM_FW_REG(idtcm->fw_ver, V520, DPLL_MODE),
@@ -1579,7 +1594,7 @@
 	if (abs(delta_ns) < PHASE_PULL_IN_MIN_THRESHOLD_NS)
 		return 0;
 
-	if (max_ffo_ppb == 0)
+	if (max_ffo_ppb == 0 || max_ffo_ppb > PHASE_PULL_IN_MAX_PPB)
 		max_ffo_ppb = PHASE_PULL_IN_MAX_PPB;
 
 	/* For most cases, keep phase pull-in duration 1 second */
@@ -1713,10 +1728,10 @@
 static int _idtcm_adjphase(struct idtcm_channel *channel, s32 delta_ns)
 {
 	struct idtcm *idtcm = channel->idtcm;
-	int err;
-	u8 i;
 	u8 buf[4] = {0};
 	s32 phase_50ps;
+	int err;
+	u8 i;
 
 	if (channel->mode != PTP_PLL_MODE_WRITE_PHASE) {
 		err = channel->configure_write_phase(channel);
@@ -1865,7 +1880,7 @@
 	mutex_lock(idtcm->lock);
 
 	if (abs(delta) < PHASE_PULL_IN_THRESHOLD_NS) {
-		err = channel->do_phase_pull_in(channel, delta, 0);
+		err = channel->do_phase_pull_in(channel, delta, channel->caps.max_adj);
 	} else {
 		if (delta >= 0) {
 			ts = ns_to_timespec64(delta);
@@ -1912,9 +1927,6 @@
 	if (channel->phase_pull_in == true)
 		return 0;
 
-	if (scaled_ppm == channel->current_freq_scaled_ppm)
-		return 0;
-
 	mutex_lock(idtcm->lock);
 	err = _idtcm_adjfine(channel, scaled_ppm);
 	mutex_unlock(idtcm->lock);
@@ -2039,7 +2051,7 @@
 
 static const struct ptp_clock_info idtcm_caps = {
 	.owner		= THIS_MODULE,
-	.max_adj	= 244000,
+	.max_adj	= MAX_FFO_PPB,
 	.n_per_out	= 12,
 	.n_ext_ts	= MAX_TOD,
 	.n_pins		= MAX_REF_CLK,
@@ -2056,7 +2068,7 @@
 
 static const struct ptp_clock_info idtcm_caps_deprecated = {
 	.owner		= THIS_MODULE,
-	.max_adj	= 244000,
+	.max_adj	= MAX_FFO_PPB,
 	.n_per_out	= 12,
 	.n_ext_ts	= MAX_TOD,
 	.n_pins		= MAX_REF_CLK,
@@ -2150,7 +2162,7 @@
 
 /*
  * Compensate for the PTP DCO input-to-output delay.
- * This delay is 18 FOD cycles.
+ * This delay is 20 FOD cycles + 8ns.
  */
 static u32 idtcm_get_dco_delay(struct idtcm_channel *channel)
 {
@@ -2181,7 +2193,7 @@
 	fodFreq = (u32)div_u64(m, n);
 
 	if (fodFreq >= 500000000)
-		return (u32)div_u64(18 * (u64)NSEC_PER_SEC, fodFreq);
+		return (u32)div_u64(20 * (u64)NSEC_PER_SEC, fodFreq) + 8;
 
 	return 0;
 }
@@ -2227,6 +2239,25 @@
 	return 0;
 }
 
+static int initialize_max_adj(struct idtcm_channel *channel)
+{
+	struct idtcm *idtcm = channel->idtcm;
+	u8 ffo_ppm;
+	int err;
+
+	err = idtcm_read(idtcm, channel->dpll_n, DPLL_MAX_FREQ_OFFSET,
+			 &ffo_ppm, sizeof(ffo_ppm));
+	if (err)
+		return err;
+
+	if (ffo_ppm && ffo_ppm <= (MAX_FFO_PPB / 1000))
+		channel->caps.max_adj = ffo_ppm * 1000;
+	else
+		channel->caps.max_adj = MAX_FFO_PPB;
+
+	return 0;
+}
+
 static int idtcm_enable_channel(struct idtcm *idtcm, u32 index)
 {
 	struct idtcm_channel *channel;
@@ -2270,6 +2301,10 @@
 		ppd->chan = index;
 	}
 
+	err = initialize_max_adj(channel);
+	if (err)
+		return err;
+
 	err = initialize_dco_operating_mode(channel);
 	if (err)
 		return err;
@@ -2422,8 +2457,13 @@
 
 	err = idtcm_load_firmware(idtcm, &pdev->dev);
 
-	if (err)
+	if (err) {
+		if (err == -ENOENT) {
+			mutex_unlock(idtcm->lock);
+			return -EPROBE_DEFER;
+		}
 		dev_warn(idtcm->dev, "loading firmware failed with %d", err);
+	}
 
 	wait_for_chip_ready(idtcm);
 
--- linux-6.12.10/drivers/ptp/ptp_clockmatrix.h	2025-07-02 11:58:50.864419400 +0900
+++ linux-xlnx-2025.1/drivers/ptp/ptp_clockmatrix.h	2025-07-02 12:01:34.724489000 +0900
@@ -19,32 +19,7 @@
 #define MAX_REF_CLK	(16)
 
 #define MAX_ABS_WRITE_PHASE_NANOSECONDS (107374182L)
-
-#define TOD_MASK_ADDR		(0xFFA5)
-#define DEFAULT_TOD_MASK	(0x04)
-
-#define SET_U16_LSB(orig, val8) (orig = (0xff00 & (orig)) | (val8))
-#define SET_U16_MSB(orig, val8) (orig = (0x00ff & (orig)) | (val8 << 8))
-
-#define TOD0_PTP_PLL_ADDR		(0xFFA8)
-#define TOD1_PTP_PLL_ADDR		(0xFFA9)
-#define TOD2_PTP_PLL_ADDR		(0xFFAA)
-#define TOD3_PTP_PLL_ADDR		(0xFFAB)
-
-#define TOD0_OUT_ALIGN_MASK_ADDR	(0xFFB0)
-#define TOD1_OUT_ALIGN_MASK_ADDR	(0xFFB2)
-#define TOD2_OUT_ALIGN_MASK_ADDR	(0xFFB4)
-#define TOD3_OUT_ALIGN_MASK_ADDR	(0xFFB6)
-
-#define DEFAULT_OUTPUT_MASK_PLL0	(0x003)
-#define DEFAULT_OUTPUT_MASK_PLL1	(0x00c)
-#define DEFAULT_OUTPUT_MASK_PLL2	(0x030)
-#define DEFAULT_OUTPUT_MASK_PLL3	(0x0c0)
-
-#define DEFAULT_TOD0_PTP_PLL		(0)
-#define DEFAULT_TOD1_PTP_PLL		(1)
-#define DEFAULT_TOD2_PTP_PLL		(2)
-#define DEFAULT_TOD3_PTP_PLL		(3)
+#define MAX_FFO_PPB (244000)
 
 #define PHASE_PULL_IN_THRESHOLD_NS_DEPRECATED	(150000)
 #define PHASE_PULL_IN_THRESHOLD_NS		(15000)
@@ -54,21 +29,9 @@
 #define LOCK_TIMEOUT_MS			(2000)
 #define LOCK_POLL_INTERVAL_MS		(10)
 
-#define IDTCM_MAX_WRITE_COUNT		(512)
-
 #define PHASE_PULL_IN_MAX_PPB		(144000)
 #define PHASE_PULL_IN_MIN_THRESHOLD_NS	(2)
 
-/*
- * Return register address based on passed in firmware version
- */
-#define IDTCM_FW_REG(FW, VER, REG)	(((FW) < (VER)) ? (REG) : (REG##_##VER))
-enum fw_version {
-	V_DEFAULT = 0,
-	V487 = 1,
-	V520 = 2,
-};
-
 /* PTP PLL Mode */
 enum ptp_pll_mode {
 	PTP_PLL_MODE_MIN = 0,
@@ -84,16 +47,16 @@
 	struct ptp_clock_info	caps;
 	struct ptp_clock	*ptp_clock;
 	struct idtcm		*idtcm;
-	u16			dpll_phase;
-	u16			dpll_freq;
-	u16			dpll_n;
-	u16			dpll_ctrl_n;
-	u16			dpll_phase_pull_in;
-	u16			tod_read_primary;
-	u16			tod_read_secondary;
-	u16			tod_write;
-	u16			tod_n;
-	u16			hw_dpll_n;
+	u32			dpll_phase;
+	u32			dpll_freq;
+	u32			dpll_n;
+	u32			dpll_ctrl_n;
+	u32			dpll_phase_pull_in;
+	u32			tod_read_primary;
+	u32			tod_read_secondary;
+	u32			tod_write;
+	u32			tod_n;
+	u32			hw_dpll_n;
 	u8			sync_src;
 	enum ptp_pll_mode	mode;
 	int			(*configure_write_frequency)(struct idtcm_channel *channel);
@@ -132,11 +95,4 @@
 	ktime_t			start_time;
 };
 
-struct idtcm_fwrc {
-	u8 hiaddr;
-	u8 loaddr;
-	u8 value;
-	u8 reserved;
-} __packed;
-
 #endif /* PTP_IDTCLOCKMATRIX_H */
--- linux-6.12.10/drivers/ptp/ptp_idt82p33.h	2025-07-02 11:58:50.866414600 +0900
+++ linux-xlnx-2025.1/drivers/ptp/ptp_idt82p33.h	2025-07-02 12:01:34.726483700 +0900
@@ -23,25 +23,6 @@
 #define DDCO_THRESHOLD_NS	(5)
 #define IDT82P33_MAX_WRITE_COUNT	(512)
 
-#define PLLMASK_ADDR_HI	0xFF
-#define PLLMASK_ADDR_LO	0xA5
-
-#define PLL0_OUTMASK_ADDR_HI	0xFF
-#define PLL0_OUTMASK_ADDR_LO	0xB0
-
-#define PLL1_OUTMASK_ADDR_HI	0xFF
-#define PLL1_OUTMASK_ADDR_LO	0xB2
-
-#define PLL2_OUTMASK_ADDR_HI	0xFF
-#define PLL2_OUTMASK_ADDR_LO	0xB4
-
-#define PLL3_OUTMASK_ADDR_HI	0xFF
-#define PLL3_OUTMASK_ADDR_LO	0xB6
-
-#define DEFAULT_PLL_MASK	(0x01)
-#define DEFAULT_OUTPUT_MASK_PLL0	(0xc0)
-#define DEFAULT_OUTPUT_MASK_PLL1	DEFAULT_OUTPUT_MASK_PLL0
-
 /**
  * @brief Maximum absolute value for write phase offset in nanoseconds
  */
@@ -103,12 +84,4 @@
 	s64			tod_write_overhead_ns;
 };
 
-/* firmware interface */
-struct idt82p33_fwrc {
-	u8 hiaddr;
-	u8 loaddr;
-	u8 value;
-	u8 reserved;
-} __packed;
-
 #endif /* PTP_IDT82P33_H */
--- /dev/null
+++ linux-xlnx-2025.1/drivers/ptp/ptp_xilinx.c	2025-07-02 12:01:34.731543700 +0900
@@ -0,0 +1,533 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Xilinx 1588 PTP timer syncer driver
+ *
+ * Copyright (c) 2020 Xilinx, Inc. All rights reserved.
+ */
+
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/ptp_clock_kernel.h>
+#include <linux/platform_device.h>
+#include <linux/of_irq.h>
+#include <linux/ptp/ptp_xilinx.h>
+
+/* Register offset definitions */
+#define XPTPTIMER_TOD_CONFIG_OFFSET	0x0000
+#define XPTPTIMER_TOD_SNAPSHOT_OFFSET	0x0004
+#define XPTPTIMER_IER_OFFSET		0x0008
+#define XPTPTIMER_ISR_OFFSET		0x000C
+#define XPTPTIMER_TOD_SW_SEC_0_OFFSET	0x0010
+#define XPTPTIMER_TOD_SW_SEC_1_OFFSET	0x0014
+#define XPTPTIMER_TOD_SW_NS_OFFSET	0x0018
+#define XPTPTIMER_TOD_SW_LOAD_OFFSET	0x001C
+#define XPTPTIMER_TOD_SEC_SYS_OFST_0_OFFSET	0x0028
+#define XPTPTIMER_TOD_SEC_SYS_OFST_1_OFFSET	0x002C
+#define XPTPTIMER_TOD_NS_SYS_OFST_OFFSET	0x0030
+#define TOD_LEGACY_SYS_PERIOD_0		0x0130
+#define TOD_LEGACY_SYS_PERIOD_1		0x0134
+#define TOD_SYS_PERIOD_0		0x0034
+#define TOD_SYS_PERIOD_1		0x0038
+
+#define XPTPTIMER_SYS_SEC_0_OFFSET	0x0100
+#define XPTPTIMER_SYS_SEC_1_OFFSET	0x0104
+#define XPTPTIMER_SYS_NS_OFFSET		0x0108
+
+#define XPTPTIMER_PORT_TX_PERIOD_0_OFFSET	0x0208
+#define XPTPTIMER_PORT_TX_PERIOD_1_OFFSET	0x020C
+#define XPTPTIMER_PORT_TX_NS_SNAP_OFFSET	0x0214
+#define XPTPTIMER_PORT_TX_SEC_0_SNAP_OFFSET	0x0218
+#define XPTPTIMER_PORT_TX_SEC_1_SNAP_OFFSET	0x021C
+#define XPTPTIMER_PORT_RX_PERIOD_0_OFFSET	0x0228
+#define XPTPTIMER_PORT_RX_PERIOD_1_OFFSET	0x022C
+#define XPTPTIMER_PORT_RX_NS_SNAP_OFFSET	0x0234
+#define XPTPTIMER_PORT_RX_SEC_0_SNAP_OFFSET	0x0238
+#define XPTPTIMER_PORT_RX_SEC_1_SNAP_OFFSET	0x023C
+#define PORT0_SEC_OFFSET_0                     0x0250
+#define PORT0_SEC_OFFSET_1                     0x0254
+#define PORT0_NS_OFFSET_0                      0x0258
+
+#define XPTPTIMER_CFG_MAIN_TOD_EN	BIT(0)
+#define XPTPTIMER_CFG_ENABLE_PORT0	BIT(16)
+#define XPTPTIMER_CFG_AUTO_REF	BIT(4)
+
+#define XPTPTIMER_MAX_SEC_SIZE		48
+#define XPTPTIMER_MAX_SEC_MASK		GENMASK_ULL(XPTPTIMER_MAX_SEC_SIZE - 1, 0)
+
+#define XPTPTIMER_TOD_OFFSET_NEG	BIT_ULL(47)
+
+#define XPTPTIMER_SNAPSHOT_MASK		BIT(0)
+#define XPTPTIMER_LOAD_TOD_MASK		BIT(0)
+#define XPTPTIMER_LOAD_OFFSET_MASK	BIT(1)
+#define XPTPTIMER_ENABLE_SNAPSHOT BIT(5)
+#define XPTPTIMER_EXTS_1PPS_INTR_MASK  BIT(16)
+
+/* TODO This should be derived from the system design */
+#define XPTPTIMER_CLOCK_PERIOD		4
+#define XPTPTIMER_PERIOD_SHIFT		48
+
+#define PPM_FRACTION	16
+
+/* I/O accessors */
+static inline u32 xlnx_ptp_ior(struct xlnx_ptp_timer *timer, off_t reg)
+{
+	return ioread32(timer->baseaddr + reg);
+}
+
+static inline void xlnx_ptp_iow(struct xlnx_ptp_timer *timer, off_t reg,
+				u32 value)
+{
+	iowrite32(value, (timer->baseaddr + reg));
+}
+
+/*
+ * Inline timer helpers
+ */
+static inline void xlnx_tod_read(struct xlnx_ptp_timer *timer,
+				 struct timespec64 *ts)
+{
+	u32 sech, secl, nsec;
+
+	xlnx_ptp_iow(timer, XPTPTIMER_TOD_SNAPSHOT_OFFSET,
+		     XPTPTIMER_SNAPSHOT_MASK);
+
+	if (timer->use_sys_timer_only) {
+		nsec = xlnx_ptp_ior(timer, XPTPTIMER_SYS_NS_OFFSET);
+		sech = xlnx_ptp_ior(timer, XPTPTIMER_SYS_SEC_1_OFFSET);
+		secl = xlnx_ptp_ior(timer, XPTPTIMER_SYS_SEC_0_OFFSET);
+	} else {
+		/* use TX port here */
+		nsec = xlnx_ptp_ior(timer, XPTPTIMER_PORT_TX_NS_SNAP_OFFSET);
+		secl = xlnx_ptp_ior(timer, XPTPTIMER_PORT_TX_SEC_0_SNAP_OFFSET);
+		sech = xlnx_ptp_ior(timer, XPTPTIMER_PORT_TX_SEC_1_SNAP_OFFSET);
+	}
+
+	ts->tv_nsec = nsec;
+	ts->tv_sec = (((u64)sech << 32) | secl) & XPTPTIMER_MAX_SEC_MASK;
+}
+
+static inline void xlnx_port_offset_write(struct xlnx_ptp_timer *timer,
+					  const struct timespec64 *ts)
+{
+	int i;
+
+	xlnx_ptp_iow(timer, PORT0_SEC_OFFSET_0,
+		     lower_32_bits(ts->tv_sec));
+	xlnx_ptp_iow(timer, PORT0_SEC_OFFSET_1,
+		     upper_32_bits(ts->tv_sec));
+	/*
+	 * Two writes are done to PORT0_NS_OFFSET_0 due to IP behavior which
+	 * uses the same as trigger to accept the whole offset value.
+	 */
+	for (i = 0; i < 2; i++) {
+		xlnx_ptp_iow(timer, PORT0_NS_OFFSET_0,
+			     (u32)(ts->tv_nsec));
+	}
+}
+
+static inline void xlnx_tod_offset_write(struct xlnx_ptp_timer *timer,
+					 const struct timespec64 *ts)
+{
+	xlnx_ptp_iow(timer, XPTPTIMER_TOD_SEC_SYS_OFST_1_OFFSET,
+		     upper_32_bits(ts->tv_sec));
+	xlnx_ptp_iow(timer, XPTPTIMER_TOD_SEC_SYS_OFST_0_OFFSET,
+		     lower_32_bits(ts->tv_sec));
+	xlnx_ptp_iow(timer, XPTPTIMER_TOD_NS_SYS_OFST_OFFSET,
+		     (u32)(ts->tv_nsec));
+
+	xlnx_ptp_iow(timer, XPTPTIMER_TOD_SW_LOAD_OFFSET,
+		     XPTPTIMER_LOAD_OFFSET_MASK);
+}
+
+static inline void xlnx_tod_load_write(struct xlnx_ptp_timer *timer,
+				       const struct timespec64 *ts)
+{
+	struct timespec64 offset;
+
+	offset.tv_sec = 0;
+	offset.tv_nsec = 0;
+
+	xlnx_ptp_iow(timer, XPTPTIMER_TOD_SW_SEC_1_OFFSET,
+		     upper_32_bits(ts->tv_sec));
+	xlnx_ptp_iow(timer, XPTPTIMER_TOD_SW_SEC_0_OFFSET,
+		     lower_32_bits(ts->tv_sec));
+	xlnx_ptp_iow(timer, XPTPTIMER_TOD_SW_NS_OFFSET, ts->tv_nsec);
+
+	/* Make sure offset registers are cleared */
+	xlnx_tod_offset_write(timer, &offset);
+	xlnx_ptp_iow(timer, XPTPTIMER_TOD_SW_LOAD_OFFSET,
+		     XPTPTIMER_LOAD_OFFSET_MASK);
+
+	xlnx_ptp_iow(timer, XPTPTIMER_TOD_SW_LOAD_OFFSET,
+		     XPTPTIMER_LOAD_TOD_MASK);
+	xlnx_port_offset_write(timer, &offset);
+	timer->timeoffset = 0;
+}
+
+static inline void xlnx_tod_period_write(struct xlnx_ptp_timer *timer, u64 adj)
+{
+	u32 adjhigh = upper_32_bits(adj);
+
+	xlnx_ptp_iow(timer, timer->period_0, (u32)(adj));
+	xlnx_ptp_iow(timer, timer->period_1, adjhigh);
+}
+
+static inline void xlnx_port_period_write(struct xlnx_ptp_timer *timer, u64 adj)
+{
+	u32 adjhigh = upper_32_bits(adj);
+
+	xlnx_ptp_iow(timer, XPTPTIMER_PORT_TX_PERIOD_0_OFFSET, (u32)(adj));
+	xlnx_ptp_iow(timer, XPTPTIMER_PORT_RX_PERIOD_0_OFFSET, (u32)(adj));
+	spin_lock(&timer->reg_lock);
+	xlnx_ptp_iow(timer, XPTPTIMER_PORT_TX_PERIOD_1_OFFSET, adjhigh);
+	xlnx_ptp_iow(timer, XPTPTIMER_PORT_RX_PERIOD_1_OFFSET, adjhigh);
+
+	spin_unlock(&timer->reg_lock);
+}
+
+/*
+ * PTP clock operations
+ */
+/**
+ * xlnx_ptp_adjfine - Fine adjustment of the frequency on the hardware clock
+ * @ptp: ptp clock structure
+ * @scaled_ppm: signed scaled parts per million for frequency adjustment.
+ * Return: 0 on success
+ * TX and RX port periods are reloaded with the adjusted value.
+ *
+ */
+static int xlnx_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)
+{
+	struct xlnx_ptp_timer *timer = container_of(ptp, struct xlnx_ptp_timer,
+					ptp_clock_info);
+	bool neg_adj = false;
+	u64 adj;
+
+	if (scaled_ppm < 0) {
+		neg_adj = true;
+		scaled_ppm = -scaled_ppm;
+	}
+
+	adj = mul_u64_u32_div(timer->incr, scaled_ppm, USEC_PER_SEC);
+	adj >>= PPM_FRACTION; /* remove fractions */
+	adj = neg_adj ? (timer->incr - adj) : (timer->incr + adj);
+
+	if (timer->use_sys_timer_only)
+		xlnx_tod_period_write(timer, adj);
+	else
+		xlnx_port_period_write(timer, adj);
+
+	return 0;
+}
+
+/**
+ * xlnx_ptp_adjtime - Adjust the current time on the hardware clock
+ * @ptp: ptp clock structure
+ * @delta: signed time in ns to be adjusted.
+ * Return: 0 on success
+ * System, TX and RX ports are reloaded with the adjusted time.
+ *
+ */
+static int xlnx_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
+{
+	struct xlnx_ptp_timer *timer = container_of(ptp, struct xlnx_ptp_timer,
+						ptp_clock_info);
+	struct timespec64 offset;
+	u64 sign = 0;
+	s64 cumulative_delta = timer->timeoffset;
+
+	spin_lock(&timer->reg_lock);
+
+	/* Fixed offset between system and port timer */
+	if (!timer->use_sys_timer_only)
+		delta += timer->static_delay;
+	cumulative_delta += delta;
+	timer->timeoffset = cumulative_delta;
+	if (cumulative_delta < 0) {
+		sign = XPTPTIMER_TOD_OFFSET_NEG;
+		cumulative_delta = -cumulative_delta;
+	}
+	offset = ns_to_timespec64(cumulative_delta);
+	offset.tv_sec |= sign;
+
+	if (timer->use_sys_timer_only)
+		xlnx_tod_offset_write(timer, (const struct timespec64 *)&offset);
+	else
+		xlnx_port_offset_write(timer, (const struct timespec64 *)&offset);
+
+	spin_unlock(&timer->reg_lock);
+
+	return 0;
+}
+
+/**
+ * xlnx_ptp_gettime - Get the current time on the hardware clock
+ * @ptp: ptp clock structure
+ * @ts: timespec64 containing the current TX port timer time.
+ * Return: 0 on success
+ * Since TX and RX ports are initialized and adjusted simultaneously,
+ * they should be the same.
+ *
+ */
+static int xlnx_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)
+{
+	struct xlnx_ptp_timer *timer = container_of(ptp, struct xlnx_ptp_timer,
+						    ptp_clock_info);
+
+	spin_lock(&timer->reg_lock);
+	xlnx_tod_read(timer, ts);
+	spin_unlock(&timer->reg_lock);
+
+	return 0;
+}
+
+/**
+ * xlnx_ptp_settime - Set the current time on the hardware clock
+ * @ptp: ptp clock structure
+ * @ts: timespec64 containing the new time
+ * Return: 0 on success
+ *
+ * The hardware loads the entire new value when a load register is triggered.
+ */
+static int xlnx_ptp_settime(struct ptp_clock_info *ptp,
+			    const struct timespec64 *ts)
+{
+	struct xlnx_ptp_timer *timer = container_of(ptp, struct xlnx_ptp_timer,
+					ptp_clock_info);
+
+	spin_lock(&timer->reg_lock);
+	xlnx_tod_load_write(timer, ts);
+	spin_unlock(&timer->reg_lock);
+
+	return 0;
+}
+
+static int xlnx_ptp_enable(struct ptp_clock_info *ptp,
+			   struct ptp_clock_request *rq, int on)
+{
+	struct xlnx_ptp_timer *timer = container_of(ptp, struct xlnx_ptp_timer,
+			ptp_clock_info);
+	u32 data;
+
+	switch (rq->type) {
+	case PTP_CLK_REQ_EXTTS:
+		timer->extts_enable = on;
+
+		data = xlnx_ptp_ior(timer, XPTPTIMER_TOD_CONFIG_OFFSET);
+
+		data &= ~(XPTPTIMER_ENABLE_SNAPSHOT);
+
+		if (on)
+			data |= XPTPTIMER_ENABLE_SNAPSHOT;
+
+		xlnx_ptp_iow(timer, XPTPTIMER_TOD_CONFIG_OFFSET, data);
+
+		return 0;
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static struct ptp_clock_info xlnx_ptp_clock_info = {
+	.owner		= THIS_MODULE,
+	.name		= "Xilinx Timer",
+	.max_adj	= 64000000,	/* Safe max adjutment for clock rate */
+	.n_ext_ts	= 1,
+	.adjfine	= xlnx_ptp_adjfine,
+	.adjtime	= xlnx_ptp_adjtime,
+	.gettime64	= xlnx_ptp_gettime,
+	.settime64	= xlnx_ptp_settime,
+	.enable		= xlnx_ptp_enable,
+};
+
+/**
+ * xlnx_ptp_timer_isr - Interrupt Service Routine
+ * @irq:               IRQ number
+ * @priv:              pointer to the timer structure
+ * Return:	       IRQ_HANDLED on success. IRQ_NONE on failure
+ */
+static irqreturn_t xlnx_ptp_timer_isr(int irq, void *priv)
+{
+	struct xlnx_ptp_timer *timer = priv;
+	struct ptp_clock_event event;
+	u32 sech, secl, nsec;
+	int status;
+	u64 sec;
+
+	memset(&event, 0, sizeof(event));
+	status = xlnx_ptp_ior(timer, XPTPTIMER_ISR_OFFSET);
+	if (status & XPTPTIMER_EXTS_1PPS_INTR_MASK) {
+		xlnx_ptp_iow(timer, XPTPTIMER_ISR_OFFSET,
+			     XPTPTIMER_EXTS_1PPS_INTR_MASK);
+		if (timer->extts_enable) {
+			event.type = PTP_CLOCK_EXTTS;
+			nsec = xlnx_ptp_ior(timer, XPTPTIMER_SYS_NS_OFFSET);
+			sech = xlnx_ptp_ior(timer, XPTPTIMER_SYS_SEC_1_OFFSET);
+			secl = xlnx_ptp_ior(timer, XPTPTIMER_SYS_SEC_0_OFFSET);
+
+			sec = (((u64)sech << 32) | secl) & XPTPTIMER_MAX_SEC_MASK;
+			event.timestamp = ktime_set(sec, nsec);
+			ptp_clock_event(timer->ptp_clock, &event);
+		}
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+static int xlnx_ptp_timer_probe(struct platform_device *pdev)
+{
+	struct xlnx_ptp_timer *timer;
+	struct resource *r_mem;
+	int err = 0;
+	struct timespec64 ts, tsp;
+	u32 nsec, sech, secl;
+
+	if (of_device_is_compatible(pdev->dev.of_node, "xlnx,timer-syncer-1588-1.0")) {
+		dev_err(&pdev->dev, "This Beta version is no longer supported. Please upgrade to 2.0 IP version and use xlnx,timer-syncer-1588-2.0 compatible string\n");
+		return -EINVAL;
+	}
+
+	timer = devm_kzalloc(&pdev->dev, sizeof(*timer), GFP_KERNEL);
+	if (!timer)
+		return -ENOMEM;
+
+	timer->dev = &pdev->dev;
+
+	r_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	timer->baseaddr = devm_ioremap_resource(&pdev->dev, r_mem);
+	if (IS_ERR(timer->baseaddr)) {
+		err = PTR_ERR(timer->baseaddr);
+		return err;
+	}
+
+	timer->use_sys_timer_only = of_property_read_bool(pdev->dev.of_node,
+							  "xlnx,has-timer-syncer");
+
+	timer->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+	if (timer->irq <= 0) {
+		dev_warn(&pdev->dev, "could not determine Timer IRQ\n");
+	} else {
+		/* Enable interrupts */
+		err = devm_request_irq(timer->dev, timer->irq,
+				       xlnx_ptp_timer_isr,
+				       IRQF_SHARED,
+				       "xlnx_ptp_timer",
+				       timer);
+		if (err)
+			dev_warn(&pdev->dev, "Failed to request ptp timer irq\n");
+	}
+
+	spin_lock_init(&timer->reg_lock);
+
+	timer->ptp_clock_info = xlnx_ptp_clock_info;
+
+	timer->ptp_clock = ptp_clock_register(&timer->ptp_clock_info,
+					      &pdev->dev);
+	if (IS_ERR(timer->ptp_clock)) {
+		err = PTR_ERR(timer->ptp_clock);
+		dev_err(&pdev->dev, "Failed to register ptp clock\n");
+		return err;
+	}
+
+	if (timer->irq > 0)
+		/* Enable timer interrupt */
+		xlnx_ptp_iow(timer, XPTPTIMER_IER_OFFSET,
+			     XPTPTIMER_EXTS_1PPS_INTR_MASK);
+
+	timer->period_0 = TOD_LEGACY_SYS_PERIOD_0;
+	timer->period_1 = TOD_LEGACY_SYS_PERIOD_1;
+
+	if (of_device_is_compatible(pdev->dev.of_node, "xlnx,timer-syncer-1588-3.0")) {
+		timer->period_0 = TOD_SYS_PERIOD_0;
+		timer->period_1 = TOD_SYS_PERIOD_1;
+	}
+
+	xlnx_ptp_iow(timer, XPTPTIMER_TOD_CONFIG_OFFSET,
+		     XPTPTIMER_CFG_MAIN_TOD_EN | XPTPTIMER_CFG_ENABLE_PORT0);
+	/*
+	 * TODO: This clock rate should be derived from system design.
+	 * This is design specific - for ex. 250MHz port clock rate; period is
+	 * 10^9/250 is 4ns. Set port timer PERIOD BEFORE calling settime,
+	 * so that the initial LOAD triggers everything together.
+	 */
+	timer->incr = ((u64)XPTPTIMER_CLOCK_PERIOD << XPTPTIMER_PERIOD_SHIFT);
+	xlnx_tod_period_write(timer, timer->incr);
+	xlnx_port_period_write(timer, timer->incr);
+
+	/* Initialize current time */
+	ts = ns_to_timespec64(ktime_to_ns(ktime_get_real()));
+	xlnx_ptp_settime(&timer->ptp_clock_info, &ts);
+
+	/*
+	 * A static delay of 7-8 clock cycles is expected between system and
+	 * port timer which should be 28-32ns on this system with 250MHz clock.
+	 */
+	xlnx_ptp_iow(timer, XPTPTIMER_TOD_SNAPSHOT_OFFSET,
+		     XPTPTIMER_SNAPSHOT_MASK);
+	nsec = xlnx_ptp_ior(timer, XPTPTIMER_SYS_NS_OFFSET);
+	sech = xlnx_ptp_ior(timer, XPTPTIMER_SYS_SEC_1_OFFSET);
+	secl = xlnx_ptp_ior(timer, XPTPTIMER_SYS_SEC_0_OFFSET);
+	ts.tv_nsec = nsec;
+	ts.tv_sec = (((u64)sech << 32) | secl) & XPTPTIMER_MAX_SEC_MASK;
+
+	nsec = xlnx_ptp_ior(timer, XPTPTIMER_PORT_TX_NS_SNAP_OFFSET);
+	secl = xlnx_ptp_ior(timer, XPTPTIMER_PORT_TX_SEC_0_SNAP_OFFSET);
+	sech = xlnx_ptp_ior(timer, XPTPTIMER_PORT_TX_SEC_1_SNAP_OFFSET);
+	tsp.tv_nsec = nsec;
+	tsp.tv_sec = (((u64)sech << 32) | secl) & XPTPTIMER_MAX_SEC_MASK;
+
+	ts = timespec64_sub(ts, tsp);
+	timer->static_delay = timespec64_to_ns(&ts);
+	dev_dbg(&pdev->dev, "Static delay %d\n", timer->static_delay);
+
+	platform_set_drvdata(pdev, timer);
+
+	timer->phc_index = ptp_clock_index(timer->ptp_clock);
+	dev_info(&pdev->dev, "Xilinx PTP timer driver probed\n");
+
+	return 0;
+}
+
+static void xlnx_ptp_timer_remove(struct platform_device *pdev)
+{
+	struct xlnx_ptp_timer *timer = platform_get_drvdata(pdev);
+
+	if (timer->irq > 0)
+		/* Disable timer interrupt */
+		xlnx_ptp_iow(timer, XPTPTIMER_IER_OFFSET,
+			     (u32)~(XPTPTIMER_EXTS_1PPS_INTR_MASK));
+	ptp_clock_unregister(timer->ptp_clock);
+}
+
+static const struct of_device_id timer_1588_of_match[] = {
+	{ .compatible = "xlnx,timer-syncer-1588-1.0", },
+	{ .compatible = "xlnx,timer-syncer-1588-2.0", },
+	{ .compatible = "xlnx,timer-syncer-1588-3.0", },
+		{ /* end of table */ }
+};
+MODULE_DEVICE_TABLE(of, timer_1588_of_match);
+
+static struct platform_driver xlnx_ptp_timer_driver = {
+	.probe		= xlnx_ptp_timer_probe,
+	.remove		= xlnx_ptp_timer_remove,
+	.driver		= {
+		.name = "xlnx_ptp_timer",
+		.of_match_table = timer_1588_of_match,
+	},
+};
+
+module_platform_driver(xlnx_ptp_timer_driver);
+
+MODULE_AUTHOR("Xilinx, Inc.");
+MODULE_DESCRIPTION("PTP Timer Syncer driver");
+MODULE_LICENSE("GPL");
diff -urN '--label=/dev/null' /dev/null linux-xlnx-2025.1/include/linux/ptp/ptp_xilinx.h
--- /dev/null
+++ linux-xlnx-2025.1/include/linux/ptp/ptp_xilinx.h	2025-07-02 12:01:39.864657400 +0900
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Xilinx PTP driver header file
+ *
+ * Copyright (c) 2023 Advanced Micro Devices, Inc. All rights reserved.
+ */
+
+#ifndef __PTP_PTP_XILINX_H__
+#define __PTP_PTP_XILINX_H__
+
+#include <linux/ptp_clock_kernel.h>
+
+struct xlnx_ptp_timer {
+	struct device		*dev;
+	void __iomem		*baseaddr;
+	struct ptp_clock	*ptp_clock;
+	struct ptp_clock_info	ptp_clock_info;
+	spinlock_t		reg_lock; /* For reg access */
+	u64			incr;
+	s64			timeoffset;
+	s32			static_delay;
+	int			phc_index;
+	bool			use_sys_timer_only;
+	int			irq;
+	int			extts_enable;
+	u32			period_0;
+	u32			period_1;
+};
+
+#endif /* __PTP_PTP_XILINX_H__ */
