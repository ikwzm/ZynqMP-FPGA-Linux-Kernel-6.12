diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index d011d6c75..2687517b7 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -53,6 +53,7 @@ config USB_XHCI_PCI_RENESAS
 
 config USB_XHCI_PLATFORM
 	tristate "Generic xHCI driver for a platform device"
+	depends on USB_DWC3
 	help
 	  Adds an xHCI host driver for a generic platform device, which
 	  provides a memory space and an irq.
diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index e66604725..b6b0e9008 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -20,6 +20,7 @@
 #include <linux/acpi.h>
 #include <linux/usb/of.h>
 #include <linux/reset.h>
+#include <linux/usb/otg.h>
 
 #include "xhci.h"
 #include "xhci-plat.h"
@@ -30,6 +31,8 @@ static struct hc_driver __read_mostly xhci_plat_hc_driver;
 static int xhci_plat_setup(struct usb_hcd *hcd);
 static int xhci_plat_start(struct usb_hcd *hcd);
 
+static host_wakeup_t host_wakeup_fn;
+
 static const struct xhci_driver_overrides xhci_plat_overrides __initconst = {
 	.extra_priv_size = sizeof(struct xhci_plat_priv),
 	.reset = xhci_plat_setup,
@@ -81,6 +84,17 @@ static void xhci_plat_quirks(struct device *dev, struct xhci_hcd *xhci)
 	xhci->quirks |= priv->quirks;
 }
 
+static void host_wakeup_register(host_wakeup_t func)
+{
+	host_wakeup_fn = func;
+}
+
+static void host_wakeup_capable(struct device *dev, bool wakeup)
+{
+	if (host_wakeup_fn)
+		host_wakeup_fn(dev, wakeup);
+}
+
 /* called during probe() after chip reset completes */
 static int xhci_plat_setup(struct usb_hcd *hcd)
 {
@@ -142,6 +156,35 @@ static const struct of_device_id usb_xhci_of_match[] = {
 MODULE_DEVICE_TABLE(of, usb_xhci_of_match);
 #endif
 
+static int usb_otg_set_host(struct device *dev, struct usb_hcd *hcd, bool yes)
+{
+	int ret = 0;
+
+	hcd->usb_phy = usb_get_phy(USB_PHY_TYPE_USB3);
+	if (!IS_ERR_OR_NULL(hcd->usb_phy) && hcd->usb_phy->otg) {
+		if (yes) {
+			if (otg_set_host(hcd->usb_phy->otg, &hcd->self)) {
+				usb_put_phy(hcd->usb_phy);
+				goto disable_phy;
+			}
+		} else {
+			ret = otg_set_host(hcd->usb_phy->otg, NULL);
+			usb_put_phy(hcd->usb_phy);
+			goto disable_phy;
+		}
+
+	} else {
+		goto disable_phy;
+	}
+
+	return 0;
+
+disable_phy:
+	hcd->usb_phy = NULL;
+
+	return ret;
+}
+
 int xhci_plat_probe(struct platform_device *pdev, struct device *sysdev, const struct xhci_plat_priv *priv_match)
 {
 	const struct hc_driver	*driver;
@@ -170,6 +213,9 @@ int xhci_plat_probe(struct platform_device *pdev, struct device *sysdev, const s
 	if (ret)
 		return ret;
 
+	/* Set the controller as wakeup capable */
+	device_set_wakeup_capable(&pdev->dev, true);
+
 	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
 	pm_runtime_get_noresume(&pdev->dev);
@@ -235,6 +281,7 @@ int xhci_plat_probe(struct platform_device *pdev, struct device *sysdev, const s
 	}
 
 	device_set_wakeup_capable(&pdev->dev, true);
+	host_wakeup_register(dwc3_host_wakeup_capable);
 
 	xhci->main_hcd = hcd;
 
@@ -265,6 +312,9 @@ int xhci_plat_probe(struct platform_device *pdev, struct device *sysdev, const s
 		if (device_property_read_bool(tmpdev, "xhci-skip-phy-init-quirk"))
 			xhci->quirks |= XHCI_SKIP_PHY_INIT;
 
+		if (device_property_read_bool(tmpdev, "xhci-reset-on-resume"))
+			xhci->quirks |= XHCI_RESET_ON_RESUME;
+
 		device_property_read_u32(tmpdev, "imod-interval-ns",
 					 &xhci->imod_interval);
 	}
@@ -335,6 +385,10 @@ int xhci_plat_probe(struct platform_device *pdev, struct device *sysdev, const s
 			goto put_usb3_hcd;
 	}
 
+	ret = usb_otg_set_host(&pdev->dev, hcd, true);
+	if (ret)
+		goto dealloc_usb2_hcd;
+
 	device_enable_async_suspend(&pdev->dev);
 	pm_runtime_put_noidle(&pdev->dev);
 
@@ -433,6 +487,10 @@ void xhci_plat_remove(struct platform_device *dev)
 
 	usb_phy_shutdown(hcd->usb_phy);
 
+	host_wakeup_register(NULL);
+
+	usb_otg_set_host(&dev->dev, hcd, false);
+
 	usb_remove_hcd(hcd);
 
 	if (shared_hcd)
@@ -461,6 +519,17 @@ static int xhci_plat_suspend(struct device *dev)
 	ret = xhci_priv_suspend_quirk(hcd);
 	if (ret)
 		return ret;
+
+	/* Inform dwc3 driver about the device wakeup capability */
+	if (device_may_wakeup(&hcd->self.root_hub->dev)) {
+		host_wakeup_capable(dev, true);
+		enable_irq_wake(hcd->irq);
+		xhci->quirks &= ~XHCI_RESET_ON_RESUME;
+	} else {
+		host_wakeup_capable(dev, false);
+		xhci->quirks |= XHCI_RESET_ON_RESUME;
+	}
+
 	/*
 	 * xhci_suspend() needs `do_wakeup` to know whether host is allowed
 	 * to do wakeup during suspend.
@@ -546,6 +615,9 @@ static int __maybe_unused xhci_plat_runtime_resume(struct device *dev)
 	struct usb_hcd  *hcd = dev_get_drvdata(dev);
 	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
 
+	if (device_may_wakeup(&hcd->self.root_hub->dev))
+		disable_irq_wake(hcd->irq);
+
 	return xhci_resume(xhci, PMSG_AUTO_RESUME);
 }
 
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 358ed674f..09e616275 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -212,7 +212,11 @@ int xhci_reset(struct xhci_hcd *xhci, u64 timeout_us)
 
 	xhci_dbg_trace(xhci, trace_xhci_dbg_init, "// Reset the HC");
 	command = readl(&xhci->op_regs->command);
+#ifdef CONFIG_USB_DWC3_OTG
+	command |= CMD_LRESET;
+#else
 	command |= CMD_RESET;
+#endif
 	writel(command, &xhci->op_regs->command);
 
 	/* Existing Intel xHCI controllers require a delay of 1 mS,
@@ -226,7 +230,12 @@ int xhci_reset(struct xhci_hcd *xhci, u64 timeout_us)
 		udelay(1000);
 
 	ret = xhci_handshake_check_state(xhci, &xhci->op_regs->command,
-				CMD_RESET, 0, timeout_us, XHCI_STATE_REMOVING);
+#ifdef CONFIG_USB_DWC3_OTG
+			CMD_LRESET,
+#else
+			CMD_RESET,
+#endif
+			0, timeout_us, XHCI_STATE_REMOVING);
 	if (ret)
 		return ret;
 
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 439767d24..1de98bcc2 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1836,6 +1836,14 @@ void xhci_remove_secondary_interrupter(struct usb_hcd
 
 /* xHCI host controller glue */
 typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);
+typedef void (*host_wakeup_t)(struct device *dev, bool wakeup);
+#if IS_ENABLED(CONFIG_USB_DWC3_HOST) || IS_ENABLED(CONFIG_USB_DWC3_DUAL_ROLE) || \
+	IS_ENABLED(CONFIG_USB_DWC3_OTG)
+void dwc3_host_wakeup_capable(struct device *dev, bool wakeup);
+#else
+static inline void dwc3_host_wakeup_capable(struct device *dev, bool wakeup)
+{ }
+#endif
 int xhci_handshake(void __iomem *ptr, u32 mask, u32 done, u64 timeout_us);
 int xhci_handshake_check_state(struct xhci_hcd *xhci, void __iomem *ptr,
 		u32 mask, u32 done, int usec, unsigned int exit_state);
